---
title: "An Investigation Into The Use Of Socio-Demographics For The Location Analysis Of 'Zero-Waste' Shops In England & Wales"
#author: "Student id: 201578497"
geometry: "left=1.2cm,right=1.2cm,top=1.5cm,bottom=1.5cm"
output:
  pdf_document: 
    latex_engine: xelatex
    fig_caption: yes
    # toc: yes
  
header-includes:
# Use the packages
  - \usepackage{setspace}
  - \usepackage{lastpage}
  - \usepackage{fontspec}
  - \usepackage{placeins}
  - \usepackage{fancyhdr}
  - \usepackage{biblatex}
  - \setlength\bibitemsep{1.5\itemsep}
# Set the font
  - \setmainfont{Calibri}

# Set line spacing
  - \onehalfspacing

# Header and Footer Settings
  - \fancyhf{}
  - \pagestyle{fancy}

# References and bibliography settings
csl: C:/Users/James/OneDrive/Documents/R/win-library/4.1/markdown/csl/UoL_Harvard.csl

#csl: https://www.zotero.org/styles/harvard-university-of-leeds
bibliography: references.bib
---

```{=tex}
\fancyhf{}
\thispagestyle{fancy}
\fancyhead[R]{201578497}
\fancyhead[L]{GEOG3050}
\rfoot{\thepage\ of \pageref{LastPage}}
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	error = FALSE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE,
	comment = "",
	tidy = FALSE
)
cache.val = T

# Load / Install packages-------------------------------------------------------
#install.packages("", dependecies = TRUE)
library(knitr)
library(sf)
library(kableExtra)
library(ggplot2)
library(basemaps)
library(mapview)
library(openrouteservice)
library(ggspatial)
library(stringr)
library(patchwork)
library(dplyr)
library(rgdal)
library(viridis)
library(corrplot)
library(tidyr)
library(tidyverse)
library(sp)
library(maptools)
library(rgeos)
library(readxl)
library(gridExtra)
library(psych)
library(reshape2)
library(sjmisc)
library(spatstat)
library(raster)
library(ggthemes)
library(RColorBrewer)
library(ggrepel)

#API Key info - should only need loading once -  500
# ors_api_key("5b3ce3597851110001cf62480f8858be0885487ca2a78900b689815b")

# Extra 500
# ors_api_key("5b3ce3597851110001cf62481c9976fe80734502bc28ff74af4e101e")

#API Key info - should only need loading once -  2500
ors_api_key("5b3ce3597851110001cf624810789863e851418a86e0341fb278a772")
```

\FloatBarrier

\maketitle

------------------------------------------------------------------------

\newpage

# Acknowledgements

Thanks everyone

------------------------------------------------------------------------

\newpage

# Abstract

WRITE THE ABSTRACT HERE

------------------------------------------------------------------------

\newpage

\tableofcontents

\listoffigures

\listoftables

\newpage

# Introduction

### *Research Questions*

This research will investigate the importance of demographics in relation to environmentally conscious consumerism, and how far these socio-demographic characteristics may be used in the analysis of zero waste stores in terms of optimal locations.

-   Can socio-demographic data (education level, occupation type, vehicle access, household composition, and tenure) be used to help in the understanding of the location of zero-waste stores?
-   Can the variables used in this study be used to provide evidence of environmentally conscious behaviour and therefore the likely customer base of the stores in the catchment areas?
-   Are these variables able to be used to find gaps in potential market provision?\

### *Aims*

There has been extensive research that concentrates on the importance of household waste, packaging, or the concept of zero-waste in general, and packaging in general, including its role in places such as zero-waste stores and supermarkets such as ([@scharpenberg2021]; [@sastre2022]; [@mollaloGISbased2020]). Demographic analysis is also a widely studied area in the social sciences and in retail more specifically. It's use by both of these areas of research, and in relation to the potential links between environmentally conscious behaviour and environmentally ethical store locations however, at the time of writing, is non-existent. This indicates an important gap in both ethical retail (consumer and provider), and more generally, environmentally conscious social, behavioural, knowledge.

This study aims to...

-   Provide evidence of a customer base for this sector of retail, based on the demographic analysis of defined catchment areas
-   Provide the most likely optimal retail centre locations for new stores based on this demographic analysis\

### *Objectives*

To meet the aims of the study, the following objectives should be completed: -

-   Create a scorecard for each area that is currently served by a zero waste store
-   Ascertain distributions of selected socio-demographics of the areas around the stores
-   Investigate any similarities in the retail centre configuration / geography of these locations
-   Analyse similarities in the non-serviced locations for potential new stores
-   Identify limitations of the study in terms of variables used
-   Propose further research and improvements to methodology

The objectives will be met through gathering data from various sources such as the Consumer Data Research Centre (CDRC), Office for National Statistics (ONS), Open Street Map (OSM), and Nomisweb. Patterns of similarity of the chosen variables may help to highlight those factors that have the potential to allow an accurate picture of the surrounding areas of known existing zero-waste stores to be built up. By drawing upon the literature around the analogue method for location allocation, and the methods for creating composite indicators, a scorecard will be produced. This will provide the basis for analysis of the areas containing stores, which will provide the ability for evidence based analysis of locations that are not currently serviced by a store, and whether there are any locations that display good potential customer base.

\newpage

# Literature Review

This section will review the literature on the most relevant and important methods of store location planning that are employed by the retail sector. Each will be discussed and critiqued for appropriateness for use in this study. A review of studies that focus on environmentally conscious (EC) consumption behaviours and associated demographic profiles will be carried out. This will provide the justification for the decisions taken around the choices of data variables that will be used in the chosen method for this piece of work.

Waste, as a general concept; in particular packaging waste, and the way in which we all as consumers can tackle the associated issues with the latter will be discussed. A brief history of waste will be described for context, including some of the problems that are associated with production and consumerism. The review will move on to research in relation to zero-waste lifestyles and the changes in attitudes and practices towards EC consumption. Insight in to the growth of zero-waste shops and the related product solutions that are linked to these, which help move retail towards zero-waste consumer practices will then be addressed. The focus will finally move towards how these solutions are being practised in England and Wales.\

### *Zero Waste Concept: Then & Now*

Prior to industrialization, society produced very little waste [@mauch2022]. People would feed livestock with leftover food, repair broken items, and household goods such as furniture would be handed down to the next generation. With the advent of industrial capitalism in the mid-nineteenth century, production was designed to maintain itself, and old products discarded when a new, or better product is made available. This is the defining feature of consumerism [@graeber2011]. After World War II the world inevitably saw a huge rise in waste of all kinds due to mass-production and mass-consumerism. As Figure \ref{globalwaste} shows, the amount of waste generated globally in 1965 was around 635 million tonnes (mt) increasing to 1999 mt in 2015, and is projected to rise to 3539 mt by 2050 [@chen2020]. This trajectory is clearly a problem that is becoming increasingly urgent to address.

\FloatBarrier

![Global Yearly Waste Production by Type [@chen2020]\label{globalwaste}](Images/Globalwaste.png){width="514"}

\FloatBarrier

The term "zero waste" was coined in 1973 by Paul Palmer [@zaman2015] in relation to the reusable "clean" chemical waste being produced in Silicone Valley. He started selling these 'waste' chemicals back to the industry with the principal strategy that everything should be reused rather than used once and discarded [@mauch2022]. The term evolved over the following years and today, there now seems to be no consensus on the definition as such [@pietzsch2017]. Zero-waste as a term, now encompasses the theory, practice, and learning of governments through to individuals, and is a catch-all term for the response to the perceived crisis of waste and the failure to manage it [@hannon2018].

In England in 2002 for example, it was estimated that producers accounted for 91% of national waste [@murray2002]. Within the manufacturing and production sector for example, zero-waste as a concept is an effective way to help minimise solid waste, and through redesign, resource life cycles enable products to be reused [@song2015].

From a consumer perspective, food waste reduction has become one of the biggest areas of concern for zero waste research [@zhang2022]. Around one third of all the food bought is thrown away in England [@murray2002], and environmental deterioration that is caused by this non-sustainable consumption impedes sustainable development [@chekima2016; @badowska2019]. Food waste is intinsically linked to packaging. Food retail uses the highest amount of plastics and is the reason why packaging makes up the largest constituent of plastic waste [@sastre2022]. Figure \ref{globalplastic} shows that global plastic production in 2015 was just under 350 mt with over 35% of all plastic produced being used for packaging (see figure \ref{plasticuses}).

\FloatBarrier

![Global Plastic Production : 1950 - 2015 [@beckman2018] \label{globalplastic}](Images/WorldPlastic_1950_2015.png){width="300"}

![The different uses of plastic. [@beckman2018] \label{plasticuses}](Images/Plastic_use.png){width="300"}

\FloatBarrier

Figure \ref{ancum_plastic} shows that around 10 mt of plastics that are produced end up in the worlds oceans. Although the annual amount is predicted to fall, the cumulative effect of adding to the problem, is estimated to rise, albeit slower, to over 1500 mt by 2100.

\FloatBarrier

![Annual and Cumulative Plastic Input into Oceans [@chen2020]\label{ancum_plastic}](Images/ann_cum_plastic.png){width="514"}

\FloatBarrier

The problem of waste in food retail can partly be addressed through product design, where packaging can be produced to have as little impact on the environment as possible. The idea of minimising environmental damage from packaging and it's relationship with sustainability has indeed seen a large increase in research and literature [@sastre2022], and in the UK there have even been trials of changes to packaging free retail in some of the larger supermarket chains.

In 2019, Waitrose launched a trial in its Oxford store where it dedicated a section of the floor-space to a new refill station, where cleaning materials, wine, and dried goods such as rice were made available to customers that wanted to use their own reusable containers. By testing this method of shopping in-store, they were able to gauge how much appetite there was for a different type of shopping experience [@smithers2019]. They have in turn shown how significant the role of the consumer is in how food retail operates. and the problem of food waste and how a move to sustainable consumerism can be achieved. Due to the success of the trial of Waitrose 'Unpacked', they introduced the refill options to three other stores, and as interest and demand grows, they hope to offer the 'Unpacked' option in more stores and online over time [@waitrose&partners].\

### *Zero Waste Shops (supply)*

Zero-waste shops are shops that are dedicated to eliminating all unnecessary waste from the retail consumer experience [@watson2020]. They do this with practices that eliminate plastic packaging by displaying products in bulk where they can, and customers bring their own containers for items, or use paper bags supplied by the store. They also aim to send all food that expires to food-banks or community kitchens, further eliminating waste. Bulk purchasing of saleable products is another goal, which minimises transport waste products such as CO~2~ and NO~x~ pollution. Another important aim for zero-waste shops is to stock products with known origins from suppliers with similar priorities that are as local as possible [@believeearth2017, @bartek2022].

Zero-waste shops, using these practices, can help in the building of a sense of community. They are often small neighbourhood stores that have been started though crowd-funding or another local campaign [@greenpeaceusa2019]. This allows for the community around them to be involved from the start and provides a sense of investment in the success of the future of the store.

However, as the demand for sustainable retail rises, the competition for customers will increase, and as Waitrose have already stated, the larger stores will be able to offer more choice than perhaps the smaller dedicated local stores are able to do. This may mean that product choice in the larger retailers will be greater, but as described above, there is more to EV retail than simply packaging and the elimination of plastic. The larger retailers will also have to consider the ethical choices made by consumers in relation to the environmental impacts of supply chains, and the related support for local producers and other businesses.\

### *The customer (demand)*

Because the local community tends to provide the customers ro demand for these shops, an important question to answer is one that asks who these customers are likely to be. There are conflicting results from various studies that contradict the demographic characteristics that were found to influence and drive EC behaviour in terms of retail decisions. For example, a survey to identify the levels of environmental awareness in consumers was carried out in Slovakia. It targeted the age groups between 1965-1980 (*gen' x*) and 1981-1996 (*gen' y*), due to these groups greater purchasing power over other groups. They found that amongst the *gen' y* group, 39% were likely to use zero-waste stores often as opposed to 10% of the *gen' x* group [@holotova2020]. This suggests that age is an important variable when analysing the demographics of the customer base of zero-waste stores. @diamantopoulos2003 highlights the weakness in using socio-demographics to try to define a 'green consumer', as 'environmental awareness' is not fully understood through gender, age and education etc. However, there are a large number of studies including [@sang2015; @bekhet2011; @yuan2013; and @zhao2014], who have all found contradictory evidence that EC 'behaviours' are strongly associated with demographic characteristics such as age, education, occupation type, and income to name a few.\

## Store planning

### *Demographics*

In order to analyse the potential of a location, retailers need to know the market demand that exists. To do this, they use, amongst other data, geodemographic classifications that have been aggregated from census and other sources. Data are aggregated in to small areas such as post-code, or the Output Area Classification [@birkin2017]. Potential customers must be identified from the data and in the case of the zero-waste store, EC or green consumer behaviours and characteristics are essential in understanding the demand.

The census provides a snapshot of the age ranges, ethnicities, population density, household compositions, housing type and socio-economic make-up and employment classifications for example, in each area. This data can in turn be used to target specific groups based on the demand for a particular service.

Around 86% of the UK population is classed as urban and as with many cities across the globe, population growth is expected to result in over 90% of the worlds population living in cities, with the waste that is produced in them also growing [@statista]. It is known that urban populations are more likely to be highly educated, and gain higher incomes [@wensing2023a], therefore adults that have a high education level must be considered as potential ethical consumers in the first instance [@paul2016; @chekima2016]. Gender and age are also indicators of EC consumerism. @gilg2005 found that 65% of committed environmental behaviours in relation to consumerism were attributed to females in the study, with the mean age being 55 years, but in the UK, 18-24 was the age at which females are especially likely to consume ethically.

One problem with the averaging of such characteristics, to gauge demand for example, is known as the ecological fallacy [@openshaw1984]. This is essentially when an averaged characteristic of an area is applied to the individual scale, which potentially ignores or fails to recognise finer detail in demographic make-up of an area. For example, an area may be calculated to be wealthy on aggregate, but within that region there may be a pocket of poverty that missed, resulting in that population being ignored when planning social and financial support, thus increasing the inequalities that may exist.\

### *Catchment Area*

Defining the catchment area for a store is a highly important aspect of retail location analysis. To do this, a possible solution is to draw an arbitrary boundary around the store location and include the population within that boundary as potential custom [@hernandez2000]. A more realistic catchment area definition would be to estimate how far a customer will travel, either by foot, car, or by public transport, to a store location. An isochrone defines the boundary that is the limit of distance accessibility within a time using a specified mode of locomotion from a specified point. A 20 minutes walk time to a store location could be used for example, and would take in to account terrain and route layout [@openrouteservicea].

Using a buffer and overlay system available in Geographial Information System software can also build an accurate picture of an area through the addition or removal of features. For example, a discount retailer looking for a new store location may filter out customers from a higher income class in an area leaving lower income populations in the analysis data [@birkin2017]. It may also provide a better picture of the residential make-up of an area, by allowing for non-residential areas to be accounted for. This can be used in conjunction with a network analysis, in which accessibility can be further investigated which entails a more comprehensive analysis of road networks to deduce the travel times to the providers of a service [@birkin2017].\

### *Location Choice*

Once various locations have been identified, a choice must be made. There are numerous methods for choosing a location of a store, and these can range from the more simple to highly complex. The simpler, cheaper and traditional approach, where experience tells the planner where to locate a store has not entirely been replaced by the more complex methods such as checklists or scorecards [@hernandez2000].

Checklists involve the scoring of a number of chosen variables that positively influence store performance. The variables are rated according to a points system which when combined, can be used to compare other potential locations [@hernandez2000]. This is part of an analogue method of location analysis, in which, once the demographic and retail centre classification variables to be used for the scorecard have been identified, each catchment area can be classified. It is apparent that this technique can be used to investigate the similarities and differences between each location, providing a picture of the customer base for a particular type of shop (in this case; zero-waste stores). Although this method is good at providing a rating of different locations based on potential customers, and allows comparisons between locations to be made, it is unable to estimate revenue [@birkin2017]. This study is not seeking to estimate the success or failure of a store on predicted or current revenue data due to this data being unavailable.

Multi-variate regression methods are more complex still, and require a great deal of (good quality) data, computing power, and expertise. Decisions are based upon statistically significant results [@hernandez2000]. These methods are good at benchmarking sales forecasting, for example, and mainly used for future development for specific products, or new stores. The same restrictive factors such as computing power are also prevalent in methods such as cluster and factor analysis, where a retailers portfolio can be clustered in to types of offering and used to create a blueprint for strategic change, such as creating discount lines to be sold in cheaper stores based in lower income demographic areas.

Gravity modelling, Spatial Interaction Models (SIMs), and neural network methods are even more complex and expensive to facilitate, in terms of expertise, computing and data. SIMs generally rely on the availability of data such as flows of revenue for example [@birkin1999]. They show the relationships between the flow of consumers and revenue, and are used in the analysis of a new store, or a competitor opening in a location, and the effect it will have on existing provision and revenue. [@hernandez2000]. Neural networks are essentially a scaled up version of this and are used to forecast performance related to a large number of new sites.

It has been suggested that statistical modelling such as regression analysis and Spatial interaction Modelling based on the link between flows of money are useful tools for retail location analysis and site planning [@wood2007; @birkin2017; @hernandez2000], however, access to sales data is highly restricted and hard to access for resource limited studies.

## *Conclusion*

Waste in general, but specifically plastic waste has become an increasingly important problem for society and the health of planet. Packaging of food and other household items is one of the main contributors to plastic waste, so it is vital that the aim is to reduce this burden as much as possible. The severe (none at the time of writing) lack of research in to the problem of where zero waste stores are ideally located means that the aims of this study are an important addition to the literature and knowledge of sustainable retail. The study will attempt to find out whether socio-demographic characteristics can signify potential customer bases for these stores, and therefore help to define the best locations for them. Using carefully chosen demographic features, a scorecard or rating system wll be applied to the calculated catchment areas, which in turn will allow comparisons to be made between the stores and their surrounding demographics based upon EC consumer behaviour. This information can then be extended to look for applicable potential retail centres with demographically similar areas, in which one would expect to find a similar store.

\newpage

# Methodology

In order to achieve the objectives set out in the previous section, a quantitative approach was taken to determining the demographics that surround the locations of the stores in the study area. This included the creation of a scorecard for each location, based on the selected demographic variables. The scorecards were then used to identify similar locations of the study area in which stores could be expected to be found. By incorporating statistical and geospatial techniques to the analysis of the data, and presenting the results of the study through geographical and statistical representation, a landscape of ethical consumption will be built up and visualised. This analysis will feed in to the discussion of the rationale behind the choices of variable used in the data, the methodological approach taken and an evaluation of the results.

### *Zero Waste Store Location Data*

Location data for the stores to be used was retrieved using the metadata of the The Zero Waste Network (ZWN)[@thezerowastenetwork] website. This was, by comparison to other similar website's and directories, the most comprehensive listing found. Table \ref{tab:zws} shows examples of the raw data used.

```{r zwstab}
# Uses library(kableExtra)
# Load zws RDS file
zws <- readRDS("zws.rds")
# Display a table of the first 10 records
kable(zws[1:10,], caption = "\\label{tab:zws}Selected zero-waste stores data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(zws)
```

These data were cleaned through Google searches to identify and remove any stores that were irrelevant to the study, such as incorrectly listed stores, wholesalers, and mobile refill vehicles, and also to highlight any that had closed since being listed. Of the initial 172 stores, 135 remained. To ensure that the remaining stores had correct coordinate data and sat within the study area, a plot of all the locations was made and can be seen in figure \ref{zwstores}.

![Map of all Zero Waste Stores in Study Area. \label{zwstores}](Images/zwsmap.png){width="400"}

### *LSOA Area Scale Boundary Data*

Lower Super Output Area (LSOA) data was downloaded for the study area from the Open Geography Portal [@opengeographyportala]. This related to the latest 2021 boundaries at the LSOA scale and includes the LSOA identifier and the attached geometries. LSOA scale data was chosen so that the number of households or individual populations within each area were small enough to allow for a good level of accuracy when comparing the demographic composition of an area. Output areas (OA) scale data provides a more granular scale that LSOA scale data, however, at the time of data extraction, all the chosen demographic variables were not available at the OA level, so LSOA scale data was to provide consistency across the variables.\

```{r lsoa_table}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoas <- readRDS("lsoas.rds")

# # remove the scores from the lsoa data
# lsoas = lsoas |> select(-one_of('occrank', 'tenrank', 'carrank', 'pplrank', 'dedrank'))

kable(lsoas[1:5,c(1,3,9)], caption = "\\label{tab:lsoas}LSOA boundary data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

### *Demographic data*

Nomisweb provided the latest Office for National Statistics, 2021 census data, at the LSOA scale [@nomis]. LSOA area codes were included to provide linked identifiers for GIS processing. The demographic variables were found under the following identifiers: -

TS003 - Household composition

This dataset included those households that were classified as either, married single family households with no children, or, cohabiting couple households with no children. See Table \ref{tab:pplscr}. Household composition amongst committed environmentalist in the results of the study by @gilg2005 was smaller, with two person households accounting for 40%. This household composition suggested greater income levels because firstly, they had sufficient means to combine to either obtain a mortgage or rent, and due to the fact that there were no children in the make-up of the household, indicated a higher level of disposable income. Behaviourally, as @tonglet2004 points to, cohabiting couples that share values, can be more likely to encourage EC behaviours and more ethical decisions.

```{r 2ppl_data, echo=FALSE}
pplscr <- readRDS("pplscr.rds")
# pplscr <- pplscr[order(pplscr$mnemonic),]
# # Create a table for the Household composition data 
# Load the 2ppl data
# pplscr <- read.csv("2ppl.csv")
# # remove the country row
# pplscr = pplscr[-c(33756), ]
# pplscr = as.data.frame(pplscr)
# 
# # clean the unrequired columns
# pplscr = pplscr |> dplyr::select(-one_of('Total..All.households', 'X.', 'Single.family.household..Married.or.civil.partnership.couple..No.children', 'X..1', 'Single.family.household..Cohabiting.couple.family..No.children', 'X..2', 'tot_.', 'score_calc', 'hhld_.'))
# 
# pplscr <- pplscr  |> dplyr::rename_at('mnemonic', ~'LSOA21CD')
# pplscr <- pplscr |> dplyr::rename_at('X2021.super.output.area...lower.layer', ~'Area')
# pplscr <- pplscr |> dplyr::rename_at('score', ~'pplscr')
# pplscr <- pplscr  |> dplyr::rename_at('Single.family.household..All.aged.66.years.and.over', ~'2ppl >66yrs')
# saveRDS(object = pplscr, file = "pplscr.rds")

kable(pplscr[1:5,c(1,2,3,7)], row.names = F, caption = "\\label{tab:pplscr}Total LSOA scores for household composition data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "1in") |> 
  column_spec(4,width = "0.75in") 
remove(pplscr)
# saveRDS(object = pplscr, file = "pplscr.rds")
```

TS045 - Car or van availability

This dataset included those households that were reported as having access to a single vehicle only. See Table \ref{tab:carscr}. Vehicle availability was chosen due the balance that is required between EC choices and behaviours that are made. Simply put; even the most EC consumer has to travel, and sustainable behaviour is influenced by both the reasons why travel is required, and the transportation environment. Employment is a major factor related to reasons for travel and public transport is not the most convenient and efficient mode. Many people balance these necessary travel requirements with environmental concerns and self-limit their impacts on the environment by minimising their own vehicle access [@taube2018]. This is also supported by the study in to sustainable lifestyles and green consumption by @gilg2005. In this they found that in each of the survey respondent clusters, more than 50%, limited themselves to a single vehicle.

```{r car_table, echo=FALSE}
carscr <- readRDS("carscr.rds")
# carscr <- carscr[order(carscr$LSOA21CD), ]
# 
# # # Load the vehicle access data
# # carscr <- read.csv("1car.csv")
# # # clean the unrequired columns and rename them for ease of use
# carscr = carscr |> dplyr::select(-one_of('score_calc', 'X.'))
# # carscr <- carscr  |>  dplyr::rename_at('X2021.super.output.area...lower.layer', ~'Area')
# # carscr <- carscr  |>  dplyr::rename_at('score', ~'carscr')
# # carscr <- carscr  |>  dplyr::rename_at('mnemonic', ~'LSOA21CD')
# carscr <- carscr  |>  dplyr::rename_at('Total..All.households', ~'total_hhld')
# carscr <- carscr  |>  dplyr::rename_at('X1.car.or.van.in.household', ~'hhld_vehicles')
# saveRDS(object = carscr, file = "carscr.rds")

kable(carscr[0:5,1:4], row.names = F, caption = "\\label{tab:carscr}Total LSOA scores for single vehicle access data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(carscr)
```

TS054 - Tenure - Home Ownership

This variable included those households that were reported as having either owning their own homes outright, or under a mortgage. See Table \ref{tab:tenscr}. Tenure, and home ownership was identified as highly likely, amongst those participants that were classified as the most committed to sustainable consumption [@gilg2005]. The variable aids the implication that those who can afford their own homes provides a link to a partial proxy for the unavailable earnings data.

```{r tenure_table, echo=FALSE}
tenscr <- readRDS("tenscr.rds")
# tenscr <- tenscr[order(tenscr$LSOA21CD),]
# # Load the tenure data
# #tenscr <- read.csv("tenure.csv")
# 
# # clean the unrequired columns and rename them for ease of use
# tenscr = tenscr |> dplyr::select(-one_of('score_calc', 'X.', 'sum'))
# # tenscr <- tenscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
# # tenscr <- tenscr  |>  rename_at('score', ~'tenscr')
# # tenscr <- tenscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# # saveRDS(object = tenscr, file = "tenscr.rds")
# tenscr <- tenscr  |>  dplyr::rename_at('Total..All.households', ~'hhld_total')
# tenscr <- tenscr  |>  dplyr::rename_at('Owned..Owns.outright', ~'Owned')
# tenscr <- tenscr  |>  dplyr::rename_at('Owned..Owns.with.a.mortgage.or.loan', ~'Mortgage/loan')
# 
# saveRDS(object = tenscr, file = "tenscr.rds")

kable(tenscr[1:5,1:5], row.names = F, caption = "\\label{tab:tenscr}Total LSOA scores for home owners that own outright or mortgage data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(tenscr)
```

TS067 - Highest level of qualification - degree educated

Education level data was included only for those people that have degree level education or above, and can be seen in table \ref{tab:dedscr}. @gilg2005 found that active and committed environmental behaviour was most prominent among those with a level of education at degree or higher. This was a finding that was also found to be important by @han2010, in which they found that more than 80% of the respondents to their study relating to green consumer decision making were degree educated. Education level is also highlighted as an important factor in the ability to have a good level of understanding of the complexity of environmental issues, and can be a driver of green behaviour [@chekima2016].

```{r deg_ed_table, echo=FALSE}
dedscr <- readRDS("dedscr.rds")
# dedscr <- dedscr[order(dedscr$LSOA21CD),]
# # Load the degree educated data
#  dedscr <- read.csv("degree_educated.csv")
# # 
# # # clean the unrequired columns and rename them for ease of use
#  dedscr = dedscr |> dplyr::select(-one_of('X.', 'MinMax'))
# #  dedscr <- dedscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
#  dedscr <- dedscr |> dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over', ~'residents_total')
#  
#  # dedscr <- dedscr |> dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over', ~'residents')
#  # dedscr <- dedscr |> dplyr::rename_at('score', ~'dedscr')
#  # dedscr <- dedscr |> dplyr::rename_at('mnemonic', ~'LSOA21CD')
# #  
# saveRDS(object = dedscr, file = "dedscr.rds")

kable(dedscr[1:5,1:4], row.names = F, caption = "\\label{tab:dedscr}Total LSOA scores for degree education level or above data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(dedscr)
```

TS063 - Occupation

Occupation data included those people whose occupations were classified as managers, directors, senior officials, and professional occupations. See Table \ref{tab:occscr}. This variable is somewhat related to the level of education, but more importantly ties in with the search for a valid proxies for higher income levels. These occupations can be seen as those that pay the most, and are also filled by people that are educated to degree level or above, and therefore earn more on average [@departmentforeducation]. It was chosen as a suitable variable for these reasons and for the fact that individual income data is unavailable.

```{r occ_data, echo=FALSE}
occscr <- readRDS("occscr.rds")
# occscr <- occscr[order(occscr$LSOA21CD),]
# # Load the occupation data
# occscr <- read.csv("occ.csv")
# 
# # clean the unrequired columns and rename them for ease of use
# occscr = occscr |> dplyr::select(-one_of('X.', 'X..1', 'X..2', 'calc'))
# 
# occscr <- occscr  |>  dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over.in.employment.the.week.before.the.census', ~'residents_total')
# 
# occscr <- occscr  |>  dplyr::rename_at('X1..Managers..directors.and.senior.officials', ~'managers/directors')
# 
# occscr <- occscr  |>  dplyr::rename_at('X2..Professional.occupations', ~'professionals')
# 
# occscr <- occscr  |>  dplyr::rename_at('high_earners.', ~'high_earn_total')
# 
# #  occscr <- occscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
# #  occscr <- occscr  |>  rename_at('score', ~'occscr')
# #  occscr <- occscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# 
# # 
 # saveRDS(object = occscr, file = "occscr.rds")

kable(occscr[1:5,1:6], row.names = F, caption = "\\label{tab:occscr}Total LSOA scores for higher rated occupations for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(occscr)
```

Using excel to process the .csv files, the percentages were calculated from reported total households or individual populations for each of the 5 variables, and each was standardised using the scaling method in which, for each variable, each LSOA was given a score / ranked from 0 to 1. The following formula was used for this:-

$$
x_{norm} = (x_{raw} - min_{i})/(max_{i} - min_{i})
$$

These rankings were then multiplied up by 10 and rounded to the nearest integer to provide a final score for each individual LSOA for each variable between 0 and 10 inclusive.

It was decided that there would be no different weightings given to any of the variables. There could be an argument to increase the weighting for either the education level or occupation variable to act as a proxy for spending power, but it was decided that with both variables being used in the study, they would provide a natural weighting, and would therefore not require any adjustments.

###  *Combining score data and calculating totals*

The scores for each individual variable were allocated to the matching LSOA in the LSOA data. A total score for each LSOA was then calculated. The resulting dataset (see table \ref{tab:lsoa_scores} for examples), was inspected to provide assurance that the process had resulted in individual scores that ranged from 0 and 10 only, and total scores were within a 0 to 50 range. These scores would then be available when analysing the current store locations and the potential un-supplied retail centres.

```{r score_prep}
# Convert lsoas to a sf file format and set the CRS to 3857
# lsoas = st_as_sf(lsoas)



#### Create a dataframe that holds the LSOA21CD id and the score for each variable
# Convert the lsoas sf file to a data.frame
#lsoas = as.data.frame(lsoas)

# Join each variables score data to the LSOA data and remove the unrequired columns each time
# carscr
#lsoas = left_join(lsoas, carscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# dedscr
#lsoas = left_join(lsoas, dedscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# occscr
#lsoas = left_join(lsoas, occscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# pplscr
#lsoas = left_join(lsoas, pplscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# tenscr
#lsoas = left_join(lsoas, tenscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# sum the individual LSOA row values in columns 10 to 14 and add the result to a new column at the end after tenscr
#lsoas = lsoas |> 
#  mutate(lsoatotscr = rowSums(lsoas[,10:14], na.rm = TRUE),
#         .after=tenscr)

# remove unrequired temporary dataframes etc
#remove(carscr, dedscr, occscr, pplscr, tenscr)

# Save the lsoa data with the newly added individual scores and the calculated total scores
#saveRDS(obj = lsoas, file = "lsoas.rds")
# Load the results of the above code to save processing and memory when knitting
# lsoas <- readRDS("lsoas.rds")
```

```{r lsoa_score_table, echo=FALSE}
lsoas <- readRDS("lsoas.rds")

kable(st_drop_geometry(lsoas[1:5,c(1,3,10:15)]), row.names = F, caption = "\\label{tab:lsoa_scores}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

### *LSOA area scale population weighted centroids*

Population Weighted Centroids (PWC) data was retrieved at the LSOA scale from the Open Geography Portal [@opengeographyportal2022]. This data was required because once the stores and retail centre isochrones had been calculated, those isochrones that contained a PWC would be filtered and used to calculate the scorecard for each location. PWC data can be seen in table \ref{tab:lsoa_pwcs}.

```{r pwc_data, echo=FALSE}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoa_pwc <- readRDS("lsoa_pwc.rds")

kable(lsoa_pwc[1:5,c(2,4)], row.names = F, caption = "\\label{tab:lsoa_pwcs}LSOA population weighted centroid data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoa_pwc)
```

### *Retail Centres*

Retail centre boundaries for the study area were retrieved from the Consumer Data Research Centre [@consumerdataresearchcentre2022]. This data provided all retail centres in England and Wales, so that once analysis of all zero waste store locations had been completed, potential retail centres that lack the supply of this type of store could be identified. The retail centre data was processed through QGIS to identify the centroid of each polygon, which was then added to the main file and saved and can be seen in table \ref{tab:rc_data}.

```{r retail_centre_data, echo=FALSE}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
# retail_c <- readRDS("retail_c.rds")
all_rcs <- readRDS("all_rcs.rds")
# 
# # # # reindex the data
# # rownames(retail_c) <- 1:nrow(retail_c)
# # 
# # saveRDS(object = retail_c, file = "retail_c.rds")
# 
# retail_c <- retail_c  |>  dplyr::rename_at('Classifica', ~'Classification')
# saveRDS(object = retail_c, file = "retail_c.rds")

kable(st_drop_geometry(all_rcs[1:5,c(2:5)]), row.names = F, caption = "\\label{tab:rc_data}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(all_rcs)
```

### *Creating a test scorecard using a known store location*

To test and refine the methods to be used to process the full dataset of zero waste stores, a single test store was selected. This consisted of a store that was known and was situated in a known area, which allowed for the method to be corrected if problems arose.

The following test store results shows the process that will be followed for all ZWS. Once the ZWS data has been processed, the data for the retail centres that do not contain a zero waste store were be processed using the same methods. Table \ref{tab:bishytab} shows the store information data and figure \ref{fig:bishylocation}, a visual representation of the test area in question.

\FloatBarrier

```{r bishy_load, echo=FALSE}
# Load bishy store boundary shapefile
bishy <- readRDS("bishy.rds")

# Convert this to the correct 3857 CRS
# bishy = st_transform(bishy, crs = st_crs(3857))

# rename the geometry column
# bishy <- bishy  |>  rename_at('geometry', ~'store_location')

kable(st_drop_geometry(bishy[,1:7]), row.names = F, caption = "\\label{tab:bishytab}Test store data for the Bishy Weigh store in York, England")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T)
remove(bishy)
```

\FloatBarrier

```{r bishylocation, fig.height=4, fig.width=4, fig.cap="Location of The Bishy Weigh store in York", echo=FALSE}
bishy <- readRDS("bishy.rds")
ggplot(bishy) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  geom_sf(colour = "blue", aes(geometry = bishystorepoint, fill = st_nam)) +
  guides(fill = guide_legend(title = "Test Store Name")) +
  theme_void(base_size = 10) +
  theme(plot.margin = margin(t = 10,  # Top margin
                             r = 0,  # Right margin
                             b = 10,  # Bottom margin
                             l = 0)) # Left margin
remove(bishy, ywalktime20)
```

\FloatBarrier

### *Calculating the isochrone*

Using the OpenRouteService [@openrouteservice], a 20-minute walk-time isochrone was calculated around the test store to define the catchment area. This distance/time was chosen partly due to the individual health benefits of walking [@tschentscher2013; @sari2010], and partly to fit in with the concept of a chrono-urbanism and temporally accessible city design concepts such as the 15 and 20 minute city for example. Some of the benefits of these concepts include decreasing vehicle pollution and helping towards achieving the goal of 'net-zero' amongst others [@ogorman2021; @moreno2021].

Once the isochrone had been calculated from the test store, it was mapped to ensure that the correct store location and catchment area had been calculated. See Figure \ref{fig:york_isochrone_test_map}.

\FloatBarrier

```{r york_isochrone_test_map, fig.height=4, fig.width=4, fig.cap="20 minutes walking distance isochrone from The Bishy Weigh store in York", echo=FALSE}
bishy <- readRDS("bishy.rds")
# Uses library(ggspatial)
# Convert the walktime20 isochrone to the correct CRS
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
ywalktime20 <- readRDS("ywalktime20.rds")
# Map the 20 mins isochrone and store location
# use the walktime LAYER isochrone as the main data layer
ggplot(ywalktime20, aes(colour = "20 minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(fill = "darkgrey", alpha = 0.4) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red", size = 2,
          aes(fill = st_nam)) +
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(ywalktime20, bishy)
```

\FloatBarrier

After confirming that the isochrone calculation and store location data produced the desired results, the PWC data was clipped so that only those PWC that fell within the isochrone would be subsequently processed. This decision was made to ensure that only population centres and, importantly, the corresponding LSOA(s) that fell within the catchment area were included. If this was not taken in to consideration, the resulting scorecards could be open to possible inaccuracy. For example, the scorecards could be calculated using LSOA(s) that had a proportion of their boundary within the isochrone, but with PWC situated further than 20 minutes from the store and outside of the isochrone, resulting in scores that include populations that have a walk-time that is greater than 20 minutes. These results were then mapped to check method accuracy and can be seen in figure \ref{fig:bishy_pwc_clipped}.

```{r ypwc_clip, warning=FALSE}
# pwc_clip <- readRDS("pwc_clip.rds")

# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# lsoas = readRDS("lsoas.rds")
# lsoas = st_as_sf(lsoas)
# ywalktime20 = readRDS("ywalktime20.rds")
# ###################################################################################
# # Test plot an LSOA
# # ggplot(lsoas[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = lsoageometry))
# ###################################################################################
# lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
# lsoa_pwc = readRDS("lsoa_pwc.rds")
# lsoa_pwc = st_as_sf(lsoa_pwc)
# lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# lsoas = st_as_sf(lsoas)
# lsoas <- st_transform(lsoas, crs = st_crs(3857))
# lsoa_pwc = st_as_sf(lsoa_pwc)
# lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(3857))
# 
# # clip the PWCs to only show those inside the 20 minute walk time
# pwc_clip = lsoa_pwc[ywalktime20$geometry,]
# saveRDS(object = pwc_clip, file = "pwc_clip.rds")
###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = -1, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
#   geom_sf(data = pwc_clip, aes(geometry = pwcgeometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
#   guides(alpha = guide_legend(title = "Catchment Area")) +
#   theme_void()
##################################################################################
##################################################################################
# remove(bishy, lsoa_clip, lsoa_pwc, lsoas, pwc_clip, ywalktime20)
```

\FloatBarrier

```{r bishy_pwc_clipped, fig.height=4, fig.width=4, fig.cap="Population Weighted Centoids within the isochrone sourrounding The Bishy Weigh store in York", echo=FALSE}
bishy <- readRDS("bishy.rds")
pwc_clip <- readRDS("pwc_clip.rds")
ywalktime20 <- readRDS("ywalktime20.rds")
ggplot() +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
  geom_sf(data = pwc_clip, aes(geometry = geometry, shape = ""), size = 1) +
  guides(shape = guide_legend(title = "Population Weighted Centroids")) +
  geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
  guides(alpha = guide_legend(title = "Catchment Area")) +
  
  #   # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", which_north = "true", 
  #                        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 8)
remove(bishy, pwc_clip, ywalktime20)
```

\FloatBarrier

Once the PWC that sat within the isochrone were found, the corresponding LSOA for that catchment area were identified using the LSOA identifiers. These were then mapped to visualise the results and confirm the accuracy of the procedure. Figure \ref{fig:pwcs_lsoas_york_map} shows these results.

```{r}
# lsoa_clip <- readRDS("lsoa_clip.rds")
# pwc_clip <- readRDS("pwc_clip.rds")
# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# #lsoas = readRDS("lsoas.rds")
# #lsoas = st_as_sf(lsoas)
# 
# ###################################################################################
# # Test plot an LSOA
# # ggplot(lsoas[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = lsoageometry))
# ###################################################################################
# # lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
# lsoa_pwc = readRDS("lsoa_pwc.rds")
# # lsoa_pwc = st_as_sf(lsoa_pwc)
# # lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# # lsoas <- st_transform(lsoas, crs = st_crs(4326))
# # lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(4326))
# 
# # clip the PWCs to only show those inside the 20 minute walk time
# pwc_clip = lsoa_pwc[ywalktime20$geometry,]
# # clip the LSOAs to only show those for the clipped PWCs
# # lsoas <- st_transform(lsoas, crs = st_crs(3857))
# # pwc_clip <- st_transform(pwc_clip, crs = st_crs(3857))
# lsoa_clip = lsoas[pwc_clip,]

###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry, alpha = "")) +
#   # guides(alpha = guide_legend(title = "LSOAs")) +
#   geom_sf(data = pwc_clip, aes(geometry = geometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, fill = ""), alpha = 0.1) +
#   guides(fill = guide_legend(title = "Isochrone"))
# #################################################################################
```

```{r pwcs_lsoas_york_map, fig.height=4, fig.width=4, warning=FALSE, fig.cap="Map showing the clipped LSOAs related to the PWCs that fall inside the 20 minute walk time catchment area.", echo=FALSE}

lsoa_clip <- readRDS("lsoa_clip.rds")
pwc_clip <- readRDS("pwc_clip.rds")
bishy <- readRDS("bishy.rds")
ywalktime20 <- readRDS("ywalktime20.rds")

# Map the test store, isochrone and corresponding LSOAs and PWCs
ggplot(ywalktime20, aes(colour = "20 minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(data = lsoa_clip,  colour = "black", aes(alpha = ""), linetype = "11", size = 0.1) +
  geom_sf(data = pwc_clip, colour = "black", aes(shape = ""), size = 1) +
    geom_sf(fill = "darkgrey", alpha = 0.3) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red",
          aes(fill = st_nam)) +
  
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  guides(alpha = guide_legend(title = "LSOA Boundaries")) +
  guides(shape = guide_legend(title = "LSOA PWCs")) +
  # 
  # # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", which_north = "true", 
  #                        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 8)
remove(ywalktime20, lsoa_clip, pwc_clip, bishy)
```

\FloatBarrier

The resulting test store catchment area contained 18 population weighted centroids. The corresponding LSOA scores previously calculated for each variable were mapped individually. This was to provide both a picture of the spatial distribution of the variables and to ensure that the processing of the previous steps were providing results that were meaningful.

Figure \ref{fig:bishycar_map} shows the individual LSOA scores for households that have single vehicle access and evidence that no individual scores were above 10.

\FloatBarrier

```{r bishycar_map, echo=FALSE, fig.cap="Map showing individual lsoas vehicle access scores for the test store area", fig.height=3.5, fig.width=3.5, warning=FALSE}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")
ggplot(lsoa_clip) +
  geom_sf(aes(fill = carrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Access to a\nsingle vehicle", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ydedscr_map} shows the individual LSOA scores for individuals that have been educated to degree level or above and shows that no individual scores were above 10.

```{r ydedscr_map, echo=FALSE, fig.cap="Map showing individual LSOA scores for the dedscr variable which relates to percentage of population that is degree educated and above.", fig.height=3.5, fig.width=3.5, warning=FALSE}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = dedrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Degree Educated", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:yoccscr_map} shows the individual LSOA scores for individuals with the occupation types of managers, directors, senior officials, and professional occupations and also shows that no individual scores were above 10.

```{r yoccscr_map, fig.height=3.5, fig.width=3.5, warning=FALSE, fig.cap="Map showing individual LSOA scores for the occscr variable which relates to the populations with the highest occupation types.", echo=FALSE}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = occrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Highest occupation\ntypes", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ypplscr_map} shows the individual LSOA scores for households that consist of two people with no children, and again shows that no individual scores were above 10.

```{r ypplscr_map, fig.height=3.5, fig.width=3.5, warning=FALSE, fig.cap="Map showing individual LSOA scores for the pplscr variable which relates to percentage of households that contain 2 people with no children.", echo=FALSE}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = pplrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households with 2\npeople & 0 children", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy, ypplscr_map)
```

\FloatBarrier

Figure \ref{fig:ytenscr_map} shows the individual LSOA scores for households that either own their homes outright, or have purchased under a mortgage or loan, and also, again, shows that no individual scores were above 10.

```{r ytenscr_map, fig.height=3.5, fig.width=3.5, fig.cap="Map showing individual LSOA scores for the tenscr variable which relates to percentage of households that either own outright or mortgage their home.", echo=FALSE}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = tenrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households\nthat own or\nmortgage their home", reverse = TRUE, ncol = 2)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ytotscr_map} shows the total scores for each individual LSOA and shows that these totals do not sum to a value above 50.

```{r ytotscr_map, echo=FALSE, fig.cap="Map showing the total score for the 5 variables for each individual LSOA.", fig.height=3, fig.width=3, warning=FALSE}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")
ggplot(lsoa_clip) +
  geom_sf(aes(fill = lsoatotscr)) +
  scale_fill_viridis_c(breaks=seq(0,50,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Individual LSOA\ntotal scores",ncol = 3, reverse = TRUE)) +
    geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 8)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Once the total score for each LSOA had been calculated, these were combined to provide a total score for the area as a whole by summing the total score for each LSOA and dividing that total by the number of LSOAs in the area. Mean scores for each of the five variables was also calculated in the same way for future reference. This method was used to maintain equivalence across the subsequent store and retail catchment areas, and allow comparison between the scorecard results of each due to the fact that stores may have greater or fewer number of LSOAs within the catchment area, rendering them isolated in terms of data without comparison.

```{r}
# Create a new variable to hold the totals for the final joined data and convert to a data.frame # # CRS should be 3857 # 
#lsoa_clip_tot = as.data.frame(lsoa_clip)

# create a row in the lsoa_clip_tot dataframe for the total MEAN for all lsoas in the area and the total of those totals #   
#lsoa_clip_tot <- lsoa_clip_tot |>      
#  bind_rows(summarise(lsoa_clip_tot[,9:14], across(where(is.numeric), mean), #across(where(is.character), ~'Total')))
#lsoa_clip_tot = st_as_sf(lsoa_clip_tot)

# Join the lsoas to a single shape - USE THIS "JOINED_LSOAS" AS THE FINAL LSOA SHAPE
#gglpot() +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = lsoa_clip_tot$lsoageometry))

# Test Plot
#plot(st_union(lsoa_clip_tot$lsoageometry))
#joined_lsoas <- st_union(lsoa_clip_tot$lsoageometry)

# Create a temp df "FT" to hold the totals for the whole joined LSOAs for each variable
#ft <- data.frame(matrix(ncol = 6, nrow = 0))
#lsoa_clip_tot = as.data.frame(lsoa_clip_tot)
#ft = lsoa_clip_tot[nrow(lsoa_clip_tot),9:14]
#lsoa_clip_tot = st_as_sf(lsoa_clip_tot)

# sum the individual variables for the whole lsoa_clip_tot and add the result to the bottom of lsoa_clip_tot
#bishy = st_as_sf(bishy)
#joined_lsoas = st_as_sf(joined_lsoas)
#joined_lsoas <- st_transform(joined_lsoas, crs = st_crs(3857))


# Test Plot Bishy
#ggplot(bishy) +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = joined_lsoas$x)) +
#  geom_sf(aes(geometry = bishy$store_location))
# THIS WORKED 
###################################################################################

#joined_lsoas = st_as_sf(joined_lsoas)
#bishyjoined = cbind(bishy, round(ft[,1:6], digits = 0))
#bishyjoined = cbind(bishyjoined, joined_lsoas)
#bishyjoined <- bishyjoined  |>  rename_at('x', ~'joined_lsoas')

################################################################################## # # Test plot
#bishyjoined = st_as_sf(bishyjoined)
#bishyjoined <- st_transform(bishyjoined, crs = st_crs(3857))

#ggplot(bishyjoined) +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = bishyisochrone, alpha = ""), colour = "blue") +
#  guides(alpha = guide_legend(title = "20 minute walk time")) +
#  geom_sf(aes(geometry = joinedlsoageometry, fill = lsoatotscr), alpha = 0.2) +
#  guides(fill = guide_legend(title = "Joined LSOA\nTotal Score")) +
#  geom_sf(aes(geometry = bishystorepoint,  colour = "")) +
#  guides(colour = guide_legend(title = bishyjoined$st_nam))
# THIS WORKED
###################################################################################
#saveRDS(obj = bishyjoined, file = "bishyjoined.rds")
#bishyjoined <- readRDS("bishyjoined.rds")
```

Once the final total score had been calculated, the individual LSOAs spatial data was combined to a single polygon to make mapping clearer by removing the boundaries for the individual LSOAs in the area, and so that this boundary shape could be added to the relevant line in the store data. An example of this result can be seen in figure \ref{fig:final_bishy_map} below.

```{r final_bishy_map, fig.height=3, fig.width=3, fig.cap="Final map of the test store showing the catchment area, the joined LSOA and the corresponding total score for the area", echo=FALSE}
bishy <- readRDS("bishy.rds")

ggplot() +
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  
  geom_sf(data = bishy, aes(geometry = joinedlsoageometry, alpha = bishy$totalscore), fill = "darkgrey") +
  guides(alpha = guide_legend(title = "Joined LSOA & score")) +
  
  geom_sf(data = bishy, aes(geometry = bishyisochrone, shape = "" ), alpha = 0.1, colour = "red") +
  guides(shape = guide_legend(title = "Catchment Area")) +
  
  geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  
  theme_void(base_size = 10)

remove(bishy)
```

\FloatBarrier

### *Processing all stores*

Once the test store data had been processed and mapped to ensure validity, the data for all 140 zero waste stores, including the test store, were processed in full using the same processing steps as the test store. The results were combined with the location data in the zero waste store data for analysis.

Firstly, as with the test store, isochrones were calculated, PWC were found, and LSOA data was filtered accordingly.

```{r zws_iso_loop}
# Load the results file from the code below
# zwsiso <- readRDS("zwsiso.rds")

# remove(i, zws, zwsiso)
# 
# zws <- readRDS("zws.rds")
# # Loops throughthe zws file and creates a new dataframe (zwsiso) that holds the zws store data and the isochrone for the walktime20 mins boundary.
# 
# #############################################################################
# #                                                                           #
# #          Commented out to stop it running                                 #
# #                                                                           #
# #############################################################################
# # create a dataframe to hold the iso results
# zwsiso <- data.frame(matrix(ncol = 12, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(zws)) {
#   # create a df variable to hold the zws values from row i of zws
#  isodf = zws[i,]
#   # embed data in the output file rather than html streaming option
#  mapviewOptions(fgb = FALSE)
#   
#   # Get the coordinates of the store in the (df)
#  coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   
#   # if there are no coordinates - skip to the next zws record
#    if(is.na(coordinates$lon)) {
#      cat(i, "No Coordinates\r")
#    next
#  }
#   
#   # Calculate a 20 minute walking time isochrone around the store
#  walktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                               output = "sf", profile = ors_profile("walking"))
#  values <- levels(factor(walktime20$value))
#  ranges <- split(walktime20, values)
#  ranges <- ranges[rev(values)]
#  names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
# #################################################################################### TEST PLOT THE ISOCHRONE
#  # ggplot(walktime20) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = geometry), alpha = 0.1) +
#  #   geom_sf(data = isodf, aes(geometry = geometry))
# # THIS WORKED 
# ###################################################################################
#   # Convert the walktime20 isochrone to the correct CRS
#   # USE THIS AS THE ISOCHRONE
#   # rename the walktime20 geometry column
#  walktime20 <- walktime20  |>  rename_at('geometry', ~'isogeometry')
# 
#   # Join the calculated walktime 20 data to the zws data in isodf
#  zwsisoc <- cbind(isodf, walktime20)
#  # rename the geometry column
#  zwsisoc <- zwsisoc  |>  rename_at('geometry', ~'zwsgeometry')
#  zwsiso = zwsiso <- rbind(zwsiso, zwsisoc)
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
# # ggplot(zwsiso) +
# #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #    geom_sf(aes(geometry = zwsgeometry)) +
# #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# ###################################################################################   # print i as a count of rows that have completed
#  cat(i, "completed\r")
#   
# # remove the temporary environments
#  remove(coordinates, isodf, ranges, values, walktime20, zwsisoc)
#  Sys.sleep(3)
# }
# # Save the zwsiso file
# saveRDS(obj = zwsiso, file = "zwsiso.rds")
# 
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
#  # ggplot(zwsiso[97,]) +
#  #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #    geom_sf(aes(geometry = zwsgeometry)) +
#  #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# #################################################################################
# remove(coordinates, i, isodf, zws)
```

```{r zws_scr_loop}
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

# # Loop through each store to find the pwcs in zwsiso$walktimegeometry
# # Find all the LSOAs related to those PWCs
# # Get the scores for each LSOA
# # Add the scores and the joined LSOA geometry to the [i] row for that store
# 
# # Load the data required
# lsoa_pwc <- readRDS("lsoa_pwc.rds")
# 
# lsoas <- readRDS("lsoas.rds")
# # convert to sf
# 
# lsoas = st_as_sf(lsoas)
# zwsiso <- readRDS("zwsiso.rds")
# 
# # Create a dataframe to hold all the joined results
# zws_joined_lsoa_scr <- data.frame(matrix(ncol = 16, nrow = 0))
# 
# #initialise i
# i = 0
# i = i + 1
# for (i in 1:nrow(zwsiso)) {
# 
# a = zwsiso[i,]
#   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
# # get all the pwcs that appear in the iso for that store
# a <- a  |>  rename_at('isogeometry', ~'geometry')
# a = st_transform(a$geometry, crs = st_crs(3857)) 
# 
# # st_geometry(b) <- "geometry"
# b = lsoa_pwc[a,]
#   
#   # Check if (a) has 0 rows. If so, sack it off and move to the next record
#  if(nrow(b) == 0) {
#    next
#  }
#   
#   # Convert a to a dataframe to manipulate it
#   b = as.data.frame(b)
#   
#   # Get all the lsoas that relate to the pwcs just found
#   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
#   
#   #convert b to a dataframe
#   c = as.data.frame(c)
#   
# ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
#   c <- c |>
#    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
#                        across(where(is.character), ~'Total')))
#   
#   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# 
#   # convert b to sf format
#   c = st_as_sf(c)
#   
# ###################################################################################
# # TEST PLOT
# # ggplot(c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# #THIS WORKED
# ################################################################################### 
#   # Join the lsoas together
#  joined_lsoas <- st_union(c$lsoageometry)
#   
# ###################################################################################
# # TEST PLOT
#  # ggplot(joined_lsoas) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   ## Create a new dataframe for the joined data
#   joined_lsoas = st_as_sf(joined_lsoas)
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
#   
#   # combine the joined lsoa data and the score data
#   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
#   #remove the empty multipolyon column
#   joined_lsoas_c = joined_lsoas_c |> select(-one_of('lsoageometry'))
#   # rename the x column to "joinedlsoageom"
#   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas_c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   # retrieve the store name from zwsiso
#   d = zwsiso[i,]
# 
#    # Join the store name and the scores and the joined LSOA geometry and the walktime geometry
#  e = cbind(d, joined_lsoas_c)
# ###################################################################################
# # TEST PLOT
# # ggplot(e) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################  
#   # add this to a row in a new dataframe
#   zws_joined_lsoa_scr <- rbind(zws_joined_lsoa_scr, e)
# 
#   # remove the temporary dataframes sf files etc 
#  remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# 
# ###################################################################################
# # TEST PLOT
# #ggplot(zws_joined_lsoa_scr) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################
#   # Print (i) as a counter
#   cat(i, "completed\r")
# }
# # clean the zws_joined_lsoa_scr names and columns
# # Round the scores to the nearest whole number
# zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# 
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(zws_joined_lsoa_scr[93,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom, alpha = lsoatotscr))
# # THIS WORKED
# ###################################################################################
# # Set the active geometry column
# # st_geometry(zws_joined_lsoa_scr) <- "isogeometry"
# # zws_joined_lsoa_scr
# # 
# # 
# # remove(a, zwsiso)
# # Save the zws_joined_lsoa_scr data
# #remove the errors
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr[-c(82), ]
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
```

\FloatBarrier

Of the original 135 stores, 128 were successfully processed. Those that were not, either did not produce isochrone calculations that contained PWCs situated inside them, or did not have valid coordinate geometry data, as they were stores that closed prior to the study.

The scores for the remaining 128 stores were processed to calculate the mean scores of the 5 individual variables. The total mean score was then calculated to produce the final scorecard result for each store location (see \ref{tab:allzwsscrtable} for examples).

```{r all_zws_scr_table, echo=FALSE}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
my_theme = readRDS("my_theme.rds")
a = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[1:5, c(2, 12:17)]))
kable(a, caption = "\\label{tab:allzwsscrtable}Scorecard table for first 5 zero waste stores")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |>
  column_spec(1,width = "2in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.5in") |>
  column_spec(4,width = "0.5in") |>
  column_spec(5,width = "0.5in") |>
  column_spec(6,width = "0.5in") |>
  column_spec(7,width = "0.5in")

remove(a, zws_joined_lsoa_scr, my_theme)
```

\FloatBarrier

Using the final store scorecards, a summary table and correlation plot were produced. See \ref{tab:zws_scrsummary} for the summary table and figure \ref{fig:corr_plot} for the correlation plot.

```{r corr_plot, fig.height=4, fig.width=5, fig.cap="Plot showing correlations between total scores and the 5 variables for the stores data."}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
a_cor = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[,c(17,12:16)]))
cor_plot <- plot(a_cor, cex = 0.3,
     col = grey(0.145,alpha=0.5), upper.panel=panel.smooth)
remove(a_cor, zws_joined_lsoa_scr, cor_plot)
```

\FloatBarrier

```{r zws_scrsums_tab, echo=FALSE}
scrs_summary <- readRDS("scrs_summary.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# my_theme = readRDS("my_theme.rds")
# scrs_summary <- scrs_summary[-c(1:nrow(scrs_summary)), ]
# scrs_summary <- data.frame(matrix(ncol = 0, nrow = 0))
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(zws_joined_lsoa_scr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. stores')
# c = as.data.frame(t(c))
# scrs_summary = as.data.frame(t(scrs_summary))
# c = as.data.frame(t(c))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, c)
# #
# ## dedrank summary
# d  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(zws_joined_lsoa_scr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. stores')
# d = as.data.frame(t(d))
# scrs_summary = as.data.frame(t(scrs_summary))
# d = as.data.frame(t(d))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, d)
# #
# ## occrank summary
# o  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(zws_joined_lsoa_scr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. stores')
# o = as.data.frame(t(o))
# scrs_summary = as.data.frame(t(scrs_summary))
# o = as.data.frame(t(o))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, o)
# #
# ## pplrank summary
# p  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(zws_joined_lsoa_scr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. stores')
# p = as.data.frame(t(p))
# scrs_summary = as.data.frame(t(scrs_summary))
# p = as.data.frame(t(p))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, p)
# #
# ## tenrank summary
# t  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(zws_joined_lsoa_scr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. stores')
# t = as.data.frame(t(t))
# scrs_summary = as.data.frame(t(scrs_summary))
# t = as.data.frame(t(t))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, t)
# 
# 
# # lsoatotscr summary
# l  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(zws_joined_lsoa_scr), l)
# l <- l  |>  rename_at('l', ~'lsoa total score summary value')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. stores')
# l = as.data.frame(t(l))
# scrs_summary = as.data.frame(t(scrs_summary))
# l = as.data.frame(t(l))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, l)
# saveRDS(object = scrs_summary, file = "scrs_summary.rds")
# 
# remove(a, c, d, o, p, t, l)

kable(scrs_summary, caption = "\\label{tab:zws_scrsummary}Scorecard summary table for all zero waste stores.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(zws_joined_lsoa_scr, a, c, d, o, p, t, scrs_summary, my_theme)
```

\FloatBarrier

A distribution histogram for all stores was also produced. Figure \ref{fig:zw_scrs_hists} shows this.

```{r theme_setup}
# my_theme = theme(axis.text = element_text(size = 6), axis.title = element_text(size = 8))
# saveRDS(object = my_theme, file = "my_theme.rds")
```

```{r zw_scrs_hists, fig.cap="Histograms showing individual variable mean scores for all zero waste stores.", fig.width = 5, fig.height = 4}
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# my_theme = readRDS("my_theme.rds")
# # nrow(zws_joined_lsoa_scr)
# 
# zwh1 <- ggplot(zws_joined_lsoa_scr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh2 <- ggplot(zws_joined_lsoa_scr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh3 <- ggplot(zws_joined_lsoa_scr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh4 <- ggplot(zws_joined_lsoa_scr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh5 <- ggplot(zws_joined_lsoa_scr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh6 <- ggplot(zws_joined_lsoa_scr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# # Add the histograpms to a plot list
# zwh_plot_list <- list(zwh1, zwh2, zwh3, zwh4, zwh5, zwh6)
# saveRDS(object = zwh_plot_list, file = "zwh_plot_list.rds")
# remove(zwh1, zwh2, zwh3, zwh4, zwh5, zwh6)
# Plot them together in a grid
zwh_plot_list <- readRDS("zwh_plot_list.rds")
do.call("grid.arrange", c(zwh_plot_list, ncol = 3))
remove(zwh_plot_list, zws_joined_lsoa_scr, my_theme)
```

\FloatBarrier

Table \ref{tab:minmaxstore_tab} shows the scorecards for the stores that had the lowest and highest scores of all stores.

```{r min_max_store_tab}
# # Load the data to be used
minmaxstr <- readRDS("minmaxstr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# # my_theme = readRDS("my_theme.rds")
# # Get the store(s) with the lowest score
# minstore = zws_joined_lsoa_scr[which.min(zws_joined_lsoa_scr$lsoatotscr), ]
# # Save this for future reference
# saveRDS(object = minstore, file = "minstore.rds")
# 
# # prepare it for the table
# minstore =  as.data.frame(minstore[,c(2,3,12:17)])
# minstore = st_as_sf(minstore)
# minstore = st_drop_geometry(minstore)
# 
# # Get the store(s) with the highest score
# maxstore = zws_joined_lsoa_scr[which.max(zws_joined_lsoa_scr$lsoatotscr), ]
# # Save this for future reference
# saveRDS(object = maxstore, file = "maxstore.rds")
# 
# # Prepare it for the table
# maxstore =  as.data.frame(maxstore[,c(2,3,12:17)])
# maxstore = st_as_sf(maxstore)
# maxstore = st_drop_geometry(maxstore)
# 
# # Combine them ready for kable table
# minmaxstr <- rbind(maxstore, minstore)
# 
# # Save this for future reference
# saveRDS(object = minmaxstr, file = "minmaxstr.rds")

# Show the table for the 2 stores
kable(minmaxstr, row.names = F, caption = "\\label{tab:minmaxstore_tab}Summary table for zero waste store(s) with highest and lowest scores.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |> 
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.8in") |>
  column_spec(3,width = "0.8in") |>
  column_spec(4,width = "0.8in") |>
  column_spec(5,width = "0.8in") |>
  column_spec(6,width = "0.8in")

# clean the dataframes from the environment
remove(zws_joined_lsoa_scr, minstore, maxstore, minmaxstr, my_theme)
```

\FloatBarrier

These were then produced as histograms to easier visualise and compare each stores scores (See figure \ref{fig:minmaxcomp_plot}.

```{r minmaxcomp_plot, fig.cap="Histograms showing compairson between highest and lowest scoring stores variables and total scores"}
# minstore <- readRDS("minstore.rds")
# maxstore <- readRDS("maxstore.rds")
# # create the dataframe for the plottble scores
# minstr <- as.data.frame(minstore[,c(2,12:17)])
# # change the data from wide to long
# plotminstr <- gather(minstr, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)
# 
# # create the dataframe for the plottble scores
# maxstr <- as.data.frame(maxstore[,c(2,12:17)])
# # change the data from wide to long
# plotmaxstr <- gather(maxstr, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)
# 
# # bind them together
# plotcompare <- rbind(plotminstr, plotmaxstr)
# # rename the columns
# plotcompare <- plotcompare  |> dplyr::rename_at('st_nam', ~'Store_Name')
# 
# saveRDS(object = plotcompare, file = "plotcompare.rds")

# Load the data
plotcompare <- readRDS("plotcompare.rds")

# Plot it as a comparison
ggplot(plotcompare, aes(x = Store_Name, y= score, fill = variable)) +
  geom_histogram(stat="identity", width=0.9, position = "dodge") +
  scale_fill_brewer(palette="Dark2", name = "Variables (0-10)\n& total (0-50)") +
  xlab("Store Name") +
  scale_y_continuous(name="Score", breaks = seq(0, 50, by = 5), limits = c(0,50)) +
  geom_text(
    aes(label = score),
    position = position_dodge(0.9),
    vjust = -0.2)

remove(maxstore, maxstr, minstore, minstr, plotmaxstr, plotminstr, plotcompare)
remove(b, i, joined_rc_results, lsoa_in_rciso, lsoa_pwc, lsoas, pwc_in_rciso, rc_joined_lsoa_scr)
```

Maps were also produced to help visualise the similarities and differences between the physical locations and surrounding areas of both stores. Figure \ref{fig:maxstr_map} shows the map, any associated retail centre, catchment area, and scorecard for the store with the highest score, and figure \ref{fig:minstr_map} shows the map and scorecard for the store with the lowest score.

\FloatBarrier

```{r maxstr_map, fig.height=4, fig.width=5, warning=FALSE, fig.cap="Map showing the store with the highest value scorecard and the variable averages for the location."}
maxstore <- readRDS("maxstore.rds")
rcmaxstr <- readRDS("rcmaxstr.rds")
maxstoremap <- 
  ggplot(maxstore) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
    geom_sf(data = rcmaxstr, aes(geometry = geometry, shape = rcmaxstr$Classifica), alpha = 0.1, colour = "blue") +
  guides(shape = guide_legend(title = "RC Classification", reverse = TRUE)) +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "red") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = maxstore$geometry, fill = maxstore$lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = st_nam)) +
  guides(colour = guide_legend(title = str_wrap("Store name", width = 15), reverse = TRUE)) +
  #   # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", 
  #                        which_north = "true", 
  #                        pad_x = unit(0.1, "in"), 
  #                        pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 10)

maxvarhead <- 
  ggplot(maxstore) + 
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

maxcarscr <-
  ggplot(maxstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

maxdedscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

maxoccscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxpplscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxtenscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void(margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"))

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = maxstoremap,
           B = maxvarhead,
           C = maxcarscr,
           D = maxdedscr,
           E = maxoccscr,
           F = maxpplscr,
           G = maxtenscr,
           design = layout)

remove(rcmaxstr,maxstore, maxstoremap, maxvarhead, maxcarscr, maxdedscr, maxoccscr, maxpplscr, maxtenscr, layout)
```

\FloatBarrier

```{r minstr_map, fig.height=4, fig.width=5, warning=FALSE, fig.cap="Map showing the store with the lowest value scorecard, and the variable averages for the location."}
rcminstr <- readRDS("rcminstr.rds")
minstore <- readRDS("minstore.rds")
minstoremap <- ggplot(minstore) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "red") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = minstore$geometry, fill = lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = st_nam)) +
  guides(colour = guide_legend(title = str_wrap("Store name", width = 15), reverse = TRUE)) +
    geom_sf(data = rcminstr, aes(geometry = geometry, shape = rcminstr$Classifica), alpha = 0.1, colour = "blue") +
  guides(shape = guide_legend(title = "RC Classification", reverse = TRUE)) +
  theme_void()

minvarhead <-
  ggplot(minstore) +
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

mincarscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void(margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"))

mindedscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

minoccscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

minpplscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

mintenscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void(base_size = 8)

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = minstoremap,
           B = minvarhead,
           C = mincarscr,
           D = mindedscr,
           E = minoccscr,
           F = minpplscr,
           G = mintenscr,
           design = layout)
remove(rcminstr, minstore, minstoremap, minvarhead, mincarscr, mindedscr, minoccscr, minpplscr, mintenscr, layout)
```

\FloatBarrier

### Processing the retail centres

Once analysis of the ZWS was completed, the scorecards for them were used to identify the most suitable potential retail centre(s) that were not already supplied by a zero waste store.

To be able to do this, as before the isochrones were calculated, PWC were filtered, the relevant LSOA data was retrieved and scorecards for each was produced.

\FloatBarrier

```{r rc_iso_additional}
# Load the data
# all_rcs <- readRDS("all_rcs.rds")
# 
# # Get the isochrones for the retail centres
# all_rcs$centoidgeom <-  st_point_on_surface(all_rcs$geometry)
# 
# # Transform the CRS 
# all_rcs = st_transform(all_rcs, crs = st_crs(3857))
# saveRDS(object = all_rcs, file = "all_rcs.rds")
# remove(all_rcs)

###################################################################################
# ggplot(all_rcs[5825,]) +
#   annotation_map_tile(zoomin = 1, type = "hotstyle") +
#   geom_sf(aes(geometry = geometry), colour = "red", alpha = 0.1) +
#   geom_sf(aes(geometry = centoidgeom), colour = "blue")
###################################################################################

# RE-DO THE RETAIL CENTRE ISOCHRONES

# SPLIT THE ALL_RCS FILE IN TO 3 (2500, 2500, 1423)
# rca <- all_rcs[1:2500,]
# saveRDS(object = rca, file = "rca.rds")


# rcb <- all_rcs[2501:5000,]
# saveRDS(object = rcb, file = "rcb.rds")

# rcc <- all_rcs[5001:6423,]
# saveRDS(object = rcc, file = "rcc.rds")

# remove(all_rcs, rca, rcb, rcc)

# rca <- readRDS("rca.rds")
# rcaa <- rca[500:2500,]
# saveRDS(object = rcaa, file = "rcaa.rds")


# rcb <- all_rcs[2501:5000,]
# saveRDS(object = rcb, file = "rcb.rds")
# rcc <- all_rcs[5001:6423,]
# saveRDS(object = rcc, file = "rcc.rds")
# remove(all_rcs, rca, rcb, rcc)
# rca <- readRDS("rca.rds")


# rc_final_results <- readRDS("rc_final_results.rds")

# # convert rciso to crs 4326
# #rciso <- st_transform(rciso, crs = st_crs(4326))
# # convert retail_c to crs 3857
# #rciso <- st_transform(rciso, crs = st_crs(3857))
# 
# 
# # Change the name of the centre column to make it identifiable
# # rca_results <- rca_results  |>  rename_at('center', ~'rcisocenter')
# 
# # remove the temporary dataframes
# remove(i)
# # save the rc_results and the rc_(x) files as RDS files
# saveRDS(obj = rc_a, file = "rc_a.rds")
# saveRDS(obj = rca_results, file = "rca_results.rds")
# remove(i)
# ###################################################################################
# # PROCESS THE RC_B FILE
# ###################################################################################
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_b)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_b[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_b, file = "rc_b.rds")
# saveRDS(obj = rcb_results, file = "rcb_results.rds")
# remove(i)
# 
# ###################################################################################
# ###################################################################################
# # PROCESS THE RC_C FILE
# ###################################################################################
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_c)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_c[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_c, file = "rc_c.rds")
# saveRDS(obj = rcc_results, file = "rcc_results.rds")
# remove(i)
# ###################################################################################
# ###################################################################################
# ###################################################################################
# # Convert all the geometries to work properly
# # load rca_results
# rca_results <- readRDS("rca_results.rds")
# a = as.data.frame(rca_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # Save a to rc_final_results
# rc_final_results <- a
# 
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcb_results <- readRDS("rcb_results.rds")
# a = as.data.frame(rcb_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[2,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # add the data to the final dataframe
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcc_results <- readRDS("rcc_results.rds")
# a = as.data.frame(rcc_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,21)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,26)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# 
# 
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'fid.1', 'RC_ID.1', 'RC_Name.1', 'Classifica.1', 'Country.1', 'Region_NM.1', 'H3_count.1', 'Retail_N.1', 'Area_km2.1', 'value', 'isodf.RC_ID'))
# # make sure the columns in a are in the same order as rc_final_results
# a <- a |> relocate(group_index, .before = rcgeometry)
# a <- st_as_sf(a)
# ###################################################################################
# # Fix the CRS of a
# # Try to fix zws_joined_lsoa_scr.rds geometries
# b = a[,c(1,10)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ###################################################################################
# # remove(rc_final_results)
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# b = rc_final_results[,c(13)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# rc_final_results$rcwalktime = b$rcwalktime
# 
# b = rc_final_results[,c(12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rccentroidgeom = b$rccentroidgeom
# 
# b = rc_final_results[,c(11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rcgeometry = b$rcgeometry
# 
# 
# ##################################################################################
# # TEST PLOT rc_final_results
# # ggplot(rc_final_results[2,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "blue")
# # THIS WORKED
# saveRDS(obj = rc_final_results, file = "rc_final_results.rds")
# ###################################################################################
# ###################################################################################
# # Remove unwanted dataframes and sf files
# remove(a, b, c, rc_a, rc_b, rc_c, rc_results, rca_results, rcb_results, rcc_results)
# ################################################################################
```

```{r rc_iso_calc}
# rc_final_results <- readRDS("rc_final_results.rds")
###################################################################################
# # RC ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# #### Process rc_a
# rca_results <- data.frame(matrix(ncol = 18, nrow = 0))
# 
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_a)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_a[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rca_results <- rbind(rca_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# # convert rciso to crs 4326
# #rciso <- st_transform(rciso, crs = st_crs(4326))
# # convert retail_c to crs 3857
# #rciso <- st_transform(rciso, crs = st_crs(3857))
# 
# 
# # Change the name of the centre column to make it identifiable
# # rca_results <- rca_results  |>  rename_at('center', ~'rcisocenter')
# 
# # remove the temporary dataframes
# remove(i)
# # save the rc_results and the rc_(x) files as RDS files
# saveRDS(obj = rc_a, file = "rc_a.rds")
# saveRDS(obj = rca_results, file = "rca_results.rds")
# remove(i)
# ###################################################################################
# # PROCESS THE RC_B FILE
# ###################################################################################
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_b)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_b[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_b, file = "rc_b.rds")
# saveRDS(obj = rcb_results, file = "rcb_results.rds")
# remove(i)
# 
# ###################################################################################
# ###################################################################################
# # PROCESS THE RC_C FILE
# ###################################################################################
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_c)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_c[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_c, file = "rc_c.rds")
# saveRDS(obj = rcc_results, file = "rcc_results.rds")
# remove(i)
# ###################################################################################
# ###################################################################################
# ###################################################################################
# # Convert all the geometries to work properly
# # load rca_results
# rca_results <- readRDS("rca_results.rds")
# a = as.data.frame(rca_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # Save a to rc_final_results
# rc_final_results <- a
# 
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcb_results <- readRDS("rcb_results.rds")
# a = as.data.frame(rcb_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[2,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # add the data to the final dataframe
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcc_results <- readRDS("rcc_results.rds")
# a = as.data.frame(rcc_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,21)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,26)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# 
# 
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'fid.1', 'RC_ID.1', 'RC_Name.1', 'Classifica.1', 'Country.1', 'Region_NM.1', 'H3_count.1', 'Retail_N.1', 'Area_km2.1', 'value', 'isodf.RC_ID'))
# # make sure the columns in a are in the same order as rc_final_results
# a <- a |> relocate(group_index, .before = rcgeometry)
# a <- st_as_sf(a)
# ###################################################################################
# # Fix the CRS of a
# # Try to fix zws_joined_lsoa_scr.rds geometries
# b = a[,c(1,10)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ###################################################################################
# # remove(rc_final_results)
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# b = rc_final_results[,c(13)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# rc_final_results$rcwalktime = b$rcwalktime
# 
# b = rc_final_results[,c(12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rccentroidgeom = b$rccentroidgeom
# 
# b = rc_final_results[,c(11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rcgeometry = b$rcgeometry
# 
# 
# ##################################################################################
# # TEST PLOT rc_final_results
# # ggplot(rc_final_results[2,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "blue")
# # THIS WORKED
# saveRDS(obj = rc_final_results, file = "rc_final_results.rds")
# ###################################################################################
# ###################################################################################
# # Remove unwanted dataframes and sf files
# remove(a, b, c, rc_a, rc_b, rc_c, rc_results, rca_results, rcb_results, rcc_results)
# ###################################################################################
```

```{r rca_isocalc, echo = FALSE}
###################################################################################
# # RCAA ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# # RC ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# remove(i)
# 
# rca_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rca)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rca[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rca_results <- rbind(rca_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = 1:499 inclusive (499)
# saveRDS(object = rca_results, file = "rca_results.rds")
# rca_results = 500:2500 inclusive (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")
```

```{r rcaa_isocalc, echo=FALSE}
###################################################################################
# # RCAA ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# remove(i)
# 
# rcaa <- readRDS("rcaa.rds")
# # #### Process rcaa
# rcaa_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcaa)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcaa[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcaa_results <- rbind(rcaa_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = 1:499 inclusive (499)
# saveRDS(object = rca_results, file = "rca_results.rds")
# rca_results = 500:2500 inclusive (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")
```

```{r rcbb_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcbb <- readRDS("rcbb.rds")
# # #### Process rcaa
# rcbb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcbb)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcbb[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcbb_results <- rbind(rcbb_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = (499)
# saveRDS(object = rca_results, file = "rca_results.rds")

# rca_results = (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")

# rcbb_results = (498)
# saveRDS(object = rcbb_results, file = "rcbb_results.rds")

# rcb_results = (2002)
# saveRDS(object = rcb_results, file = "rcb_results.rds")
```

```{r rcb_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)
# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcb <- readRDS("rcb.rds")
# # remove(rcb)
# # #### Process rcaa
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcb)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcb[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert  to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rca_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcb_results = (2002)
# saveRDS(object = rcb_results, file = "rcb_results.rds")
# remove(rcb)
# rcc_results = (1423)
# saveRDS(object = rcc_results, file = "rcc_results.rds")
```

```{r rcc_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")
# rcb <- rbind(rcb, rcc)
# rcc <- rcb[2501:2925,]
# # # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcc$RC_ID,]
# saveRDS(object = rcc, file = "rcc.rds")
# saveRDS(object = rcb, file = "rcb.rds")
###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcc <- readRDS("rcc.rds")
# # #### Process rcaa
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcc)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcc[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rcaa_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcb_results = (2500)
# # saveRDS(object = rcb_results, file = "rcb_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcc_results = (425)
# saveRDS(object = rcc_results, file = "rcc_results.rds")
# remove(rcc)
# rccc_results = (500)
# saveRDS(object = rccc_results, file = "rccc_results.rds")
```

```{r rccc_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")
# rccc <- rcc[924:1423,]
# # Remove the rows from rcc found in rccc
# rcc <- rcc[!rcc$RC_ID %in% rccc$RC_ID,]
# saveRDS(object = rccc, file = "rccc")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# # rcc <- readRDS("rcc.rds")
# # #### Process rcaa
# rccc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rccc)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rccc[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rccc_results <- rbind(rccc_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rca_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcb_results = (2002)
# # saveRDS(object = rcb_results, file = "rcb_results.rds")
# 
# # rcc_results = (1423)
# saveRDS(object = rccc_results, file = "rccc_results.rds")
# # remove(rccc)
```

Once isochrones had been calculated for all retail centres, those that contained a store were filtered out, leaving only those centres without a store located within them.

```{r rc_with_zws_prep}
# # Load the data required
# 
#  # Load Retail Centres data
 # rc_results <- readRDS("rc_results.rds")
#  # create a dataframe to hold the RCID and geometry for the isochrone
#  rc = select(rc_results, 2, 10)
#  # remove rc_results
#  # remove(rc_results)
#  # Convert rc to a sf format
#  rc = st_as_sf(rc)
# 
# # Load Lsoa data
# lsoas <- readRDS("lsoas.rds")
# lsoas = st_as_sf(lsoas)
# 
# # Load Population Weighted Centroid data and zws results
# lsoa_pwc <- readRDS("lsoa_pwc.rds")
# lsoa_pwc
# 
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# 
# # Find the retail centres that do not contain a store already
# # RCs WITH zws
# rc_with_zws = rc[zws_joined_lsoa_scr$zwsgeometry,]
# 
# # RCs WITHOUT zws##################################################################
# rc_no_zws = rc[!(rc$RC_ID  %in% rc_with_zws$RC_ID),]
# saveRDS(obj = rc_no_zws, file = "rc_no_zws.rds")
```

```{r rc_no_zws}
# ################# Prepare the retail centres data without a zws in them
# # PREPARE THE RETAIL CENTRE DATA
# # Get all the data for the retail centres
# rc_no_zws = rc_no_zws |> select(-3)
# rc_results = as.data.frame(rc_results)
# rc_no_zws = as.data.frame(rc_no_zws)
# rc_no_zws = inner_join(rc_no_zws, rc_results, by="RC_ID")
# 
# ## Remove retail centres from retail_c that are not required
# ### Remove retail centres that are not in England and Wales from retail_c
# rc_no_zws <- rc_no_zws[grep(c("Wales|England"), rc_no_zws$Country),]
# 
# # Clean the columns up
# rc_no_zws = rc_no_zws |> select(-one_of('rcgeometry.x'))
# rc_no_zws <- rc_no_zws  |>  rename_at('rcgeometry.y', ~'rcgeometry')
# 
# # Remove retail centres that are too large
# # Those zwstores that are located within a retail centre are mainly in :-
# # Town Centre
# # Small Local Centre
# # Local Centre
# # Market Town
# rc_no_zws <- rc_no_zws[grep(c("Town Centre|Small Local Centre|Local Centre|Market Town"), rc_no_zws$Classifica),]
# 
# 
# # Split he retail_c file in to chunks so that they can be processed and then re-combined
# 
# # Create the 2 temporary dataframes
# rc_1 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_2 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_3 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_4 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_5 <- data.frame(matrix(ncol = 20, nrow = 0))
# 
# # Move the relevant rows to the 5 new dataframes
# rc_1 <- rc_no_zws[rc_no_zws$Classifica == "Local Centre",]
# rc_2 <- rc_no_zws[rc_no_zws$Classifica == "Major Town Centre",]
# rc_3 <- rc_no_zws[rc_no_zws$Classifica == "Market Town",]
# rc_4 <- rc_no_zws[rc_no_zws$Classifica == "Small Local Centre",]
# rc_5 <- rc_no_zws[rc_no_zws$Classifica == "Town Centre",]
# 
# rc_a <- rbind(rc_1, rc_3)
# rc_b <- rbind(rc_2, rc_4, rc_5)
# 
# # remove the 5 temporary variables
# remove(rc_1, rc_2, rc_3, rc_4, rc_5)
# #remove(rc_a, rc_b)
# 
# # Split the rc_b file in to 2 leaving rc_b and rc_c
# rc_c <- tail(rc_b, -2500)
# rc_b = rc_b[!(rc_b$RC_ID %in% rc_c$RC_ID),]
# 
# ###################################################################################
# # with prep done, remove unrequired dataframes etc
# remove(rc, rc_with_zws)
```

The population weighted centroids were then identified so that the LSOAs could be identified from them. Scorecards were then able to be calculated for each retail centre. Table \ref{tab:rc_scrs_summary} shows the summary data for all retail centre scorecards.

\FloatBarrier

```{r rc_scrsums_tab}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
rc_scrs_summary <- readRDS("rc_scrs_summary.rds")
# totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_joined_lsoa_scr), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total score summary value')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_scrs_summary <- data.frame(matrix(ncol = 7, nrow = 0))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# l = as.data.frame(t(l))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_joined_lsoa_scr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# c = as.data.frame(t(c))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_joined_lsoa_scr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# d = as.data.frame(t(d))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_joined_lsoa_scr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# o = as.data.frame(t(o))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_joined_lsoa_scr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# p = as.data.frame(t(p))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_joined_lsoa_scr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# t = as.data.frame(t(t))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, t)
# saveRDS(object = rc_scrs_summary, file = "rc_scrs_summary.rds")

kable(rc_scrs_summary, caption = "\\label{tab:rc_scrs_summary}Scorecard summary table for all retail centres.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary)
```

\FloatBarrier

Comparative histograms (see figure \ref{fig:rcminmax_hists} ) were then produced to visualise the RC with the lowest and highest scores.

```{r rcminmax_hists, fig.cap="Histogram cmparing the retail centres with the lowest and hisghest scorecard total value", fig.height=4, fig.width=7, warning=FALSE}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# rc_scrs_summary <- readRDS("rc_scrs_summary.rds")
# 
# # Get the retail centre(s) with the lowest score
# rcmin = rc_joined_lsoa_scr[which.min(rc_joined_lsoa_scr$lsoatotscr), ]
# # Get the retail centre(s) with the highest score
# rcmax = rc_joined_lsoa_scr[which.max(rc_joined_lsoa_scr$lsoatotscr), ]
# 
# # create the dataframe for the plottble scores
# rcmin <- as.data.frame(rcmin[,c(2,3,10:15)])
# # change the data from wide to long
# plotminrc <- gather(rcmin, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)
# 
# # create the dataframe for the plottble scores
# rcmax <- as.data.frame(rcmax[,c(2,3,10:15)])
# # change the data from wide to long
# plotmaxrc <- gather(rcmax, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)
# 
# # bind them together
# rcplotcompare <- rbind(plotminrc, plotmaxrc)
# # rename the columns
# rcplotcompare <- rcplotcompare  |> dplyr::rename_at('RC_Name', ~'Retail_Centre_Name')
# saveRDS(object = rcplotcompare, file = "rcplotcompare.rds")
rcplotcompare <- readRDS("rcplotcompare.rds")

ggplot(rcplotcompare, aes(x = Retail_Centre_Name, y= score, fill = variable)) +
  geom_histogram(stat="identity", width=0.9, position = "dodge") +
  scale_fill_brewer(palette="Dark2", name = "Variables (0-10)\n& total (0-50)") +
  xlab("Retail Centre Name") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 40)) +
  scale_y_continuous(name="Score", breaks = seq(0, 50, by = 5), limits = c(0,50)) +
  geom_text(
    aes(label = score),
    position = position_dodge(0.9),
    vjust = -0.2)

remove(plotmaxrc, plotminrc, rc_joined_lsoa_scr, rc_scrs_summary, rcmax, rcmin, rcplotcompare)
```

\FloatBarrier

Distributions of all retail centre scores were then visualised, again using distribution histograms and can be seen in \ref{fig:all_rc_hists}.

```{r all_rc_hists, fig.cap="Histograms showing distributions for individual variable scores for all retail centres.", fig.width = 5, fig.height = 4}
# ###################################################################################
# All rc_total scores
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# rc_hist1 <- ggplot(rc_joined_lsoa_scr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rc_hist2 <- ggplot(rc_joined_lsoa_scr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist3 <- ggplot(rc_joined_lsoa_scr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist4 <- ggplot(rc_joined_lsoa_scr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist5 <- ggplot(rc_joined_lsoa_scr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist6 <- ggplot(rc_joined_lsoa_scr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# plot_list_rchist <- list(rc_hist1, rc_hist2, rc_hist3, rc_hist4, rc_hist5, rc_hist6)
# saveRDS(object = plot_list_rchist, file = "plot_list_rchist.rds")
# remove(rc_hist1, rc_hist2, rc_hist3, rc_hist4, rc_hist5, rc_hist6)
plot_list_rchist <- readRDS("plot_list_rchist.rds")
do.call("grid.arrange", c(plot_list_rchist, ncol = 3))
remove(plot_list_rchist, rc_joined_lsoa_scr)
```

\FloatBarrier

Once the retail centres data was processed, the number of centres were narrowed down to identify those that would be the best potential optimal location(s) for new zero waste stores.

Firstly, using the full range of store scores, those RCs that scored a total that fell within this range were identified, and the distributions were visualised through a summary table (see table \ref{tab:rc_zwsmm_scrs_summary}) and distribution histograms (see figure \ref{fig:rc_minmax_hists}).

```{r rc_eq_zws_minmax_tab, echo=FALSE}
# Load the data
# zws_joined_lsoa_scr <- as.data.frame(readRDS("zws_joined_lsoa_scr.rds"))
# rc_joined_lsoa_scr <- as.data.frame(readRDS("rc_joined_lsoa_scr.rds"))
# rc_in_zws_mm <- readRDS("rc_in_zws_mm.rds")
rc_in_zws_mm_summary <- readRDS("rc_in_zws_mm_summary.rds")
# zwsmeans <- as.data.frame(readRDS("zwsmeans.rds"))
# allmatches <- as.data.frame(readRDS("allmatches.rds"))

# # totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_in_zws_mm$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_in_zws_mm), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nsit within the ZWS  range.')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_in_zws_mm_summary <- data.frame(matrix(ncol = 6, nrow = 0))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# l = as.data.frame(t(l))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_in_zws_mm$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_in_zws_mm), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# c = as.data.frame(t(c))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_in_zws_mm$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_in_zws_mm), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# d = as.data.frame(t(d))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_in_zws_mm$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_in_zws_mm), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# o = as.data.frame(t(o))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_in_zws_mm$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_in_zws_mm), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# p = as.data.frame(t(p))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_in_zws_mm$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_in_zws_mm), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# t = as.data.frame(t(t))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, t)
# saveRDS(object = rc_in_zws_mm_summary, file = "rc_in_zws_mm_summary.rds")
# 
kable(rc_in_zws_mm_summary, caption = "\\label{tab:rc_zwsmm_scrs_summary}Scorecard summary table for all retail centres whos total scores sit within the ZWS total score range.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, rc_zwsiqr_scrs_summary, rc_in_zws_iqr)
```

\FloatBarrier

```{r rc_minmax_hists, fig.height=5, fig.width=5, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that falls within the minimum and maximum score range for the zero waste stores.", echo=FALSE}
# my_theme = readRDS("my_theme.rds")
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# # rc_in_zws_mm <- readRDS("rc_in_zws_mm.rds")
# ###################################################################################
# # Using the range min-max
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (min(zws_joined_lsoa_scr$lsoatotscr)) & rc_joined_lsoa_scr$lsoatotscr <= (max(zws_joined_lsoa_scr$lsoatotscr))
# #
# rc_in_zws_mm <- subset(rc_joined_lsoa_scr, identify_rows)
# remove(identify_rows)
# #
# rcm1 <- ggplot(rc_in_zws_mm, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm2 <- ggplot(rc_in_zws_mm, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm3 <- ggplot(rc_in_zws_mm, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm4 <- ggplot(rc_in_zws_mm, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm5 <- ggplot(rc_in_zws_mm, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm6 <- ggplot(rc_in_zws_mm, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# #
# plot_list_minmax <- list(rcm1, rcm2, rcm3, rcm4, rcm5, rcm6)
# saveRDS(object = plot_list_minmax, file = "plot_list_minmax.rds")
# remove(rcm1, rcm2, rcm3, rcm4, rcm5, rcm6)
plot_list_minmax <- readRDS("plot_list_minmax.rds")
do.call("grid.arrange", c(plot_list_minmax, ncol = 3))
remove(plot_list_minmax, rc_joined_lsoa_scr, rc_in_zws_mm, rc_in_zws_mm_summary, zws_joined_lsoa_scr, my_theme, rcm1, rcm2, rcm3, rcm4, rcm5, rcm6, zws_joined_lsoa_scr)
```

\FloatBarrier

Retail centres were narrowed down further, to include only those that had a total score that was within the interquartile range of the stores total scores. See table \ref{tab:rc_zwsiqr_scrs_summary} for a summary, and figure \ref{fig:rc_iqr_hists} for distributions.

```{r rc_zwiqrsummary_tab}
# Load the data
# rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
# rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
# rc_in_zws_iqr <- readRDS("rc_in_zws_iqr.rds")
rc_zwsiqr_scrs_summary <- readRDS("rc_zwsiqr_scrs_summary.rds")
# # totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_in_zws_iqr), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nsit within the ZWS interquartile range.')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_zwsiqr_scrs_summary <- data.frame(matrix(ncol = 6, nrow = 0))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# l = as.data.frame(t(l))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_in_zws_iqr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# c = as.data.frame(t(c))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_in_zws_iqr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# d = as.data.frame(t(d))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_in_zws_iqr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# o = as.data.frame(t(o))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_in_zws_iqr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# p = as.data.frame(t(p))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_in_zws_iqr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# t = as.data.frame(t(t))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, t)
# saveRDS(object = rc_zwsiqr_scrs_summary, file = "rc_zwsiqr_scrs_summary.rds")
# 
kable(rc_zwsiqr_scrs_summary, caption = "\\label{tab:rc_zwsiqr_scrs_summary}Scorecard summary table for all retail centres whos total scores sit within the ZWS stores interquartile range.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, rc_zwsiqr_scrs_summary, rc_in_zws_iqr)
```

\FloatBarrier

```{r rc_iqr_hists, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that falls within the interquartile range of the zero waste stores total scores.", fig.width = 5, fig.height = 4}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

# # ###################################################################################
# # # Using the interquartile range
# # # Find the 1st and 3rd Quartiles of the zws results
# a <- data.frame(unclass(summary(zws_joined_lsoa_scr$lsoatotscr)), check.names = F)
# # # rotate the dataframe
# a = a |> rotate_df()
# # 
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (a$`1st Qu.`) & rc_joined_lsoa_scr$lsoatotscr <= (a$`3rd Qu.`)
# # 
# rc_in_zws_iqr <- subset(rc_joined_lsoa_scr, identify_rows)
# # 
# rcq1 <- ggplot(rc_in_zws_iqr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq2 <- ggplot(rc_in_zws_iqr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq3 <- ggplot(rc_in_zws_iqr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq4 <- ggplot(rc_in_zws_iqr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq5 <- ggplot(rc_in_zws_iqr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq6 <- ggplot(rc_in_zws_iqr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # 
# plot_list_iqr <- list(rcq1, rcq2, rcq3, rcq4, rcq5, rcq6)
# saveRDS(object = plot_list_iqr, file = "plot_list_iqr.rds")
# remove(rcq1, rcq2, rcq3, rcq4, rcq5, rcq6)
plot_list_iqr <- readRDS("plot_list_iqr.rds")
do.call("grid.arrange", c(plot_list_iqr, ncol = 3))
remove(plot_list_iqr, rc_joined_lsoa_scr, rc_in_zws_iqr, zws_joined_lsoa_scr, identify_rows, a)
```

\FloatBarrier

Further filtering of the RCs was then done through identifying only those that scored a total that was the same as the mean for the stores total mean score (24). See table \ref{tab:rc_eqzws_scrs_summary} for a summary and figure \ref{fig:rc_zws_mean_hists} for distributions.

```{r rc_eq_zw_ave_tab}
# Load the data
# # rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
#  # rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
#  zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
#  rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # # # Find and round the average zws score to the nearest while number
#  # zws_ave = round(mean(zws_joined_lsoa_scr$lsoatotscr))
# # # Identify the rows in the retail centre total score data that match the average total score for the stores data
#  # identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (zws_ave) & rc_joined_lsoa_scr$lsoatotscr <= (zws_ave)
# # # Get the rows identified as matching the zws mean score
#  rc_eq_zws_ave <- subset(rc_joined_lsoa_scr, identify_rows)
# saveRDS(object = rc_eq_zws_ave, file = "rc_eq_zws_ave.rds")
rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
remove(rc_joined_lsoa_scr, zws_joined_lsoa_scr)
# # totalscore summary
l  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$lsoatotscr)))
l = as.data.frame(l)
l = rbind(nrow(rc_eq_zws_ave), l)
l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nmatch the ZWS average score')
l = as.data.frame(t(l))
l <- l  |>  rename_at('1', ~'Total no. retail centres')
l = as.data.frame(t(l))
rc_eqzws_scrs_summary <- data.frame(matrix(ncol = 6, nrow = 0))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
l = as.data.frame(t(l))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, l)

# carrank summary
c  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$carrank)))
c = as.data.frame(c)
c = rbind(nrow(rc_eq_zws_ave), c)
c <- c  |>  rename_at('c', ~'carrank total score summary value')
c = as.data.frame(t(c))
c <- c  |>  rename_at('1', ~'Total no. retail centres')
c = as.data.frame(t(c))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
c = as.data.frame(t(c))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, c)

# dedrank summary
d  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$dedrank)))
d = as.data.frame(d)
d = rbind(nrow(rc_eq_zws_ave), d)
d <- d  |>  rename_at('d', ~'dedrank total score summary value')
d = as.data.frame(t(d))
d <- d  |>  rename_at('1', ~'Total no. retail centres')
d = as.data.frame(t(d))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
d = as.data.frame(t(d))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, d)

# occrank summary
o  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$occrank)))
o = as.data.frame(o)
o = rbind(nrow(rc_eq_zws_ave), o)
o <- o  |>  rename_at('o', ~'occrank total score summary value')
o = as.data.frame(t(o))
o <- o  |>  rename_at('1', ~'Total no. retail centres')
o = as.data.frame(t(o))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
o = as.data.frame(t(o))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, o)

# pplrank summary
p  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$pplrank)))
p = as.data.frame(p)
p = rbind(nrow(rc_eq_zws_ave), p)
p <- p  |>  rename_at('p', ~'pplrank total score summary value')
p = as.data.frame(t(p))
p <- p  |>  rename_at('1', ~'Total no. retail centres')
p = as.data.frame(t(p))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
p = as.data.frame(t(p))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, p)

# tenrank summary
t  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$tenrank)))
t = as.data.frame(t)
t = rbind(nrow(rc_eq_zws_ave), t)
t <- t  |>  rename_at('t', ~'tenrank total score summary value')
t = as.data.frame(t(t))
t <- t  |>  rename_at('1', ~'Total no. retail centres')
t = as.data.frame(t(t))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
t = as.data.frame(t(t))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, t)
# saveRDS(object = rc_eqzws_scrs_summary, file = "rc_eqzws_scrs_summary.rds")
# remove(c,d,l,o,p,t)

# rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
kable(rc_eqzws_scrs_summary, caption = "\\label{tab:rc_eqzws_scrs_summary}Scorecard summary table for all retail centres that total the same as the ZWS average.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave)
```

\FloatBarrier

```{r rc_zws_mean_hists, fig.height=5, fig.width=5, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that equals the mean score for the zero waste stores."}
# Find the mean total score for the zero waste stores
# Load the data required
 # zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
 # rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
 # my_theme <- readRDS("my_theme.rds")
 # plot_list_ave <- readRDS("plot_list_ave.rds")
#  rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
#  zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
#  rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # # # Find and round the average zws score to the nearest while number
#  zws_ave = round(mean(zws_joined_lsoa_scr$lsoatotscr))
#
# # # Identify the rows in the retail centre total score data that match the average total score for the stores data
#  identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (zws_ave) & rc_joined_lsoa_scr$lsoatotscr <= (zws_ave)
# #
# # # Get the rows identified as matching the zws mean score
#  rc_eq_zws_ave <- subset(rc_joined_lsoa_scr, identify_rows)
#
# rcnum = as.data.frame(nrow(rc_eq_zws_ave))
# # # Plot these distributions
#  rca1 <- ggplot(rc_eq_zws_ave, aes(x=lsoatotscr)) +
#    geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") +
#      geom_text(stat="bin", label = rcnum, vjust = -0.2, size = 3) +
#    my_theme
# # #
#  rca2 <- ggplot(rc_eq_zws_ave, aes(x=tenrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca3 <- ggplot(rc_eq_zws_ave, aes(x=pplrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca4 <- ggplot(rc_eq_zws_ave, aes(x=occrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca5 <- ggplot(rc_eq_zws_ave, aes(x=dedrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca6 <- ggplot(rc_eq_zws_ave, aes(x=carrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # # #
#  plot_list_ave <- list(rca1, rca2, rca3, rca4, rca5, rca6)
#  saveRDS(object = plot_list_ave, file = "plot_list_ave.rds")
 plot_list_ave <- readRDS("plot_list_ave.rds")
 do.call("grid.arrange", c(plot_list_ave, ncol = 3))
 remove(rca1, rca2, rca3, rca4, rca5, rca6, plotmaxrc, plotminrc, rc_eq_zws_ave, rc_joined_lsoa_scr, rc_scrs_summary, rcmax, rcmin, rcplotcompare, zws_ave, zws_joined_lsoa_scr, my_theme, plot_list_ave, identify_rows, rcnum)
```

```{r rc_scores}
# # # remove(joined_rc_results, rc_joined_lsoa_scr, rcs)
# # joined_rc_results <- readRDS("joined_rc_results.rds")
# # joined_rc_results <- joined_rc_results |> rename_at('geometry', ~'rcgeometry')
# # 
# # ##################################################################################
# # #                                                                                #
# # #          Calclate the isochrones around the retail centres without zws         #
# # #                                                                                #
# # ##################################################################################
# # # remove(i, rc_joined_lsoa_scr)
# # # # Load the data required
# # lsoa_pwc <- readRDS("lsoa_pwc.rds")
# # lsoas <- readRDS("lsoas.rds")
# # # # convert to sf
# # lsoa_pwc = st_as_sf(lsoa_pwc)
# # lsoas = st_as_sf(lsoas)
# # # 
# # # # # Find all the PWCs that appear in any of the rc_isochrones
# # st_geometry(joined_rc_results) <- "rcwalktime"
# # joined_rc_results$rcwalktime = st_transform(joined_rc_results$rcwalktime, crs = st_crs(3857))
# # joined_rc_results = st_as_sf(joined_rc_results)
# # pwc_in_rciso = lsoa_pwc[joined_rc_results$rcwalktime,]
# # # #
# # # ## # find all the pwc_in_rciso related LSOAs
# # lsoa_in_rciso = lsoas[(lsoas$LSOA21CD  %in% pwc_in_rciso$LSOA21CD),]
# # # 
# # # # Create a dataframe to hold all the joined results
# # rc_joined_lsoa_scr <- data.frame(matrix(ncol = 19, nrow = 0))
# # # 
# # # #initialise i
# # i = 0
# # i = i + 1
# # for (i in 1:nrow(joined_rc_results)) {
# # # 
# #   a = joined_rc_results[i,]
# # #   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(a) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = a$rcgeometry), alpha = 0.1, colour = "blue") +
# # # #   geom_sf(aes(geometry = a$rcwalktime), alpha = 0.1, colour = "red")
# # # #THIS WORKED
# # # ###################################################################################
# # # 
# # # # get all the pwcs that appear in the iso for that store
# # # a <- a  |>  rename_at('isogeometry', ~'geometry')
# # # a = st_transform(a$geometry, crs = st_crs(3857))
# # # 
# # # st_geometry(b) <- "geometry"
# # b = lsoa_pwc[a$rcwalktime,]
# # #   
# # #   # Check if (a) has 0 rows. If so, sack it off and move to the next record
# #  if(nrow(b) == 0) {
# #    cat(i, "..errored\r")
# #    next
# #  }
# # #   
# # #   # Convert a to a dataframe to manipulate it
# #   b = as.data.frame(b)
# # #   
# # #   # Get all the lsoas that relate to the pwcs just found
# #   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
# # #   
# # #   #convert b to a dataframe
# #   c = as.data.frame(c)
# # #   
# # # ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
# #   c <- c |>
# #    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
# #                        across(where(is.character), ~'Total')))
# # #   
# # #   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# # # 
# # #   # convert c to sf format
# #   c = st_as_sf(c)
# # #   
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(c) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# # # #THIS WORKED
# # # ################################################################################### 
# # #   # Join the lsoas together
# #   joined_lsoas <- st_union(c$lsoageometry)
# # #   
# # # ###################################################################################
# # # # TEST PLOT
# # #  # ggplot(joined_lsoas) +
# # #  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # #  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1, colour = "black")
# # # #THIS WORKED
# # # ###################################################################################
# # #   # Convert joined_lsoas to sf
# #   joined_lsoas = st_as_sf(joined_lsoas)
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(joined_lsoas) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1, colour = "blue")
# # # #THIS WORKED
# # # ###################################################################################
# # #   
# #   # combine the joined lsoa data and the score data
# #   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
# #   #remove the empty multipolyon column
# #   joined_lsoas_c = as.data.frame(joined_lsoas_c)
# #   joined_lsoas_c = joined_lsoas_c |> dplyr::select(-one_of('lsoageometry'))
# #   # rename the x column to "joinedlsoageom"
# #   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # #   # ggplot(joined_lsoas_c) +
# # #   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # #   #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1, colou = "red")
# # # #THIS WORKED
# # # ###################################################################################
# # # 
# #   # retrieve the retail center ID from rc_final_results
# #   d = joined_rc_results[i,]
# # 
# #   # Join the retail center data, the scores, the joined LSOA geometry and the walktime geometry
# #   e = cbind(d, joined_lsoas_c)
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(e) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = rcgeometry), colour = "green") +
# # # #   geom_sf(aes(geometry = rccentroidgeom), alpha = 0.1, colour = "black") +
# # # #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# # # #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1, colour = "blue")
# # # # THIS WORKED
# # # ###################################################################################  
# #   # add this to a row in a new dataframe
# #   rc_joined_lsoa_scr <- rbind(rc_joined_lsoa_scr, e)
# # 
# #   # remove the temporary dataframes sf files etc
# #   remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# # 
# #   # Print (i) as a counter
# #   cat(i, "completed\r")
# # }
# # saveRDS(object = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
# 
# # # clean the rc_joined_lsoa_scr names and columns
# # # Round the scores to the nearest whole number
# # rc_joined_lsoa_scr = as.data.frame(rc_joined_lsoa_scr)
# # rc_joined_lsoa_scr = st_as_sf(rc_joined_lsoa_scr)
# # rc_joined_lsoa_scr <- rc_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# # # # 
# # # # # reindex the data
# # rownames(rc_joined_lsoa_scr) <- 1:nrow(rc_joined_lsoa_scr)
# # # Delete the irrelevant columns
# # rc_joined_lsoa_scr = rc_joined_lsoa_scr |> dplyr::select(-one_of('fid', "center", "value", 'group_index'))
# # # rename the columns that require renaming
# # rc_joined_lsoa_scr <- rc_joined_lsoa_scr  |>  rename_at('centoidgeom', ~'rccentroidgeom')
# # saveRDS(object = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # 
# # ###################################################################################
# # # # Convert all the geometries
# b = rc_joined_lsoa_scr[,c(1,19)]
# # b = as.data.frame(b)
# # b = b |> dplyr::select(-one_of('rcgeometry'))
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# 
# rc_joined_lsoa_scr$joinedlsoageom = b$joinedlsoageom
# 
# # # ###################################################################################
# # # # TEST PLOT
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # # # THIS WORKED
# # # ###################################################################################
# # # 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,18)]
# # remove rcgeometry
# # b = as.data.frame(b)
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rcwalktime = b$rcwalktime
# 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,17)]
# # remove rcgeometry
# # b = as.data.frame(b)
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rccentroidgeom = b$rccentroidgeom
# 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,16)]
# # remove rcgeometry
# # b = as.data.frame(b)
# # b = b |> select(-one_of('rcgeometry'))
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rcgeometry = b$rcgeometry
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # # rc_joined_lsoa_scr <- st_as_sf(rc_joined_lsoa_scr)
# ggplot(rc_joined_lsoa_scr[67,]) +
#   annotation_map_tile(zoomin = 0, type = "osm") +
#   geom_sf(aes(geometry = joinedlsoageom, alpha = round(lsoatotscr, digits = 0)), colour = "blue") +
#   guides(alpha = guide_legend(title = "LSOAs total score")) +
#   geom_sf(aes(geometry = rcgeometry, colour = ""), colour = "black", alpha = 0.1) +
#   geom_sf(aes(geometry = rcwalktime, fill = ""), colour = "purple",alpha = 0.1) +
#   guides(fill = guide_legend(title = "Retail centre isochrone")) +
#   geom_sf(aes(geometry = rccentroidgeom), colour = "red")
# # # THIS WORKED
# # #################################################################################
# 
# # saveRDS(obj = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
```

\FloatBarrier

Finally, the final set of most potential RC were identified using the 5 variables and the total score of the stores data. Those RC variables that scored an average within +-0.5 of the same variable in the stores data were identified and only those that scored the same as the store mean score (24) for the total score were identified. Table \ref{tab:allmatches} shows the summary table for these Retail centres.

```{r rc_allmatched, echo=FALSE}
# Load the data
# zws_joined_lsoa_scr <- as.data.frame(readRDS("zws_joined_lsoa_scr.rds"))
# rc_joined_lsoa_scr <- as.data.frame(readRDS("rc_joined_lsoa_scr.rds"))
# zwsmeans <- as.data.frame(readRDS("zwsmeans.rds"))
allmatches <- as.data.frame(readRDS("allmatches.rds"))
# ################################################################################
# # # Get the column names for the scores
# # zwcolnames <- as.data.frame(t(colnames(st_drop_geometry(zws_joined_lsoa_scr[,12:17]))))
# # # Create a dataframe to hold the mean scores
# # zwsmeans <- data.frame(matrix(ncol = 6, nrow = 1))
# # # Change the column names
# # colnames(zwsmeans) <- zwcolnames
# #
# # # Add the mean scores for each of the variables to the mean dataframe
# # zwsmeans$carrank = round(mean(zws_joined_lsoa_scr$carrank), digits = 0)
# # zwsmeans$dedrank = round(mean(zws_joined_lsoa_scr$dedrank), digits = 0)
# # zwsmeans$occrank = round(mean(zws_joined_lsoa_scr$occrank), digits = 0)
# # zwsmeans$pplrank = round(mean(zws_joined_lsoa_scr$pplrank), digits = 0)
# # zwsmeans$tenrank = round(mean(zws_joined_lsoa_scr$tenrank), digits = 0)
# # zwsmeans$lsoatotscr = round(mean(zws_joined_lsoa_scr$lsoatotscr), digits = 0)
# # remove(zwcolnames, zws_joined_lsoa_scr)
# ##################################################################################
# # # Use this mean dataframe to find the retail centres that have scores that match this data.
# allmatches <- subset(rc_joined_lsoa_scr,
#                      (rc_joined_lsoa_scr$lsoatotscr == zwsmeans$lsoatotscr) &
#                      (rc_joined_lsoa_scr$carrank > zwsmeans$carrank-0.5) &
#                      (rc_joined_lsoa_scr$carrank < zwsmeans$carrank+0.5) &
#                      (rc_joined_lsoa_scr$dedrank > zwsmeans$dedrank-0.5) &
#                      (rc_joined_lsoa_scr$dedrank < zwsmeans$dedrank+0.5) &
#                      (rc_joined_lsoa_scr$occrank > zwsmeans$occrank-0.5) &
#                      (rc_joined_lsoa_scr$occrank < zwsmeans$occrank+0.5) &
#                      (rc_joined_lsoa_scr$pplrank > zwsmeans$pplrank-0.5) &
#                      (rc_joined_lsoa_scr$pplrank < zwsmeans$pplrank+0.5) &
#                      (rc_joined_lsoa_scr$tenrank > zwsmeans$tenrank-0.5) &
#                      (rc_joined_lsoa_scr$tenrank < zwsmeans$tenrank+0.5))
# 
# # Reindex the matches table
# rownames(allmatches) <- 1:nrow(allmatches)
# 
# # Save the all_matches data
# saveRDS(object = allmatches, file = "allmatches.rds")
# 
# 
# Print the matches table
kable(allmatches[,c(2:4, 10:15)], caption = "\\label{tab:allmatches}Scorecard summary table for all retail centres that contain all variable scores that sit within +-1 of the rounded mean zero wastte store variable scores, and match the mean total store score.") |> 
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |> 
  column_spec(1,bold = T, width = "2in")
  # column_spec(2,width = "0.1in") |>
  # column_spec(3,width = "0.1in") |>
  # column_spec(4,width = "0.1in") |>
  # column_spec(5,width = "0.1in") |>
  # column_spec(6,width = "0.1in") |>
  # column_spec(7,width = "0.1in") |>
  # column_spec(8,width = "0.1in") |>
  # column_spec(9,width = "0.1in")

#saveRDS(object = zwsmeans, file = "zwsmeans.rds")
#saveRDS(object = allmatches, file = "allmatches.rds")

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, allmatches, zwsmeans)
```

![Map of optimal retail centres in the study area. See table \ref{tab:allmatches} for retail centre names. \label{finalrcs}](matchmap.png){alt="Map of optimal retail centres in the study area. See table \\ref{tab:allmatches} for retail centre names. \\label{finalrcs}" width="438"}

\FloatBarrier

\newpage

# Results

\FloatBarrier

This section will describe the results of the initial scorecard calculations for the locations containing zero waste stores. It will discuss the demographic composition of the 20 minute walking time catchment areas around the stores, before describing the results of the retail centre processing, resulting in the most optimal locations for new stores.

### *Zero waste stores scorecard*

```{r, echo=FALSE}
# # Remove the COGS store
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr[-c(128), ]
# # Reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# # save it
# saveRDS(object = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
```

Once the scorecards for the stores had been calculated, summary tables were produced. All scores were calculated as means, based on the number of LSOA's that appeared within each isochrone catchment area and rounded to the nearest integer. For example, the first record of the examples in table \ref{tab:allzwsscrtable} shows that the mean for each variable (*carrank*, *dedrank*, *occrank*, *pplrank*, and *tenrank*) were 6, 3, 4, 5 and 7 respectively, while the total mean score (*lsoatotscr*) was 26.

Table \ref{tab:zws_scrsummary} shows the summary values for each variable. Across all 129 stores, the total scores out of a possible maximum of 50 (*lsoatotscr*) ranged from 15 through to 32, a mean of 24 and an interquartile range of between 22 to 27 was observed. The variables were scored out of a possible 10, and the greatest range of scores was seen in the *tenrank* variable which ranged from 1 to 9. The interquartile range of this variable was between 5 and 7 with a mean of 6. The smallest range was seen in the *carrank* variable which was between 3 and 7, and had an interquartile range of 0 (25th % and 75% were both 6) and a mean of 6.

To visualise this distribution of each the 129 stores, total and variable scores together, histogram plots were produced, and can be seen in figure \ref{fig:zw_scrs_hists}. The *lsoatotscr* (total scores) were distributed normally between 15 and 32. The *tenrank* variable was distributed widely with a negative skew. The variable for the households comprised two people without children (*pplrank*) was distributed fairly narrowly with a slight positive skew. The *occrank* and *dedrank* variables were more widely distributed and with a slight positive skew. The carrank variable was by contrast very narrowly distributed and showed a negative skew.

Figure \ref{fig:corr_plot} shows the correlation between the individual variables and the total scores. This visualises the varying strength of the relationships between the variables and between the total score (*lsoatotscr*). For example, the degree educated (*dedrank*), occupation (*occrank*) and home-ownership (*occrank*) variables all have a more positive linear relationship with the total score, than the vehicle access (*carrank*) and household composition (pplrank) variables. As expected, there is a strong positive correlation between the *dedrank* and *occrank* scores. Those variables that seemed to display a more negative relationship were between the *pplrank* and *dedrank*.

Less linear correlations can be seen in the relationship between the *tenrank* and, *dedrank* and *occrank* variables for example. As *tenrank* increases both *dedrank* and *occrank* decrease up to a certain point. After this point, they both increase at roughly the same rate.

So that a comparison could be made between the store(s) with the lowest and the store(s) with the highest score as seen in table \ref{tab:minmaxstore_tab} distribution histograms were produced side by side for comparison (see \ref{fig:minmaxcomp_plot}.

The smallest difference between the individual scores in the these two stores was seen in the household composition (*pplrank*) variable with the lowest and highest scoring stores scored 2 and 4 respectively. The vehicle access variable (*carrank*) was also fairly low with the lowest to the highest scoring store being 5 and 8 respectively. All other variables were considerably higher for the store with the highest score, and the totals for each being 15 for the low scoring store and 32 for the highest store.

These were then individually mapped so that a picture of the physical locations could be visualised and compared. Both stores appear to be located in urban areas of cities. (See figures \ref{fig:minstr_map} and \ref{fig:maxstr_map}.

The highest scoring store as seen in \ref{fig:maxstr_map} is located within Teddington which is an area of South-West London in the borough of Richmond upon Thames. This is a relatively small residential area, with a small local retail centre in the middle (on which the store was found), and is surrounded by large areas of greenspace.

```{r}
# Get the retail centres for the min and max stores
# Load the retail centres data
# rcs <- readRDS("joined_rc_results.rds")
# # Load the maxstore data
# maxstore <- readRDS("maxstore.rds")
# 
# # Look to see if the store sits within a retail centre
# rcmaxstr = rcs[maxstore$zwsgeometry,]
# # Save the max store retail centre
# saveRDS(object = rcmaxstr, file = "rcmaxstr.rds")
```

The lowest scoring store as seen in \ref{fig:minstr_map} is located within the City of Leicester area which is in the Midlands of England. The store was found not to be located in a retail centre, but is situated on the campus of Leicester University. The isochrone however covers a large area of the city.

```{r, echo=FALSE}
# Get the retail centres for the min stores
# Load the retail centres data
# rcs <- readRDS("retail_c.rds")
# Load the minstore data
# minstore <- readRDS("minstore.rds")

# Look to see if the store siits within a retail centre
# rcminstr = rcs[minstore$zwsgeometry,]
# Save the min store retail centre
# saveRDS(object = rcminstr, file = "rcminstr.rds")
```

```{r}
############### Try to fix zws_joined_lsoa_scr.rds geometries #####################
###################################################################################
# # Load zwsiso
# zwsdata <- readRDS("zws_joined_lsoa_scr.rds")
# a = as.data.frame(zwsdata)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$joinedlsoageom <- b$joinedlsoageom
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$isogeometry <- b$isogeometry
# 
# b = a[,c(1,18)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$zwsgeometry <- b$zwsgeometry
# 
# ###################################################################################
# # # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1) +
# #   geom_sf(aes(geometry = zwsgeometry))
# # 
# ###################################################################################
# # # FINAL TEST
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # #################################################################################
# zwsdata = a
# zwsdata = st_as_sf(zwsdata)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr = zwsdata
# zws_joined_lsoa_scr$zwsgeometry
# zws_joined_lsoa_scr$isogeometry
# zws_joined_lsoa_scr$joinedlsoageom
# 
# ###################################################################################
# # TEST PLOT
# ggplot(zws_joined_lsoa_scr[93,]) +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   geom_sf(aes(geometry = zwsgeometry)) +
#   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
#   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
```

```{r}
# # reindex the rc_joined_lsoa_scr data
# rownames(rc_joined_lsoa_scr) <- 1:nrow(rc_joined_lsoa_scr)
# ###################################################################################
# # TEST PLOT
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # i = 0
# # i = i + 1
# # a = rc_joined_lsoa_scr[i,]
# # a
# # st_geometry(a) <- "rcwalktime"
# # a
# # st_geometry(a) <- "joinedlsoageom"
# # a
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "black") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "brown", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "blue") +
# #   geom_sf(aes(geometry = joinedlsoageom, fill = lsoatotscr), alpha = 0.1, colour = "red")
# # THIS WORKED
# #################################################################################
```

\newpage

### Retail centres results

```{r join_rc_results, echo=FALSE}
# joined_rc_results <- rbind(rca_results, rcaa_results, rcb_results, rcbb_results, rcc_results, rccc_results)
# saveRDS(object = joined_rc_results, file = "joined_rc_results.rds")
# remove(rca_results, rcaa_results, rcb_results, rcbb_results, rcc_results, rccc_results)
```

A summary of the retail centre scores can be seen in table \ref{tab:rc_scrs_summary} below. A total of 5139 retail centres were processed. The total scores out of a possible 50, ranged from between 12 and 36. The mean was calculated to 23 with a median value of 22 and an interquartile range of between 20 and 25.

Again, each variable was scored out of 10, showing a very wide range of scores across all 5 individual variables, with *carrank* being the most narrow (between 2 and 8) and *tenrank* being the widest (between 1 and 10).

\FloatBarrier

Distributions of all scores for all retail centres were produced. Figure \ref{fig:all_rc_hists} shows that all retail centres were distributed normally. The *tenrank* and *carrank* variables were negatively skewed with the *tenrank* widely distributed and *carrank* more narrowly distributed. The widely distributed *pplrank* and *occrank,* and narrowly distributed *dedrank* variables were all positively skewed.

\FloatBarrier

Those retail centres that scored a total that fell within the interquartile range (22 to 27) of the stores scores were identified, and the summary results can be seen in table \ref{tab:rc_zwsiqr_scrs_summary} below.

The results here show that there were 2089 of these retail centres The lowest scoring variable was the *dedrank* variable which ranged from 0 to 7.

\FloatBarrier

The distribution histograms as seen in \ref{fig:rc_iqr_hists} show that the widely distributed *tenrank* and narrowly distributed *carrank* variables were negatively skewed. The occrank and dedrank variables were more widely distributed than the pplrank variable and all were positively skewed to varying degrees.

\FloatBarrier

Due to the rounding of score values, the average total store score was calculated to 24. This was used to locate all the retail centres that also scored 24. There were 529 of these retail centres in total, and the summaries for the total and variables can be seen in table \ref{tab:rc_eqzws_scrs_summary}.

\FloatBarrier

The distribution histograms seen in figure \ref{fig:rc_zws_mean_hists} below show the single average total score (24) for the retail centres. The variables were fairly narrowly distributed with *tenrank*, *pplrank* and *carrank* all negatively skewed, and *occrank* and *dedrank* positively skewed. the *tenrank* and *carrank* variables seemed to be particularly high scoring among these retail centres, while the *dedrank* variable seems particularly low on average.

\FloatBarrier

Finally, the final set of potential retail centres that scored an average within +-1 of the same variable in the stores data, including the exact mean score (24) for the total score were identified. All conditions were to be met

```{r zws_rc_join}
# remove(a, i, z, rc_with_zws, retail_c, b, zws_joined_lsoa_scr, all_rcs)
# rc_with_zws <- readRDS("rc_with_zws.rds")
# # retail_c <- readRDS("retail_c.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# 
# ###############################################################################
# # ALL RETAIL CENTRES SETUP
# all_rcs <- read_sf('all_retailcentres.shp')
# saveRDS(object = all_rcs, file = "all_rcs.rds")
# 
# all_rcs <- readRDS('all_rcs.rds')
# all_rcs = st_transform(all_rcs, crs = st_crs(3857))
# ##############################################################################
# 
# # delete the RC geometry column
# zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr = zws_joined_lsoa_scr |> dplyr::select(-one_of('V21'))
# zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)
# 
# # Create a blank dataframe to hold the new data ready to copy to the zws data
# b <- data.frame(matrix(ncol = 22, nrow = 0))
# 
# # set up the counter
# i = 0
# i = i + 1
# missingrcs = 0
# # Start the loop
# for(i in 1:nrow(zws_joined_lsoa_scr)) {
#   # take the i row of zws_joined_lsoa_scr
#  z = zws_joined_lsoa_scr[i,]
#  # # Set the active geometry column
#   # st_geometry(z) <- "rcgeometry"
#  # get the retail centre that i sits in
#  a = all_rcs[z,]
# 
#  # check to see of the store is contaned within a retail centre
#    if(nrow(a) == 0) {
#      cat(i, "No Coordinates\r")
# # Add the row from z to the b dataframe 
#     z = cbind(z, a[i,c(4,10)])
#   b = rbind(b, z)
#   missingrcs = missingrcs + 1
#    next
#  }
# dammt = cbind(z, a[,c(4,10)])
# # Add the row from z to the b dataframe 
#   b = rbind(b, dammt)
# 
# # remove a and z
#   remove(a, z, dammt)
# 
# ##   # print i as a count of rows that have completed
#  cat(i, ".....completed\r")
#   # Sys.sleep(1)
# 
# }
# # Make the zwsjoined dataframe the same as the b dataframe
# zws_joined_lsoa_scr[,c(21:22)] = b[,c(18,22)]
# saveRDS(object = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
# 
# remove(a, i, z, rc_with_zws, retail_c, b, all_rcs)
```

![Map of optimal retail centres in the study area. See table \ref{tab:allmatches} for retail centre names. \label{finalrcs}](matchmap.png){alt="Map of optimal retail centres in the study area. See table \\ref{tab:allmatches} for retail centre names. \\label{finalrcs}" width="438"}

\newpage

# Discussion

The question as to whether socio-demographic variables that relate to EC behaviour can help to define optimal locations for ZWS will be discussed here. This section will discuss the various findings of this study and link them to the relevant literature. It will discuss the demographic variables in terms of their ability to provide evidence that justify store locations, the store locations and scores related to these variables, the retail centres and their scores, and the possible optimal new stores locations.

### *The relevance of demographic characteristics used*

Figure \ref{fig:corr_plot} shows that there is a varying degree of strength in the relationship between the individual variables for each catchment area, with the majority being strong and positive. Overall, these relationships positively reflect the bulk of the literature related to demographic characteristics in the context of EC behaviours. It is important to note however, that there is also a body of work that contradicts some of the findings of these studies [@chekima2016; @figueroa-garcia2018; @panzone2016].

Occupation type and education level can individually indicate increased spending potential and environmental concern / awareness, resulting in more ethical consumption decisions. Occupation and education variables and the link between them (as seen in figure \ref{fig:corr_plot}) is consistent with the increased EC behaviours seen in the study by @chen2023. They found that the link between these and the resultant higher spending potential allowed respondents to make more environmentally ethical decisions around consumption. Individually, education was an important factor as seen in the results by @roberts1997, in which a higher level of education signified a higher level of environmental knowledge that influenced more EC behaviour. Occupation types that are often from degree education levels, and therefore offer higher earnings, combined to act as partial proxies for wealth and therefore spending power. This was required, because firstly the lack of availability of income data, and secondly, as @martinsons1997 points out, more educated and wealthier consumers are more likely to be more environmentally sensitive.

Household composition can also be seen as a partial proxy for increased spending potential, but also as an indicator for behavioural influence and change, whilst tenure also reflects the increased spending potential. Tenure in this study was defined by home ownership, and is also linked to the variable for the number of people in a household, which was limited to two people per household with no resident children. Combined, these households generally have a greater spending power, but household composition also plays an important role in that members of the household are more likely to influence each others environmental consciousness [@diamantopoulos2003]. This study showed that there was a positive relationships between the number of the people in a household and home ownership (see figure \ref{fig:corr_plot}).

Vehicle access was an important characteristic for two reasons. Car ownership amongst the most environmentally conscious is lower. However, this group of people often tend to own a single car that is used infrequently for longer journeys, or due to the lack of public transport options [@gilg2005]. This was perhaps the variable with the weakest relationship between other variables, but was important to include due to the aforementioned reasons.\

### *Zero waste stores and their catchment area scores*

Demographic constituents of a catchment area of an existing store are the logical starting point for analysis in retail [@birkin2017]. This can help particular retail suppliers target specific demographic markets, such as McDonald's who will target younger consumers from a wide range of backgrounds. In this study, catchment areas around the stores were defined as a 20 minute walk-time rather an an arbitrary distance and because of the choice of scale (LSOA), and captured a range of population differences, including the demographic variables used to define the scores.

Comparison between the stores with the lowest and highest scores as seen in figures \ref{fig:minmaxcomp_plot}, \ref{fig:maxstr_map} and \ref{fig:minstr_map} indicates that the results for individual stores and their physical locations are less important than looking at the results as a complete set of data.

For example, the store with the highest score, was the 'Refill Larder' sited in Teddington in the London borough of Richmond upon Thames. It was on a Small Local Retail Centre, in a relatively wealthy urban location and scored relatively high across all variables. Contrast this with the store with the lowest overall score, which was called NADA. This was located on the University of Leicester campus. This difference in score and location does not automatically equate to success or failure, or an optimal versus sub-optimal location, and highlights potential issues in determining optimal locations based solely upon analysis of variables such as those used in this study, rather than looking at the distributions and averages of all of the results.

Without spending data it is difficult to say whether any store is more or less successful than any other, however, in terms of potential demand the NADA store score does not score highly on any variable, but due to it's location, the individual low scores (especially for education level), and location, become less relevant. The evidence that degree educated populations are more likely to understand and engage with the environmental concepts involved in the ethos of zero waste stores has been discussed as one of the most important demographic characteristics according to the literature [@balderjahn1988; @aprilia2022; @bogusz2021; @chekima2016]. Situated on a university campus, the majority of the demand population for the NADA store are not educated to degree level (yet), but are however on that path and it could be argued that this should increase the weighting of the education level score for this and other similar locations.

Taking the above difficulties in to account, and by looking at the complete set of ZWS scores as a whole, it is clear that there are no stores that signify and more or less optimal location, and that none sit at either extremity of the range of scores (see figure \ref{fig:zw_scrs_hists} for all store score distributions). This suggests that firstly, all stores sit in locations that display, on average, demographics that have relatively normal distributed populations related to the variables used. This in turn suggests that narrowing down the potential locations for new stores should be based on this range of scores or a combination of averages taken from the range of scores, rather than using a range from the highest scoring stores.\

### *Identifying optimal retail centres using the scores from the stores data*

Retail centres that could be classified as potential new store locations were identified though a series of steps that incrementally narrowed the results down. This was done by decreasing the range of store scores to derive the results from.

The full range of retail centre total and individual variable scores can be seen in the summary table \ref{tab:rc_scrs_summary} and distribution histograms can be seen in figure \ref{fig:rcminmax_hists}. When compared to the distributions of the stores (see table \ref{tab:zws_scrsummary} and figure \ref{fig:zw_scrs_hists}, the distributions show similar shapes and ranges. This suggests that the majority of the stores are located within a retail centre. However, as discussed, the NADA store on the University of Leicester campus is not on a retail centre. This may hint at the possibility that it is not entirely necessary that a store is placed in a retail centre. especially when taking in to consideration the scores for each of the lowest scoring locations (retail centre and store). The NADA store actually scored higher than the lowest retail centre score, implying some retail centres are less optimal than some non-retail centre locations. This feature is not uncommon, as according to [@birkin2017], in the context of UK Post Office locations, the use of 'fuzzy' membership of a retail centre can be used because stores / services that are located close to retail centres, may still experience some of the benefits of retail adjacency and centre quality.

Initially, the majority of the 5876 RCs scores were found to be within the store score range with only 258 sitting outside of this, leaving 5618 potential locations. These were filtered using the interquartile range of store scores, which resulted in 2089 RC locations. Further filtering was carried out using the mean store total score, which left 529 RCs as potential locations. The final filter was to apply the mean of each of the 5 variables and the mean of the total store scores, which resulted in the final RC results. 9 retail centres remained and these were identified as the most optimal. Table \ref{tab:allmatches} shows these and highlights some important points.

```{r final_rcs_map, fig.height=5, fig.width=5, fig.cap="Classifications of final optimal retail centres."}
# allmatches <- readRDS("allmatches.rds")
# lsoas <- readRDS("lsoas.rds")
# 
# # set the active geometry (rccentroidgeom)
# st_geometry(allmatches) <- "rccentroidgeom"
# st_geometry(lsoas) <- "lsoageometry"
# 
# # Set the CRS
# allmatches <- st_transform(allmatches, crs = st_crs(4326))
# lsoas <- st_transform(lsoas, crs = st_crs(4326))
# 
# # Add the row id to a new column
# allmatches <- tibble::rowid_to_column(allmatches, "ID")
# 
# # Plot the data
# matchmap <- ggplot(allmatches, aes(geometry = rccentroidgeom)) +
#   annotation_map_tile(zoomin = -1, type = "cartolight") +
#   geom_sf(aes(colour = allmatches$Classifica)) +
#   geom_sf_text(aes(label = allmatches$ID),
#                nudge_x = c(-0.1, 0.1, -0.1),
#                nudge_y = c(0.1, 0.1, 0.1)) +
#   geom_sf(data = lsoas, aes(geometry = lsoageometry), linewidth = NA, fill = NA) +
#   guides(colour = guide_legend(title = "Retail Centre Classification", reverse = FALSE)) +
#   theme_void(base_size = 10)
# 
# ggsave("matchmap.png")
```

Figure \ref{finalrcs}, shows the optimal retail centres are located around the west of England and in Wales. The majority of the potential retail centres are classified as 'Small Local Centre'. This point to the importance of proximity which coincides with the ethical framework of the environmentally concious retail principles of zero waste stores. In terms of the environment and social equity, the sourcing of local produce from local producers, minimising supply chains, and an ethical approach to trading is an important reason that this sector of retail aims to address. All of these aims can help to minimise excessive transportation requirements, and reduce the amount of chemicals needed to preserve food items that are used in the the longer supply chains of the larger supermarkets [@beitzen-heineke2017]. Local proximity also brings increased social benefits, such as linking local suppliers to the local demand market. It can also, encourage more engagement from residents with their local neighbourhoods, including other stores in these smaller local centres, providing greater convenience, and an enhanced community [@carrigan2004; @beitzen-heineke2017].\

### *Discussion of the benefits and limitations of the methods used in the study*

The variables used in this study were chosen for their implications of environmentally conscious consumer behaviours. Creating scorecards based upon these behaviours at the LSOA scale was successful in terms of the processes followed, however, the number of variables chosen limited the findings by increasing the range of potential stores. With the previously discussed contradictory literature in mind, the inclusion of additional variables could have been argued for. For example, with regards to sex, there are bodies of work that conclude that females are more likely to actively engage with EC behaviour [@badowska2019; @bartek2022; @tonglet2004], amongst others. However, due to the nature of the data available the impact of including this vaiable would have been minimal because LSOA data is in general split 50/50 between male and female population counts.

Another variable that could have been argued for inclusion in this study is age. There are however different bodies of work that provide evidence that individually cover all age bands as being more actively in the EC behaviours. For example @gilg2005 and amongst others have shown that older people are more likely to provide evidence of demand for zero waste stores through their EC behaviour, but @balderjahn1988 and @papaoikonomou2011 amongst others have shown younger people are more likely to exhibit the same behaviour. This points to a shift in EC attitudes amongst the general population, and that all age ranges are equally valid and should be included in the study.

With regards to the process of narrowing down and filtering optimal retail centre locations based on scorecards, this study has shown that due to the range of store scores and retail centre scores, without sales data, it is very difficult to do. It could be argued that because both sets of score distributions were similar, it could be argued that any retail centre could be argued as being a potential location for a new store. Sales data would have been able to give a metric of success and would have been able to have been correlated with each variable. This would have given an idea of the most influential variables, which would have allowed for decisions about the their inclusion/exclusion and weighting to have been made.

\newpage

# Conclusion & Recommendations

WRITE THE CONCLUSIONS HERE

\newpage

Limitations / Rec

OA scale data would have been better

House prices would be a good measure of wealth perhaps (See Teddington vs Coventry stores)

I would lok at car ownership again but use the ownership of electric cars rather than any other.

The size of store and outgoings versus the spend required to keep it afloat would be a pertinent inversitgation, as this would highlight the percentage of a catchment area that is required, and relate that to EC consumer behaviours

\newpage

# References

::: {#refs}
\noindent \vspace{-2em} \setlength{\parindent}{-0.5in} \setlength{\leftskip}{0.5in} \setlength{\parskip}{15pt}
:::

# Appendices
