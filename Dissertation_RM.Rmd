---
title: "An Investigation Into The Use Of Socio-Demographics For The Location Optimisation Of 'Zero-Waste' Shops In England & Wales"
#author: "Student id: 201578497"
geometry: "left=1.2cm,right=1.2cm,top=1.5cm,bottom=1.5cm"
output:
  pdf_document: 
    latex_engine: xelatex
    fig_caption: yes
    toc: yes
  
header-includes:
# Use the packages
  - \usepackage{setspace}
  - \usepackage{lastpage}
  - \usepackage{fontspec}
  - \usepackage{placeins}
  - \usepackage{fancyhdr}
  - \usepackage{biblatex}
  - \setlength\bibitemsep{1.5\itemsep}
# Set the font
  - \setmainfont{Calibri}

# Set line spacing
  - \onehalfspacing

# Header and Footer Settings
  - \fancyhf{}
  - \pagestyle{fancy}

# References and bibliography settings
csl: C:/Users/James/OneDrive/Documents/R/win-library/4.1/markdown/csl/UoL_Harvard.csl

#csl: https://www.zotero.org/styles/harvard-university-of-leeds
bibliography: references.bib
---

```{=tex}
\fancyhf{}
\thispagestyle{fancy}
\fancyhead[R]{201578497}
\fancyhead[L]{GEOG3050}
\rfoot{\thepage\ of \pageref{LastPage}}
```

------------------------------------------------------------------------

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	error = FALSE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE,
	comment = "",
	tidy = FALSE
)
cache.val = T

# Load / Install packages-------------------------------------------------------
#install.packages("", dependecies = TRUE)
library(knitr)
library(sf)
library(kableExtra)
library(ggplot2)
library(basemaps)
library(mapview)
library(openrouteservice)
library(ggspatial)
library(stringr)
library(patchwork)
library(dplyr)
library(rgdal)
library(viridis)
library(corrplot)
library(tidyr)
library(tidyverse)
library(sp)
library(maptools)
library(rgeos)
library(readxl)
library(gridExtra)
library(psych)
library(reshape2)
library(sjmisc)
library(spatstat)
library(raster)
library(ggthemes)

#API Key info - should only need loading once -  500
# ors_api_key("5b3ce3597851110001cf62480f8858be0885487ca2a78900b689815b")

#API Key info - should only need loading once -  2500
# ors_api_key("5b3ce3597851110001cf624810789863e851418a86e0341fb278a772")
```

\FloatBarrier

\maketitle

------------------------------------------------------------------------

\newpage

## Abstract

WRITE THE ABSTRACT HERE

## Introduction

WRITE THE INTROCUDTION HERE

## Literature Review

This section will review the literature on some of the most relevant and important methods of store location planning that are employed in the retail sector. Each will be discussed and critiqued for appropriateness for use in this study. A review of studies that focus on environmentally conscious consumption behaviours and associated demographic profiles will be carried out. This will provide the justification for the decisions taken around the choices of data that will be used in the chosen method for this piece of work.

Municipal waste, as a general concept, and in particular packaging waste, and the way in which we all as consumers can tackle the associated issues with the latter will be discussed. Firstly, a brief history of waste will be described for context, including some of the problems that are associated with production and consumerism. Secondly, the review will move on to a critique of the research in relation to zero-waste lifestyles and the changes in attitudes and practices towards environmentally conscious consumption. Insight in to the growth of zero-waste shops and the related product solutions that are linked to these, which help move retail towards zero-waste consumer practices will be addressed. The picture will move towards a focus on how these solutions are being practised in England and Wales.

### Zero Waste Concept: Then & Now

Prior to industrialization, society produced very little waste [@mauch2022]. People would feed livestock with leftover food, repair broken items, and household goods such as furniture would be handed down to the next generation. With the advent of industrial capitalism in the mid-nineteenth century, production was designed to maintain itself, and old products discarded when a new, or better product when one is made available. This is the defining feature of consumerism [@graeber2011]. After World War II the world inevitably saw a huge rise in waste of all kinds due to mass-production and mass-consumerism. As Figure \ref{globalwaste} shows, the amount of waste generated globally in 1965 was around 635 million tonnes (mt) increasing to 1999 mt in 2015, and is projected to rise to 3539 mt by 2050 [@chen2020].

\FloatBarrier

![Global Yearly Waste Production by Type [@chen2020]\label{globalwaste}](Images/Globalwaste.png){width="514"}

\FloatBarrier

The term "zero waste" was coined in 1973 by Paul Palmer [@zaman2015] in relation to the reusable "clean" chemical waste being produced in Silicone Valley. He started selling these chemicals back to the industry with the principal strategy that everything should be reused rather than used once and discarded [@mauch2022]. The term evolved over the following years and today, there seems to be no consensus on the definition as such [@pietzsch2017]. Zero-waste as a term that now encompasses the theory, practice, and learning of governments through to individuals, and is a catch-all term for the response to the perceived crisis of waste and the failure to manage it [@hannon2018].

In England in 2002 for example, it was estimated that producers accounted for 91% of national waste [@murray2002]. Within the area of manufacturing and production for example, zero-waste as a concept is an effective way to help minimise solid waste, and through redesign, resource life cycles enable products to be reused [@song2015].

From a consumer perspective, food waste reduction has become one of the biggest areas of concern for zero waste research [@zhang2022]. Around one third of all the food bought is thrown away in England [@murray2002], and environmental deterioration that is caused by this non-sustainable consumption impedes sustainable development [@chekima2016; @badowska2019]. Food waste is linked to packaging. Food retail uses the highest amount of plastics and is the reason why packaging makes up the largest constituent of plastic waste [@sastre2022]. Figure \ref{globalplastic} shows that global plastic production in 2015 was just under 350 mt with over 35% of all plastic produced being used for packaging (see figure \ref{plasticuses}).

\FloatBarrier

![Global Plastic Production : 1950 - 2015 [@beckman2018] \label{globalplastic}](Images/WorldPlastic_1950_2015.png){width="300"}

![The different uses of plastic. [@beckman2018] \label{plasticuses}](Images/Plastic_use.png){width="300"}

\FloatBarrier

Figure \ref{ancum_plastic} shows that around 10 mt of plastics that are produced end up in the worlds oceans. Although the annual amount is predicted to fall, the cumulative effect of adding to the problem, is estimated to rise, albeit slower, to over 1500 mt by 2100.

\FloatBarrier

![Annual and Cumulative Plastic Input into Oceans [@chen2020]\label{ancum_plastic}](Images/ann_cum_plastic.png){width="514"}

\FloatBarrier

The problem of waste in food retail can partly be addressed through product design, where packaging can be produced to have as little impact on the environment as possible. The idea of minimising environmental damage from packaging and it's relationship with sustainability has indeed seen a large increase in research and literature [@sastre2022], and in the UK there have even been trials of changes to packaging free retail in some of the larger supermarket chains.

In 2019, Waitrose launched a trial in its Oxford store where it dedicated a section of the store to a new refill station, where cleaning materials, wine, and dried goods such as rice were made available to customers that wanted to use their own reusable containers. By testing this method of shopping in store, they were able to gauge how much appetite there was for a different type of shopping experience [@smithers2019]. by doing this they have shown how significant the role of the consumer is in how food retail operates. and the problem of food waste and how a move to sustainable consumerism can be achieved. Due to the success of the trial of Waitrose "Unpacked", they introduced the refill options to three other stores, and as interest and demand grows, they hope to offer the "Unpacked" option in more stores and online over time [@waitrose&partners].

### Zero Waste Shops

Zero-waste shops are shops that are dedicated to eliminating all unnecessary waste from the retail consumer experience [@watson2020]. They do this with practices that eliminate plastic packaging by displaying products in bulk where they can, and customers bring their own containers for items, or use paper bags for supplied by the store. They also aim to send all food that expires to food-banks or community kitchens, further eliminating waste in this way. Bulk purchasing of saleable products is another goal, which minimises transport waste products such as CO~2~. Another important aim for zero-waste shops is to stock products with known origins from suppliers with similar priorities that are as local as possible [@believeearth2017].

Zero-waste shops, using these practices, can help in the building of a sense of community. They are often small neighbourhood stores that have been started though crowd-funding or another local campaign [@greenpeaceusa2019]. This allows for the community around them to be involved from the start and provides a sense of investment in the success of the store.

However, as the demand for sustainable retail rises, the competition for customers will increase, and as Waitrose have already stated, the larger stores will be able to offer more choice than perhaps the smaller dedicated local stores can. This may mean that product choice in the larger retailers will be greater, but as described above, there is more to environmentally conscious retail than simply packaging and the elimination of plastic. The larger retailers will also have to consider the ethical choices made by consumers in relation to the environmental impacts of supply chains, and the related support for local producers.

### The customer

Because the community tends to provide the customers for these shops, an important question to answer, is one that asks who these customers are likely to be. A survey to identify the levels of environmental awareness in consumers was carried out in Slovakia. It targeted the age groups between 1965-1980 (*gen' x*) and 1981-1996 (*gen' y*), due to their greater purchasing power over other groups. They found that amongst the *gen' y* group, 39% were likely to use zero-waste stores often as opposed to 10% of the *gen' x* group [@holotova2020]. This suggests that age is an important variable when analysing the demographics of the customer base of zero-waste stores. @diamantopoulos2003 highlights the weakness in using socio-demographics to try to define a 'green consumer', as environmental 'awareness' is not fully understood through gender, age and education etc. However, there are a large number of studies including [@sang2015; @bekhet2011; @yuan2013; @zhao2014], who have all found that environmentally conscious 'behaviours' are strongly associated with demographic characteristics such as age, education, occupation type, and income to name a few. AGE SHOULD ONT BE A VARIABLE AND SHOULD BE TESTED AFTER RESULTS HAVE BEEN SHOWN. THIS CAN HIGHLIGHT THE IMPORTANCE OF AGE RATHER THAN ARBITRARILY CHOOSING AN AGE A A VARIABLE TO INCLUDE IN THE SCORECARD.

### Store planning

**Geodemographics**

1)  I think it is too general. Be specific in how this can relate to customers for this type of retail

In order to analyse the potential of a location, retailers need to know the market demand that exists. To do this, they use, amongst other data, geodemographic classifications that have been aggregated from census and other sources. Data are aggregated in to small areas such as post-code, or the Output Area Classification [@birkin2017]. Potential customers must be identified from the data and in the case of the zero-waste store, environmentally conscious or green consumer behaviours and characteristics are essential to understand the demand.

Around 86% of the UK population is classed as urban and as with cities across the globe, population growth is expected to see over 90% of the worlds population living in cities, and the waste that is produced in them also grow [@statista]. This hints at the need to look at the demographic make-up of urban populations rather than rural communities.

The environmental context is complex to understand, therefore adults that have a high education level must be considered as potential ethical consumers in the first instance [@paul2016; @chekima2016]. It is known that urban populations are more likely to be highly educated, and gain higher incomes [@wensing2023a]. Gender and age are also indicators of environmentally conscious consumerism. @gilg2005 found that 65% of committed environmental behaviours in relation to consumerism were attributed to females in the study, and the mean age was 55 years. **HAS THIS CHANGED - GOTTEN YOUNGER RECENTLY??** However, in the UK 18-24 is the age at which females especially are likely to consume ethically.

The UK urban population population is

These provide a snapshot of the age ranges, ethnicities, population density, household compositions, housing type and socio-economic make-up and employment classifications for example, in each area, which can in turn be used to target specific groups based on the market for a particular service. A problem with the averaging of characteristics in this way is known as the ecological fallacy [@openshaw1984]. This is essentially when an averaged characteristic of an area is applied to the individual scale, which potentially ignores or fails to recognise finer detail in demographic make-up of an area. For example, an area may be calculated to be wealthy, but within that region there may be a pocket of poverty that is aggregated out and vital support for this population may be missed.

**Catchment Area**

Defining the catchment area for a store is highly important aspect of retail location analysis. To do this, a possible solution would be to draw an arbitrary boundary around the store location and include the population within that boundary as potential custom [@hernandez2000]. A more realistic catchment area definition would be to estimate how far a customer will travel, either by foot, car, or by public transport, to a store location. A boundary that is 20 minutes walk to the store location could be used for example, and would take in to account terrain and route layout in terms of accessibility. Using a buffer and overlay system available in GIS can build an accurate picture of an area through the addition or removal of features. For example, a discount retailer looking for a new store location may filter out customers from a higher income class in an area leaving lower income populations in the analysis data [@birkin2017]. It may also provide a better picture of the residential make-up of an area, by allowing for non-residential areas to be accounted for, thus providing a more accurate picture of the demographics of an area, and therefore potential custom. This can be used in conjunction with a network analysis, in which accessibility can be further investigated. This entails a more comprehensive analysis of road networks to deduce the travel times to the providers of a service [@birkin2017].

**Location Choice**

Once various locations have been identified, a choice must be made. There are numerous methods for choosing a location of a store, and these can range from the more simple to highly complex. The simpler, cheaper and traditional approach, where experience tells the planner where to locate a store has not entirely been replaced by the more complex methods such as checklists or scorecards [@hernandez2000].

Checklists involve the scoring of a number of chosen variables that positively influence store performance. The variables are rated according to a points system which when combined, can be used to compare other potential locations [@hernandez2000]. This is part of an analogue method of location analysis, in which, once the demographic and retail centre classification variables to be used for the scorecard have been identified, each catchment area can be classified. It is apparent that this technique can be used to investigate the similarities and differences between each location, providing a picture of the customer base for a particular type of shop (in this case; zero-waste stores). Although this method is good at providing a rating of different locations based on potential customers, and allows comparisons between locations to be made, it is unable to estimate revenue [@birkin2017]. This study is not seeking to estimate the success or failure of a store on predicted or current revenue data due to it being unavailable.

Multi-variate regression methods are more complex still, and require a great deal of (good quality) data, computing power, and expertise. Decisions are based upon statistically significant results [@hernandez2000]. These methods are good at benchmarking sales forecasting, for example, and mainly used for future development for specific products, or new stores. The same restrictive factors such as computing power are also prevalent in methods such as cluster and factor analysis, where a retailers portfolio can be clustered in to types of offering and used to create a blueprint for strategic change, such as creating discount lines to be sold in cheaper stores based in lower income demographic areas.

Gravity modelling, Spatial Interaction Models (SIMs), and neural network methods are even more complex and expensive to facilitate, in terms of expertise, computing and data. SIMs generally rely on the availability of data such as flows of revenue for example [@birkin1999]. They show the relationships between the flow of consumers and revenue, and are used in the analysis of a new store, or a competitor opening in a location, and the effect it will have on existing provision. [@hernandez2000]. Neural networks are essentially a scaled up version of this and are used to forecast performance related to a large number of new sites

### Conclusion

It has been suggested that statistical modelling such as regression analysis and Spatial interaction Modelling based on the link between flows of money are useful tools for retail location analysis and site planning [@wood2007; @birkin2017; @hernandez2000], however, access to sales data will is restricted and hard to access for resource limited studies. Buffer and overlay techniques take in to account non-residential areas, travel time, and mode of transport, and can be applied to define appropriate catchment areas. Using carefully chosen demographic features, a scorecard or rating system can be applied to these catchment areas which can then replicate the analogue method, in which comparison can be made between the stores and their surrounding demographics related to environmental consumer behaviour. This information can then be extended to look for similar retail centres or demographically similar areas, in which one would expect to find a similar store.

\newpage

# Methodology

Education data - This was cleaned so that only those with degree or above education levels were shown. Each lsoa was then given a % of the population for that lsoa, and this % was given a score out from 0-10. [@papaoikonomou2011]

Occupation data [@bassi2023]

Time [@park2018]

Mean age of 55

High level of home ownership

High level of education

High Level of Income - use occupation as a proxy

Single Car per household

2 ppl per household - increased spending available

# 

In order to achieve the objectives set out in the previous section, a quantitative approach was taken to determining the demographics that surround the locations of the stores in the study area. This included the creation of a scorecard for each location, based on the selected demographic variables. The scorecards were then used to identify similar locations of the study area in which stores could be expected to be found. By incorporating statistical and geospatial techniques to the analysis of the data, and presenting the results of the study through geographical representation, a landscape of ethical consumption will be built up and visualised. This analysis will feed in to the discussion of the rationale behind the choices of variable used in the data, the methodological approach taken and an evaluation of the results.

#### Zero Waste Store Location Data

Location data for the stores to be used was retrieved using the metadata of the The Zero Waste Network [@thezerowastenetwork] (ZWN) website. This was, by comparison to other similar website's and directories, the most comprehensive listing found. These data were cleaned through Google searches to identify and remove any stores that were irrelevant to the study, such as incorrectly listed stores, wholesalers, and mobile refill vehicles, and also to highlight any that had closed since being listed. Of the initial 172 stores, 135 remained. Table \ref{tab:zws} shows the first 10 records of this cleaned data. To ensure that the remaining stores sat within the study area a plot of all the locations was made and can be seen in figure \ref{zwstores}.

```{r zwstab}
# Uses library(kableExtra)
# Load zws RDS file
zws <- readRDS("zws.rds")
# Display a table of the first 10 records
kable(zws[1:10,], caption = "\\label{tab:zws}Zero-waste stores data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
```

![Map of all Zero Waste Stores in Study Area. \label{zwstores}](Images/zwsmap.png){width="400"}

#### Demographic data

Nomisweb provided the latest Office for National Statistics, 2021 census data [\@nomis], at the LSOA scale. LSOA area codes were included to provide linked identifiers for GIS processing. The variables were found under the following identifiers,

TS003 - Household composition

This dataset included those households that were classified as either, married, single family households, with no children, or, cohabiting couple households with no children. See Table \ref{tab:pplscr}.

```{r 2ppl_data}
pplscr <- readRDS("pplscr.rds")
# # Create a table for the Household composition data 
# Load the 2ppl data
# pplscr <- read.csv("2ppl.csv")
# 
# # remove the country row
# pplscr = pplscr[-c(33756), ]
# 
# # clean the unrequired columns
# pplscr = pplscr |> select(-one_of('Total..All.households', 'X.', 'Single.family.household..Married.or.civil.partnership.couple..No.children', 'X..1', 'Single.family.household..Cohabiting.couple.family..No.children', 'X..2', 'tot_.', 'Score'))
# 
# pplscr <- pplscr  |>  rename_at('mnemonic', ~'LSOA21CD')

kable(pplscr[0:4,1:6], caption = "\\label{tab:pplscr}Total LSOA scores for household composition data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(pplscr)
# saveRDS(object = pplscr, file = "pplscr.rds")
```

TS045 - Car or van availability

This dataset included only those households that were reported as having access to a single vehicle only. See Table \ref{tab:carscr}.

```{r car_table}
carscr <- readRDS("carscr.rds")

# # Load the vehicle access data
# carscr <- read.csv("1car.csv")
# # clean the unrequired columns and rename them for ease of use
# carscr = carscr |> select(-one_of('Total..All.households', 'X1.car.or.van.in.household', 'score_calc', 'X.'))
# carscr <- carscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
# carscr <- carscr  |>  rename_at('score', ~'carscr')
# carscr <- carscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# #
# saveRDS(object = carscr, file = "carscr.rds")

kable(carscr[0:4,1:4], caption = "\\label{tab:carscr}Total LSOA scores for single vehicle access data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(carscr)
```

TS054 - Tenure - Home Ownership

This variable included those households that were reported as having either owning their own homes outright, or under a mortgage. See Table \ref{tab:tenscr}.

```{r tenure_table}
tenscr <- readRDS("tenscr.rds")

# Load the tenure data
#tenscr <- read.csv("tenure.csv")

# clean the unrequired columns and rename them for ease of use
# tenscr = tenscr |> select(-one_of('Total..All.households',  'score_calc', 'X.', #'Owned..Owns.outright', 'Owned..Owns.with.a.mortgage.or.loan', 'sum'))
# tenscr <- tenscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
# tenscr <- tenscr  |>  rename_at('score', ~'tenscr')
# tenscr <- tenscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# saveRDS(object = tenscr, file = "tenscr.rds")

kable(tenscr[0:4,1:5], caption = "\\label{tab:tenscr}Total LSOA scores for home owners that own outright or mortgage data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(tenscr)
```

TS067 - Highest level of qualification - degree educated

Education level data was only included those people that have degree level education or above. See Table \ref{tab:dedscr}.

```{r deg_ed_table}
dedscr <- readRDS("dedscr.rds")
# # Load the degree educated data
#  dedscr <- read.csv("degree_educated.csv")
# # 
# # # clean the unrequired columns and rename them for ease of use
#  dedscr = dedscr |> select(-one_of('Total..All.usual.residents.aged.16.years.and.over', 'degree_educated', 'X.', 'MinMax'))
#  dedscr <- dedscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
#  dedscr <- dedscr  |>  rename_at('score', ~'dedscr')
#  dedscr <- dedscr  |>  rename_at('mnemonic', ~'LSOA21CD')
#  
#  saveRDS(object = dedscr, file = "dedscr.rds")

kable(dedscr[0:4,1:4], caption = "\\label{tab:dedscr}Total LSOA scores for degree education level or above data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(dedscr)
```

TS063 - Occupation

Occupation data included those people whose occupations were classified as managers, directors, senior officials, and professional occupations. See Table \ref{tab:occscr}.

```{r occ_data}
occscr <- readRDS("occscr.rds")
# # Load the occupation data
# occscr <- read.csv("occ.csv")
# 
# # clean the unrequired columns and rename them for ease of use
#  occscr = occscr |> select(-one_of('Total..All.usual.residents.aged.16.years.and.over.in.employment.the.week.before.the.census', 'X.', 'X1..Managers..directors.and.senior.officials', 'X..1', 'X2..Professional.occupations', 'X..2', 'high_earners.', 'calc'))
#  occscr <- occscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
#  occscr <- occscr  |>  rename_at('score', ~'occscr')
#  occscr <- occscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# 
#  saveRDS(object = occscr, file = "occscr.rds")

kable(occscr[0:4,1:9], caption = "\\label{tab:occscr}Total LSOA scores for higher rated occupations for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(occscr)
```

Using excel to process the .csv files, the percentages were calculated from reported total households or individual populations for each of the 5 variables, and each was standardised using the scaling method in which each LSOA data point for each variable was scored / ranked from 0 to 1 using the following formula:-

$$
x_{norm} = (x_{raw} - min_{i})/(max_{i} - min_{i})
$$

These rankings were then multiplied up by 10 and rounded to the nearest integer to provide a final score for each individual LSOA for each variable between 0 and 10 inclusive.

#### LSOA Area Scale Boundary Data

Boundary data was downloaded for the study area from the Open Geography Portal [@opengeographyportala]. This related to the latest 2021 boundaries at the LSOA scale and includes the LSOA identifier and the attached geometries.

```{r lsoa_table}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoas <- readRDS("lsoas.rds")

# # remove the scores from the lsoa data
# lsoas = lsoas |> select(-one_of('occrank', 'tenrank', 'carrank', 'pplrank', 'dedrank'))

kable(lsoas[1:5,c(1,3,9)], caption = "\\label{tab:lsoas}LSOA boundary data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

#### Combining score data and calculating totals

The scores for each individual variable were allocated to the matching LSOA in the LSOA data. A total score for each LSOA was then calculated. The resulting dataset (see \ref{tab:lsoa_scores} for examples), was inspected to provide assurance that the process had resulted in individual scores ranged from 0 and 10 only, and total scores were within a 0 to 50 range. These scores would then be available when analysing the current store locations and the potential un-supplied retail centres.

```{r score_prep}
# Convert lsoas to a sf file format and set the CRS to 3857
# lsoas = st_as_sf(lsoas)
# lsoas = st_transform(lsoas, crs = st_crs(3857))

#### Create a dataframe that holds the LSOA21CD id and the score for each variable
# Convert the lsoas sf file to a data.frame
#lsoas = as.data.frame(lsoas)

# Join each variables score data to the LSOA data and remove the unrequired columns each time
# carscr
#lsoas = left_join(lsoas, carscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# dedscr
#lsoas = left_join(lsoas, dedscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# occscr
#lsoas = left_join(lsoas, occscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# pplscr
#lsoas = left_join(lsoas, pplscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# tenscr
#lsoas = left_join(lsoas, tenscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# sum the individual LSOA row values in columns 10 to 14 and add the result to a new column at the end after tenscr
#lsoas = lsoas |> 
#  mutate(lsoatotscr = rowSums(lsoas[,10:14], na.rm = TRUE),
#         .after=tenscr)

# remove unrequired temporary dataframes etc
#remove(carscr, dedscr, occscr, pplscr, tenscr)

# Save the lsoa data with the newly added individual scores and the calculated total scores
#saveRDS(obj = lsoas, file = "lsoas.rds")
# Load the results of the above code to save processing and memory when knitting
# lsoas <- readRDS("lsoas.rds")
```

```{r lsoa_score_table}
lsoas <- readRDS("lsoas.rds")

kable(st_drop_geometry(lsoas[1:5,c(1,3,9:14)]), caption = "\\label{tab:lsoa_scores}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

#### LSOA area scale population weighted centroids

Population Weighted Centroids (PWC) [\@opengeographyportal2022] data was retrieved at the LSOA scale. This data was required because once the stores and retail center isochrones had been calculated, those isochrones that contained a PWC would be filtered and used to calculate the scorecard for each location. PWC data can be seen in table \ref{tab:lsoa_pwcs}.

```{r pwc_data}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoa_pwc <- readRDS("lsoa_pwc.rds")

kable(lsoa_pwc[1:5,c(2,4)], caption = "\\label{tab:lsoa_pwcs}LSOA population weighted centroid data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoa_pwc)
```

#### Retail Centres

Retail centre boundaries for the study area were retrieved from the Consumer Data Research Centre [@consumerdataresearchcentre2022]. This data provided all retail centres in England and Wales, so that once analysis of all current zero waste store locations had been completed, potential retail centres that lack the supply of this type of store could be identified. The retail centre data was processed through QGIS to identify the geometric centroid of each, which was then added to the file and saved as seen in \ref{tab:rc_data}.

```{r retail_centre_data}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
retail_c <- readRDS("retail_c.rds")

# # # reindex the data
# rownames(retail_c) <- 1:nrow(retail_c)
# 
# saveRDS(object = retail_c, file = "retail_c.rds")

kable(st_drop_geometry(retail_c[1:5,c(2:5)]), caption = "\\label{tab:rc_data}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(retail_c)
```

#### 

#### Creating a test scorecard using a known store location

To test and refine the methods that will be used to process the full dataset of zero waste stores, a single test store was selected. This consisted of a store that was known and was located in a known area, which allowed for the method to be corrected due to erroneous or anomalous results.

The following test store results shows the process that will be followed for all ZWS. Once the ZWS data has been processed, the data for the retail centres that do not contain a zero waste store will be processed using the same methods. Table \ref{tab:bishytab} shows the store information data and figure \ref{fig:bishylocation} for a visual representation of the test area in question.

```{r bishy_load}
# Load bishy store boundary shapefile
bishy <- readRDS("bishy.rds")

# Convert this to the correct 3857 CRS
# bishy = st_transform(bishy, crs = st_crs(3857))

# rename the geometry column
# bishy <- bishy  |>  rename_at('geometry', ~'store_location')

kable(st_drop_geometry(bishy[,1:7]), caption = "\\label{tab:bishytab}Test store data for the Bishy Weigh store in York, England")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T)
remove(bishy)
```

```{r bishylocation, fig.cap="Location of The Bishy Weigh store in York"}
bishy <- readRDS("bishy.rds")
ggplot(bishy) +
  annotation_map_tile(zoomin = 0, type = "osm") +
  geom_sf(colour = "blue", aes(geometry = bishystorepoint, fill = st_nam)) +
  guides(fill = guide_legend(title = "Test Store Name"))
remove(bishy)
```

#### Calculating the isochrone

Using the OpenRouteService [@openrouteservice], a 20 minute walking time isochrone was calculated around the test store to define the catchment area. This distance/time was chosen partly due to the individual health benefits of walking [@tschentscher2013; @sari2010], and partly to fit in with the concept of a chrono-urbanism and temporally accessible city design such as the currently popular 15 and 20 minute city. The benefits of this concept include decreasing vehicle pollution and can help towards achieving the goal of net-zero amongst others [@ogorman2021; @moreno2021].

```{r bishy_iso}
# Load the York isochrone data from the previously run code below
# ywalktime20 <- readRDS("ywalktime20.rds")

# Uses library(mapview) and library(openrouteservice)
# Create an isochrone around the Bishy Weigh zero waste store

# embed data in the output file
# mapviewOptions(fgb = FALSE)

# Get the coordinates of the bishy weigh
#coordinates <- data.frame(lon = bishy$Lon, lat = bishy$Lat)

## Calculate a 20 minute walking time to the store
#ywalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                     output = "sf", profile = ors_profile("walking"))
#values <- levels(factor(ywalktime20$value))
#ranges <- split(ywalktime20, values)
#ranges <- ranges[rev(values)]
#names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)

# Convert the walktime20 isochrone to the correct CRS
#ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))

#remove(coordinates, values, ranges)
#
# Save the York isochrone data
#saveRDS(obj = ywalktime20, file = "ywalktime20.rds")
```

Once the isochrone had been calculated from the test store, it was mapped to ensure that the correct store location and catchment area had been calculated for the the known store. See Figure \ref{fig:york_isochrone_test_map}.

```{r york_isochrone_test_map, fig.cap="20 minutes walking distance isochrone from The Bishy Weigh store in York"}
bishy <- readRDS("bishy.rds")
# Uses library(ggspatial)
# Convert the walktime20 isochrone to the correct CRS
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
ywalktime20 <- readRDS("ywalktime20.rds")
# Map the 20 mins isochrone and store location
# use the walktime LAYER isochrone as the main data layer
ggplot(ywalktime20, aes(colour = "20 minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(fill = "blue", alpha = 0.1) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red", size = 2,
          aes(fill = st_nam)) +
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  
  # North arrow and scale bar
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tr", which_north = "true", 
                         pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
                         style = north_arrow_minimal) +
  theme_bw()
remove(ywalktime20, bishy)
```

After confirming that the isochrone calculation and store location data produced the desired results, the PWC data was clipped so that a set of data was produced that contained only those PWC that fell within the isochrone. This decision was made to ensure that only population centres and, importantly, the corresponding LSOA(s) that fell within the catchment area were included. If this was not taken in to consideration, the resulting scorecards could be open to possible inaccuracy. For example, the scorecards could be calculated using LSOA(s) that had a proportion within the isochrone, but with PWC situated further than 20 minutes from the store and outside of the isochrone, resulting in scores that include populations that have a walktime that is greater than 20 minutes. These results were then mapped to check method accuracy and can be seen in figure \ref{fig:bishy_pwc_clipped}.

```{r ypwc_clip, warning=FALSE}
pwc_clip <- readRDS("pwc_clip.rds")
# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# lsoas = readRDS("lsoas.rds")
# lsoas = st_as_sf(lsoas)
# ywalktime20 = readRDS("ywalktime20.rds")
###################################################################################
# Test plot an LSOA
# ggplot(lsoas[1,]) +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   geom_sf(aes(geometry = lsoageometry))
###################################################################################
# lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
#lsoa_pwc = readRDS("lsoa_pwc.rds")
# lsoa_pwc = st_as_sf(lsoa_pwc)
# lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
#ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# lsoas <- st_transform(lsoas, crs = st_crs(4326))
# lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(4326))

# clip the PWCs to only show those inside the 20 minute walk time
#pwc_clip = lsoa_pwc[ywalktime20$geometry,]
#saveRDS(object = pwc_clip, file = "pwc_clip.rds")
###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = -1, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
#   geom_sf(data = pwc_clip, aes(geometry = pwcgeometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
#   guides(alpha = guide_legend(title = "Catchment Area")) +
#   theme_void()
##################################################################################
```

```{r bishy_pwc_clipped, fig.cap="Population Weighted Centoids within the isochrone sourrounding The Bishy Weigh store in York"}
bishy <- readRDS("bishy.rds")
pwc_clip <- readRDS("pwc_clip.rds")
ywalktime20 <- readRDS("ywalktime20.rds")
ggplot() +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
  geom_sf(data = pwc_clip, aes(geometry = pwcgeometry, shape = "")) +
  guides(shape = guide_legend(title = "Population Weighted Centroids")) +
  geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
  guides(alpha = guide_legend(title = "Catchment Area")) +
  
    # North arrow and scale bar
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tr", which_north = "true", 
                         pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
                         style = north_arrow_minimal) +
  theme_bw()
remove(bishy, pwc_clip, ywalktime20)
```

Once the PWC that sat within the isochrone were found, the corresponding LSOA for that catchment area were identified using the LSOA identifiers. These were then mapped to visualise the results and confirm the accuracy of the procedure. Figure \ref{fig:pwcs_lsoas_york_map} shows these results.

```{r}
# lsoa_clip <- readRDS("lsoa_clip.rds")
# pwc_clip <- readRDS("pwc_clip.rds")
# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# #lsoas = readRDS("lsoas.rds")
# #lsoas = st_as_sf(lsoas)
# 
# ###################################################################################
# # Test plot an LSOA
# # ggplot(lsoas[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = lsoageometry))
# ###################################################################################
# # lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
# lsoa_pwc = readRDS("lsoa_pwc.rds")
# # lsoa_pwc = st_as_sf(lsoa_pwc)
# # lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# # lsoas <- st_transform(lsoas, crs = st_crs(4326))
# # lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(4326))
# 
# # clip the PWCs to only show those inside the 20 minute walk time
# pwc_clip = lsoa_pwc[ywalktime20$geometry,]
# # clip the LSOAs to only show those for the clipped PWCs
# # lsoas <- st_transform(lsoas, crs = st_crs(3857))
# # pwc_clip <- st_transform(pwc_clip, crs = st_crs(3857))
# lsoa_clip = lsoas[pwc_clip,]

###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry, alpha = "")) +
#   # guides(alpha = guide_legend(title = "LSOAs")) +
#   geom_sf(data = pwc_clip, aes(geometry = pwcgeometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, fill = ""), alpha = 0.1) +
#   guides(fill = guide_legend(title = "Isochrone"))
# #################################################################################
```

```{r pwcs_lsoas_york_map, warning=FALSE, fig.cap= "Map showing the clipped LSOAs related to the PWCs that fall inside the 20 minute walk time catchment area."}

lsoa_clip <- readRDS("lsoa_clip.rds")
pwc_clip <- readRDS("pwc_clip.rds")
bishy <- readRDS("bishy.rds")
ywalktime20 <- readRDS("ywalktime20.rds")

# Map the test store, isochrone and corresponding LSOAs and PWCs
ggplot(ywalktime20, aes(colour = "20 minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(data = lsoa_clip,  colour = "black", aes(alpha = "")) +
  geom_sf(data = pwc_clip, colour = "black", aes(shape = "")) +
    geom_sf(fill = "blue", alpha = 0.1) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red", size = 2,
          aes(fill = st_nam)) +
  
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  guides(alpha = guide_legend(title = "LSOA Boundaries")) +
  guides(shape = guide_legend(title = "LSOA PWCs")) +
  
  # North arrow and scale bar
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tr", which_north = "true", 
                         pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
                         style = north_arrow_minimal) +
  theme_void()
remove(ywalktime20, lsoa_clip, pwc_clip, bishy)
```

\FloatBarrier

The resulting test store catchment area contained 18 population weighted centroids. The corresponding LSOA scores previously calculated for each variable were mapped individually. This was to provide both a picture of the spatial distribution of the variables and to ensure that the processing of the previous steps were providing results that were meaningful.

Figure \ref{fig:bishycar_map} shows the individual LSOA scores for households that have single vehicle access and evidence that no individual scores were above 10.

```{r bishycar_map, fig.cap="Map showing individual lsoas vehicle access scores for the test store area", warning=FALSE}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")
ggplot(lsoa_clip) +
  geom_sf(aes(fill = carrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Access to a\nsingle vehicle", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  
  # # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", which_north = "true", 
  #                        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void()
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ydedscr_map} shows the individual LSOA scores for individuals that have been educated to degree level or above and shows that no individual scores were above 10.

```{r ydedscr_map, warning=FALSE, fig.cap="Map showing individual LSOA scores for the dedscr variable which relates to percentage of population that is degree educated and above."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = dedrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Degree Educated", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void()
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:yoccscr_map} shows the individual LSOA scores for individuals with the occupation types of managers, directors, senior officials, and professional occupations and also shows that no individual scores were above 10.

```{r yoccscr_map, warning=FALSE, fig.cap="Map showing individual LSOA scores for the occscr variable which relates to the populations with the highest occupation types."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = occrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Highest occupation\ntypes", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void()
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ypplscr_map} shows the individual LSOA scores for households that consist of two people with no children, and again shows that no individual scores were above 10.

```{r ypplscr_map, warning=FALSE, fig.cap="Map showing individual LSOA scores for the pplscr variable which relates to percentage of households that contain 2 people with no children."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = pplrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households with 2\npeople & 0 children", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void()
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ytenscr_map} shows the individual LSOA scores for households that either own their homes outright, or have purchased under a mortgage or loan, and also, again, shows that no individual scores were above 10.

```{r ytenscr_map, warning=FALSE, fig.cap="Map showing individual LSOA scores for the tenscr variable, which relates to percentage of households that either own outright or mortgage their home."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = tenrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households\nthat own or\nmortgage their home", reverse = TRUE, ncol = 2)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void()
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ytotscr_map} shows the total scores for each individual LSOA and shows that these totals do not sum to a value above 50.

```{r ytotscr_map, warning=FALSE, fig.cap="Map showing the total score for the 5 variables for each individual LSOA."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")
ggplot(lsoa_clip) +
  geom_sf(aes(fill = lsoatotscr)) +
  scale_fill_viridis_c(breaks=seq(0,50,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Total score\nfor 5 variables", reverse = TRUE, ncol = 2)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void()
remove(lsoa_clip, bishy)
```

Once the individual variables scores for the test store had each been checked for validity, a final total mean score for the area as a whole was calculated by, for each variable, summing the total scores and dividing this by the number of LSOA in the area. Mean scores for each of the five variables was also calculated for future reference. This method was used to maintain equivalence across the subsequent store and retail catchment areas, and allow comparison between the scorecard results of each. This method was followed because some stores may have greater or fewer LSOA within the catchment area, rendering them isolated in terms of data without comparison.

```{r}
# Create a new variable to hold the totals for the final joined data and convert to a data.frame # # CRS should be 3857 # lsoa_clip_tot = as.data.frame(lsoa_clip) #  # ##### create a row in the lsoa_clip_tot dataframe for the total MEAN for all lsoas in the area and the total of those totals #   lsoa_clip_tot <- lsoa_clip_tot |> #     bind_rows(summarise(lsoa_clip_tot[,9:14], across(where(is.numeric), mean), across(where(is.character), ~'Total'))) # lsoa_clip_tot = st_as_sf(lsoa_clip_tot) #  # # Join the lsoas to a single shape - USE THIS "JOINED_LSOAS" AS THE FINAL LSOA SHAPE # # gglpot() + # #   annotation_map_tile(zoomin = 0, type = "hotstyle") + # #   geom_sf(aes(geometry = lsoa_clip_tot$lsoageometry)) #  # ################################################################################### # # Test Plot # # plot(st_union(lsoa_clip_tot$lsoageometry)) # #  joined_lsoas <- st_union(lsoa_clip_tot$lsoageometry) # # THIS WORKED # ################################################################################### # # Test Plot # # ggplot(joined_lsoas) + # #     annotation_map_tile(zoomin = 0, type = "hotstyle") + # #     geom_sf() # # THIS WORKED # ##################################################################################   # # Create a temp df "FT" to hold the totals for the whole joined LSOAs for each variable #   ft <- data.frame(matrix(ncol = 6, nrow = 0)) #   lsoa_clip_tot = as.data.frame(lsoa_clip_tot) #   ft = lsoa_clip_tot[nrow(lsoa_clip_tot),9:14] #   lsoa_clip_tot = st_as_sf(lsoa_clip_tot) #  #   # sum the individual variables for the whole lsoa_clip_tot and add the result to the bottom of lsoa_clip_tot #    bishy = st_as_sf(bishy) #    joined_lsoas = st_as_sf(joined_lsoas) #    joined_lsoas <- st_transform(joined_lsoas, crs = st_crs(3857)) # ################################################################################### # # Test Plot Bishy #  # ggplot(bishy) + #  #    annotation_map_tile(zoomin = 0, type = "hotstyle") + #  #    geom_sf(aes(geometry = joined_lsoas$x)) + #  #    geom_sf(aes(geometry = bishy$store_location)) # # THIS WORKED # ################################################################################## #  joined_lsoas = st_as_sf(joined_lsoas) #  bishyjoined = cbind(bishy, round(ft[,1:6], digits = 0)) #  bishyjoined = cbind(bishyjoined, joined_lsoas) #  bishyjoined <- bishyjoined  |>  rename_at('x', ~'joined_lsoas') #    # ################################################################################## # # Test plot #   bishyjoined = st_as_sf(bishyjoined) #   bishyjoined <- st_transform(bishyjoined, crs = st_crs(3857)) # ################################################################################### #  # ggplot(bishyjoined) + #  #    annotation_map_tile(zoomin = 0, type = "hotstyle") + #  #    geom_sf(aes(geometry = bishyisochrone, alpha = ""), colour = "blue") + #  #    guides(alpha = guide_legend(title = "20 minute walk time")) + #  #    geom_sf(aes(geometry = joinedlsoageometry, fill = lsoatotscr), alpha = 0.2) + #  #    guides(fill = guide_legend(title = "Joined LSOA\nTotal Score")) + #  #    geom_sf(aes(geometry = bishystorepoint,  colour = "")) + #  #    guides(colour = guide_legend(title = bishyjoined$st_nam)) # # THIS WORKED # ################################################################################## # saveRDS(obj = bishyjoined, file = "bishyjoined.rds") ################################################################################## bishyjoined <- readRDS("bishyjoined.rds")
```

#### Processing all stores

Once the test store data had been processed and mapped to ensure validity, the data for all 140 zero waste stores, including the test store, were processed in full using the same processing steps as the test store, and the results were combined with the location data in the zero waste store data for analysis.

Firstly, as with the test store, isochrones were calculated, PWC were found, and LSOA data was filtered accordingly.

```{r zws_iso_loop}
# Load the results file from the code below
# zwsiso <- readRDS("zwsiso.rds")

# remove(i, zws, zwsiso)
# 
# zws <- readRDS("zws.rds")
# # Loops throughthe zws file and creates a new dataframe (zwsiso) that holds the zws store data and the isochrone for the walktime20 mins boundary.
# 
# #############################################################################
# #                                                                           #
# #          Commented out to stop it running                                 #
# #                                                                           #
# #############################################################################
# # create a dataframe to hold the iso results
# zwsiso <- data.frame(matrix(ncol = 12, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(zws)) {
#   # create a df variable to hold the zws values from row i of zws
#  isodf = zws[i,]
#   # embed data in the output file rather than html streaming option
#  mapviewOptions(fgb = FALSE)
#   
#   # Get the coordinates of the store in the (df)
#  coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   
#   # if there are no coordinates - skip to the next zws record
#    if(is.na(coordinates$lon)) {
#      cat(i, "No Coordinates\r")
#    next
#  }
#   
#   # Calculate a 20 minute walking time isochrone around the store
#  walktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                               output = "sf", profile = ors_profile("walking"))
#  values <- levels(factor(walktime20$value))
#  ranges <- split(walktime20, values)
#  ranges <- ranges[rev(values)]
#  names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
# #################################################################################### TEST PLOT THE ISOCHRONE
#  # ggplot(walktime20) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = geometry), alpha = 0.1) +
#  #   geom_sf(data = isodf, aes(geometry = geometry))
# # THIS WORKED 
# ###################################################################################
#   # Convert the walktime20 isochrone to the correct CRS
#   # USE THIS AS THE ISOCHRONE
#   # rename the walktime20 geometry column
#  walktime20 <- walktime20  |>  rename_at('geometry', ~'isogeometry')
# 
#   # Join the calculated walktime 20 data to the zws data in isodf
#  zwsisoc <- cbind(isodf, walktime20)
#  # rename the geometry column
#  zwsisoc <- zwsisoc  |>  rename_at('geometry', ~'zwsgeometry')
#  zwsiso = zwsiso <- rbind(zwsiso, zwsisoc)
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
# # ggplot(zwsiso) +
# #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #    geom_sf(aes(geometry = zwsgeometry)) +
# #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# ###################################################################################   # print i as a count of rows that have completed
#  cat(i, "completed\r")
#   
# # remove the temporary environments
#  remove(coordinates, isodf, ranges, values, walktime20, zwsisoc)
#  Sys.sleep(3)
# }
# # Save the zwsiso file
# saveRDS(obj = zwsiso, file = "zwsiso.rds")
# 
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
#  # ggplot(zwsiso[97,]) +
#  #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #    geom_sf(aes(geometry = zwsgeometry)) +
#  #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# #################################################################################
# remove(coordinates, i, isodf, zws)
```

```{r zws_scr_loop}
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

# # Loop through each store to find the pwcs in zwsiso$walktimegeometry
# # Find all the LSOAs related to those PWCs
# # Get the scores for each LSOA
# # Add the scores and the joined LSOA geometry to the [i] row for that store
# 
# # Load the data required
# lsoa_pwc <- readRDS("lsoa_pwc.rds")
# 
# lsoas <- readRDS("lsoas.rds")
# # convert to sf
# 
# lsoas = st_as_sf(lsoas)
# zwsiso <- readRDS("zwsiso.rds")
# 
# # Create a dataframe to hold all the joined results
# zws_joined_lsoa_scr <- data.frame(matrix(ncol = 16, nrow = 0))
# 
# #initialise i
# i = 0
# i = i + 1
# for (i in 1:nrow(zwsiso)) {
# 
# a = zwsiso[i,]
#   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
# # get all the pwcs that appear in the iso for that store
# a <- a  |>  rename_at('isogeometry', ~'geometry')
# a = st_transform(a$geometry, crs = st_crs(3857)) 
# 
# # st_geometry(b) <- "geometry"
# b = lsoa_pwc[a,]
#   
#   # Check if (a) has 0 rows. If so, sack it off and move to the next record
#  if(nrow(b) == 0) {
#    next
#  }
#   
#   # Convert a to a dataframe to manipulate it
#   b = as.data.frame(b)
#   
#   # Get all the lsoas that relate to the pwcs just found
#   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
#   
#   #convert b to a dataframe
#   c = as.data.frame(c)
#   
# ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
#   c <- c |>
#    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
#                        across(where(is.character), ~'Total')))
#   
#   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# 
#   # convert b to sf format
#   c = st_as_sf(c)
#   
# ###################################################################################
# # TEST PLOT
# # ggplot(c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# #THIS WORKED
# ################################################################################### 
#   # Join the lsoas together
#  joined_lsoas <- st_union(c$lsoageometry)
#   
# ###################################################################################
# # TEST PLOT
#  # ggplot(joined_lsoas) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   ## Create a new dataframe for the joined data
#   joined_lsoas = st_as_sf(joined_lsoas)
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
#   
#   # combine the joined lsoa data and the score data
#   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
#   #remove the empty multipolyon column
#   joined_lsoas_c = joined_lsoas_c |> select(-one_of('lsoageometry'))
#   # rename the x column to "joinedlsoageom"
#   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas_c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   # retrieve the store name from zwsiso
#   d = zwsiso[i,]
# 
#    # Join the store name and the scores and the joined LSOA geometry and the walktime geometry
#  e = cbind(d, joined_lsoas_c)
# ###################################################################################
# # TEST PLOT
# # ggplot(e) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################  
#   # add this to a row in a new dataframe
#   zws_joined_lsoa_scr <- rbind(zws_joined_lsoa_scr, e)
# 
#   # remove the temporary dataframes sf files etc 
#  remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# 
# ###################################################################################
# # TEST PLOT
# #ggplot(zws_joined_lsoa_scr) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################
#   # Print (i) as a counter
#   cat(i, "completed\r")
# }
# # clean the zws_joined_lsoa_scr names and columns
# # Round the scores to the nearest whole number
# zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# 
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(zws_joined_lsoa_scr[93,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom, alpha = lsoatotscr))
# # THIS WORKED
# ###################################################################################
# # 
# # st_geometry(zws_joined_lsoa_scr) <- "isogeometry"
# # zws_joined_lsoa_scr
# # 
# # 
# # remove(a, zwsiso)
# # Save the zws_joined_lsoa_scr data
# #remove the errors
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr[-c(82), ]
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
```

Of the original 145 stores, 129 were successfully processed. Those that were not, either did not produce isochrone calculations, with PWCs situated inside them, or did not have valid coordinate geometry data, as they were stores that closed prior to the study.

The results for the remaining 129 stores were analysed to calculate the mean scores of the 5 variables. The total mean score was then calculated to give the final scorecard result. These scorecards were then used to analyse the locations that currently contain a store, and to identify the most suitable potential retail centre that was not already supplied by a zero waste store.

```{r zw_scrs_hists}
# nrow(zws_joined_lsoa_scr)
# individual variable scores for the retail centres that score a total that matches the mean store total score
# zwh1 <- ggplot(zws_joined_lsoa_scr, aes(x=lsoatotscr)) + 
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey")
# 
# zwh2 <- ggplot(zws_joined_lsoa_scr, aes(x=tenrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zwh3 <- ggplot(zws_joined_lsoa_scr, aes(x=pplrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zwh4 <- ggplot(zws_joined_lsoa_scr, aes(x=occrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zwh5 <- ggplot(zws_joined_lsoa_scr, aes(x=dedrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zwh6 <- ggplot(zws_joined_lsoa_scr, aes(x=carrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# # Add the histograpms to a plot list
# zwh_plot_list <- list(zwh1, zwh2, zwh3, zwh4, zwh5, zwh6)
# saveRDS(object = zwh_plot_list, file = "zwh_plot_list.rds")
# Plot them together in a grid
zwh_plot_list <- readRDS("zwh_plot_list.rds")
do.call("grid.arrange", c(zwh_plot_list, ncol = 3))
remove(zwh_plot_list)
```

OR WOULD THIS BE THE HIGHEST SCORES THAT SHOULD BE USED?!

```{r}
# rc_final_results <- readRDS("rc_final_results.rds")
###################################################################################
# # RC ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# #### Process rc_a
# rca_results <- data.frame(matrix(ncol = 18, nrow = 0))
# 
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_a)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_a[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rca_results <- rbind(rca_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# # convert rciso to crs 4326
# #rciso <- st_transform(rciso, crs = st_crs(4326))
# # convert retail_c to crs 3857
# #rciso <- st_transform(rciso, crs = st_crs(3857))
# 
# 
# # Change the name of the centre column to make it identifiable
# # rca_results <- rca_results  |>  rename_at('center', ~'rcisocenter')
# 
# # remove the temporary dataframes
# remove(i)
# # save the rc_results and the rc_(x) files as RDS files
# saveRDS(obj = rc_a, file = "rc_a.rds")
# saveRDS(obj = rca_results, file = "rca_results.rds")
# remove(i)
# ###################################################################################
# # PROCESS THE RC_B FILE
# ###################################################################################
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_b)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_b[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_b, file = "rc_b.rds")
# saveRDS(obj = rcb_results, file = "rcb_results.rds")
# remove(i)
# 
# ###################################################################################
# ###################################################################################
# # PROCESS THE RC_C FILE
# ###################################################################################
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_c)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_c[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_c, file = "rc_c.rds")
# saveRDS(obj = rcc_results, file = "rcc_results.rds")
# remove(i)
# ###################################################################################
# ###################################################################################
# ###################################################################################
# # Convert all the geometries to work properly
# # load rca_results
# rca_results <- readRDS("rca_results.rds")
# a = as.data.frame(rca_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # Save a to rc_final_results
# rc_final_results <- a
# 
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcb_results <- readRDS("rcb_results.rds")
# a = as.data.frame(rcb_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[2,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # add the data to the final dataframe
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcc_results <- readRDS("rcc_results.rds")
# a = as.data.frame(rcc_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,21)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,26)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# 
# 
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'fid.1', 'RC_ID.1', 'RC_Name.1', 'Classifica.1', 'Country.1', 'Region_NM.1', 'H3_count.1', 'Retail_N.1', 'Area_km2.1', 'value', 'isodf.RC_ID'))
# # make sure the columns in a are in the same order as rc_final_results
# a <- a |> relocate(group_index, .before = rcgeometry)
# a <- st_as_sf(a)
# ###################################################################################
# # Fix the CRS of a
# # Try to fix zws_joined_lsoa_scr.rds geometries
# b = a[,c(1,10)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ###################################################################################
# # remove(rc_final_results)
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# b = rc_final_results[,c(13)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# rc_final_results$rcwalktime = b$rcwalktime
# 
# b = rc_final_results[,c(12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rccentroidgeom = b$rccentroidgeom
# 
# b = rc_final_results[,c(11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rcgeometry = b$rcgeometry
# 
# 
# ##################################################################################
# # TEST PLOT rc_final_results
# # ggplot(rc_final_results[2,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "blue")
# # THIS WORKED
# saveRDS(obj = rc_final_results, file = "rc_final_results.rds")
# ###################################################################################
# ###################################################################################
# # Remove unwanted dataframes and sf files
# remove(a, b, c, rc_a, rc_b, rc_c, rc_results, rca_results, rcb_results, rcc_results)
# ###################################################################################
```

```{r rc_with_zws_prep}
# # Load the data required
# 
#  # Load Retail Centres data
 # rc_results <- readRDS("rc_results.rds")
#  # create a dataframe to hold the RCID and geometry for the isochrone
#  rc = select(rc_results, 2, 10)
#  # remove rc_results
#  # remove(rc_results)
#  # Convert rc to a sf format
#  rc = st_as_sf(rc)
# 
# # Load Lsoa data
# lsoas <- readRDS("lsoas.rds")
# lsoas = st_as_sf(lsoas)
# 
# # Load Population Weighted Centroid data and zws results
# lsoa_pwc <- readRDS("lsoa_pwc.rds")
# lsoa_pwc
# 
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# 
# # Find the retail centres that do not contain a store already
# # RCs WITH zws
# rc_with_zws = rc[zws_joined_lsoa_scr$zwsgeometry,]
# 
# # RCs WITHOUT zws##################################################################
# rc_no_zws = rc[!(rc$RC_ID  %in% rc_with_zws$RC_ID),]
# saveRDS(obj = rc_no_zws, file = "rc_no_zws.rds")
```

```{r eval = F}
# ################# Prepare the retail centres data without a zws in them
# # PREPARE THE RETAIL CENTRE DATA
# # Get all the data for the retail centres
# rc_no_zws = rc_no_zws |> select(-3)
# rc_results = as.data.frame(rc_results)
# rc_no_zws = as.data.frame(rc_no_zws)
# rc_no_zws = inner_join(rc_no_zws, rc_results, by="RC_ID")
# 
# ## Remove retail centres from retail_c that are not required
# ### Remove retail centres that are not in England and Wales from retail_c
# rc_no_zws <- rc_no_zws[grep(c("Wales|England"), rc_no_zws$Country),]
# 
# # Clean the columns up
# rc_no_zws = rc_no_zws |> select(-one_of('rcgeometry.x'))
# rc_no_zws <- rc_no_zws  |>  rename_at('rcgeometry.y', ~'rcgeometry')
# 
# # Remove retail centres that are too large
# # Those zwstores that are located within a retail centre are mainly in :-
# # Town Centre
# # Small Local Centre
# # Local Centre
# # Market Town
# rc_no_zws <- rc_no_zws[grep(c("Town Centre|Small Local Centre|Local Centre|Market Town"), rc_no_zws$Classifica),]
# 
# 
# # Split he retail_c file in to chunks so that they can be processed and then re-combined
# 
# # Create the 2 temporary dataframes
# rc_1 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_2 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_3 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_4 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_5 <- data.frame(matrix(ncol = 20, nrow = 0))
# 
# # Move the relevant rows to the 5 new dataframes
# rc_1 <- rc_no_zws[rc_no_zws$Classifica == "Local Centre",]
# rc_2 <- rc_no_zws[rc_no_zws$Classifica == "Major Town Centre",]
# rc_3 <- rc_no_zws[rc_no_zws$Classifica == "Market Town",]
# rc_4 <- rc_no_zws[rc_no_zws$Classifica == "Small Local Centre",]
# rc_5 <- rc_no_zws[rc_no_zws$Classifica == "Town Centre",]
# 
# rc_a <- rbind(rc_1, rc_3)
# rc_b <- rbind(rc_2, rc_4, rc_5)
# 
# # remove the 5 temporary variables
# remove(rc_1, rc_2, rc_3, rc_4, rc_5)
# #remove(rc_a, rc_b)
# 
# # Split the rc_b file in to 2 leaving rc_b and rc_c
# rc_c <- tail(rc_b, -2500)
# rc_b = rc_b[!(rc_b$RC_ID %in% rc_c$RC_ID),]
# 
# ###################################################################################
# # with prep done, remove unrequired dataframes etc
# remove(rc, rc_with_zws)
```

```{r eval = F}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
##################################################################################

#          Calclate the isochrones around the retail centres without zws
                                    
##################################################################################
# remove(i, rc_joined_lsoa_scr)
# # Load the data required
# #lsoa_pwc <- readRDS("lsoa_pwc.rds")
# #lsoas <- readRDS("lsoas.rds")
# # convert to sf
# #lsoa_pwc = st_as_sf(lsoa_pwc)
# #lsoas = st_as_sf(lsoas)
# 
# # # Find all the PWCs that appear in any of the rc_isochrones
# #pwc_in_rciso = lsoa_pwc[rc_final_results$rcwalktime,]
# #
# ## # find all the pwc_in_rciso related LSOAs
# #lsoa_in_rciso = lsoas[(lsoas$LSOA21CD  %in% pwc_in_rciso$LSOA21CD),]
# 
# # Create a dataframe to hold all the joined results
# rc_joined_lsoa_scr <- data.frame(matrix(ncol = 19, nrow = 0))
# 
# #initialise i
# i = 0
# i = i + 1
# for (i in 1:nrow(rc_iso_results)) {
# 
#   a = rc_iso_results[i,]
#   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a$rcgeometry), alpha = 0.1, colour = "blue") +
# #   geom_sf(aes(geometry = a$rcwalktime), alpha = 0.1, colour = "red")
# #THIS WORKED
# ###################################################################################
# 
# # get all the pwcs that appear in the iso for that store
# # a <- a  |>  rename_at('isogeometry', ~'geometry')
# # a = st_transform(a$geometry, crs = st_crs(3857)) 
# 
# # st_geometry(b) <- "geometry"
# b = lsoa_pwc[a$rcwalktime,]
#   
#   # Check if (a) has 0 rows. If so, sack it off and move to the next record
#  if(nrow(b) == 0) {
#    cat(i, "..errored\r")
#    next
#  }
#   
#   # Convert a to a dataframe to manipulate it
#   b = as.data.frame(b)
#   
#   # Get all the lsoas that relate to the pwcs just found
#   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
#   
#   #convert b to a dataframe
#   c = as.data.frame(c)
#   
# ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
#   c <- c |>
#    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
#                        across(where(is.character), ~'Total')))
#   
#   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# 
#   # convert c to sf format
#   c = st_as_sf(c)
#   
# ###################################################################################
# # TEST PLOT
# # ggplot(c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# #THIS WORKED
# ################################################################################### 
#   # Join the lsoas together
#   joined_lsoas <- st_union(c$lsoageometry)
#   
# ###################################################################################
# # TEST PLOT
#  # ggplot(joined_lsoas) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1, colour = "black")
# #THIS WORKED
# ###################################################################################
#   # Convert joined_lsoas to sf
#   joined_lsoas = st_as_sf(joined_lsoas)
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1, colour = "blue")
# #THIS WORKED
# ###################################################################################
#   
#   # combine the joined lsoa data and the score data
#   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
#   #remove the empty multipolyon column
#   joined_lsoas_c = joined_lsoas_c |> select(-one_of('lsoageometry'))
#   # rename the x column to "joinedlsoageom"
#   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# 
# ###################################################################################
# # TEST PLOT
#   # ggplot(joined_lsoas_c) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1, colou = "red")
# #THIS WORKED
# ###################################################################################
# 
#   # retrieve the retail center ID from rc_final_results
#   d = rc_iso_results[i,]
# 
#   # Join the retail center data, the scores, the joined LSOA geometry and the walktime geometry
#   e = cbind(d, joined_lsoas_c)
# ###################################################################################
# # TEST PLOT
# # ggplot(e) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "green") +
# #   geom_sf(aes(geometry = rccentroidgeom), alpha = 0.1, colour = "black") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1, colour = "blue")
# # THIS WORKED
# ###################################################################################  
#   # add this to a row in a new dataframe
#   rc_joined_lsoa_scr <- rbind(rc_joined_lsoa_scr, e)
# 
#   # remove the temporary dataframes sf files etc 
#   remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# 
# 
#   # Print (i) as a counter
#   cat(i, "completed\r")
# }
# # clean the zws_joined_lsoa_scr names and columns
# # Round the scores to the nearest whole number
# # zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
# # zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)
# # zws_joined_lsoa_scr <- zws_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# # 
# # # reindex the data
# # rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# 
# 
# ###################################################################################
# # # Convert all the geometries
# # b = rc_joined_lsoa_scr[,c(1,16)]
# # b = st_as_sf(b)
# # b
# # b = st_transform(b, crs = st_crs(4326))
# # b
# # rc_joined_lsoa_scr$rcgeometry = b$rcgeometry
# # 
# # ###################################################################################
# # # TEST PLOT
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), alpha = 0.1)
# # # THIS WORKED
# # ###################################################################################
# # 
# # remove(b)
# # b = rc_joined_lsoa_scr[,c(1,17)]
# # # remove rcgeometry
# # b = as.data.frame(b)
# # b = b |> select(-one_of('rcgeometry'))
# # b = st_as_sf(b)
# # b
# # b = st_transform(b, crs = st_crs(4326))
# # b
# # rc_joined_lsoa_scr$rccentroidgeom = b$rccentroidgeom
# # 
# # remove(b)
# # b = rc_joined_lsoa_scr[,c(1,18)]
# # # remove rcgeometry
# # b = as.data.frame(b)
# # b = b |> select(-one_of('rcgeometry'))
# # b = st_as_sf(b)
# # b
# # b = st_transform(b, crs = st_crs(3857))
# # rc_joined_lsoa_scr$rcwalktime = b$rcwalktime
# # 
# # remove(b) 
# # b = rc_joined_lsoa_scr[,c(1,19)]
# # # remove rcgeometry
# # b = as.data.frame(b)
# # b = b |> select(-one_of('rcgeometry'))
# # b = st_as_sf(b)
# # b
# # b = st_transform(b, crs = st_crs(3857))
# # rc_joined_lsoa_scr$joinedlsoageom = b$joinedlsoageom
# # 
# # ###################################################################################
# # # TEST PLOT
# # rc_joined_lsoa_scr <- st_as_sf(rc_joined_lsoa_scr)
# # ggplot(rc_joined_lsoa_scr[67,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = joinedlsoageom, alpha = round(lsoatotscr, digits = 0)), colour = "red") +
# #   guides(alpha = guide_legend(title = "LSOAs total score")) +
# #   geom_sf(aes(geometry = rcgeometry, colour = ""), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime, fill = ""), colour = "blue",alpha = 0.1) +
# #   guides(fill = guide_legend(title = "Retail centre isochrone"))
# # # THIS WORKED
# # #################################################################################
# 
# # saveRDS(obj = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
```

```{r eval = F}
# # Find the mean total score for the zero waste stores
# zws_ave = round(mean(zws_joined_lsoa_scr$lsoatotscr))
# 
# # Identify the rows in the retail centre total score data that match the average total score for the stores data 
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (zws_ave) & rc_joined_lsoa_scr$lsoatotscr <= (zws_ave)
# # get the rows identified as matching the zws mean score
# rc_eq_zws_ave <- subset(rc_joined_lsoa_scr, identify_rows)
# 
# ###################################################################################
# # Plot all the retail centres 
# ggplot(rc_eq_zws_ave) +
#   annotation_map_tile(zoomin = 1, type = "hotstyle") +
#   geom_sf(aes(geometry = joinedlsoageom), colour = "red")
```

```{r all_rc_hists}
###################################################################################
# All rc_total scores
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# rc_hist1 <- ggplot(rc_joined_lsoa_scr, aes(x=lsoatotscr)) + 
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey")
# 
# rc_hist2 <- ggplot(rc_joined_lsoa_scr, aes(x=tenrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rc_hist3 <- ggplot(rc_joined_lsoa_scr, aes(x=pplrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rc_hist4 <- ggplot(rc_joined_lsoa_scr, aes(x=occrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rc_hist5 <- ggplot(rc_joined_lsoa_scr, aes(x=dedrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rc_hist6 <- ggplot(rc_joined_lsoa_scr, aes(x=carrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# plot_list_rchist <- list(rc_hist1, rc_hist2, rc_hist3, rc_hist4, rc_hist5, rc_hist6)
# saveRDS(object = plot_list_rchist, file = "plot_list_rchist.rds")

plot_list_rchist <- readRDS("plot_list_rchist.rds")
do.call("grid.arrange", c(plot_list_rchist, ncol = 3))
remove(plot_list_rchist)
```

```{r zwmeanrc_hists}
# # saveRDS(obj = rc_eq_zws_ave, file = "rc_eq_zws_ave.rds")
# rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
# #nrow(rc_eq_zws_ave)
# # individual variable scores for the retail centres that score a total that matches the mean store total score
# zrc1 <- ggplot(rc_eq_zws_ave, aes(x=lsoatotscr)) + 
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey")
# 
# zrc2 <- ggplot(rc_eq_zws_ave, aes(x=tenrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zrc3 <- ggplot(rc_eq_zws_ave, aes(x=pplrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zrc4 <- ggplot(rc_eq_zws_ave, aes(x=occrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zrc5 <- ggplot(rc_eq_zws_ave, aes(x=dedrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zrc6 <- ggplot(rc_eq_zws_ave, aes(x=carrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# # Add the histograpms to a plot list
# zrc_plot_list <- list(zrc1, zrc2, zrc3, zrc4, zrc5, zrc6)
# saveRDS(object = zrc_plot_list, file = "zrc_plot_list.rds")
# Plot them together in a grid
zrc_plot_list <- readRDS("zrc_plot_list.rds")
do.call("grid.arrange", c(zrc_plot_list, ncol = 3))
remove(zrc_plot_list)
```

```{r rc_zw_meanrange_hists}
# # saveRDS(obj = zws_ave, file = "zws_ave.rds")
# zws_ave <-  readRDS("zws_ave.rds")
# ###################################################################################
# # Using the range + or - 3
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (zws_ave-3) & rc_joined_lsoa_scr$lsoatotscr <= (zws_ave+3)
# 
# rc_in_zws_ave_rng <- subset(rc_joined_lsoa_scr, identify_rows)
# 
# rcr1 <- ggplot(rc_in_zws_ave_rng, aes(x=lsoatotscr)) + 
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcr2 <- ggplot(rc_in_zws_ave_rng, aes(x=tenrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcr3 <- ggplot(rc_in_zws_ave_rng, aes(x=pplrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcr4 <- ggplot(rc_in_zws_ave_rng, aes(x=occrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcr5 <- ggplot(rc_in_zws_ave_rng, aes(x=dedrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcr6 <- ggplot(rc_in_zws_ave_rng, aes(x=carrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcr_plot_list <- list(rcr1, rcr2, rcr3, rcr4, rcr5, rcr6)
# saveRDS(object = rcr_plot_list, file = "rcr_plot_list.rds")

rcr_plot_list <- readRDS("rcr_plot_list.rds")
do.call("grid.arrange", c(rcr_plot_list, ncol = 3))
remove(rcr_plot_list)
```

```{r rc_iqr_hists}
# ###################################################################################
# # Using the interquartile range
# # Find the 1st and 3rd Quartiles of the zws results
# a <- data.frame(unclass(summary(zws_joined_lsoa_scr$lsoatotscr)), check.names = F)
# # rotate the dataframe
# a = a |> rotate_df()
# 
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (a$`1st Qu.`) & rc_joined_lsoa_scr$lsoatotscr <= (a$`3rd Qu.`)
# 
# rc_in_zws_iqr <- subset(rc_joined_lsoa_scr, identify_rows)
# 
# rcq1 <- ggplot(rc_in_zws_iqr, aes(x=lsoatotscr)) + 
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcq2 <- ggplot(rc_in_zws_iqr, aes(x=tenrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcq3 <- ggplot(rc_in_zws_iqr, aes(x=pplrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcq4 <- ggplot(rc_in_zws_iqr, aes(x=occrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcq5 <- ggplot(rc_in_zws_iqr, aes(x=dedrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcq6 <- ggplot(rc_in_zws_iqr, aes(x=carrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# plot_list_iqr <- list(rcq1, rcq2, rcq3, rcq4, rcq5, rcq6)
# saveRDS(object = plot_list_iqr, file = "plot_list_iqr.rds")
plot_list_iqr <- readRDS("plot_list_iqr.rds")
do.call("grid.arrange", c(plot_list_iqr, ncol = 3))
remove(plot_list_iqr)
```

```{r rc_minmax_hists}
# ###################################################################################
# # Using the range min-max
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (min(zws_joined_lsoa_scr$lsoatotscr)) & rc_joined_lsoa_scr$lsoatotscr <= (max(zws_joined_lsoa_scr$lsoatotscr))
# 
# rc_in_zws_mm <- subset(rc_joined_lsoa_scr, identify_rows)
# 
# rcm1 <- ggplot(rc_in_zws_mm, aes(x=lsoatotscr)) + 
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcm2 <- ggplot(rc_in_zws_mm, aes(x=tenrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcm3 <- ggplot(rc_in_zws_mm, aes(x=pplrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcm4 <- ggplot(rc_in_zws_mm, aes(x=occrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcm5 <- ggplot(rc_in_zws_mm, aes(x=dedrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# rcm6 <- ggplot(rc_in_zws_mm, aes(x=carrank)) + 
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# plot_list_minmax <- list(rcm1, rcm2, rcm3, rcm4, rcm5, rcm6)
# saveRDS(object = plot_list_minmax, file = "plot_list_minmax.rds")
plot_list_minmax <- readRDS("plot_list_minmax.rds")
do.call("grid.arrange", c(plot_list_minmax, ncol = 3))
remove(plot_list_minmax)
```

\newpage

## Results

This section will analyse the results of the initial scorecard calculations for the locations containing zero waste stores. It will discuss the demographic composition of the 20 minute walking time catchment areas around the stores, and how the resulting scores may help to understand what makes these locations most suitable for this sector of retail.

### Zero Waste Scorecard

Once the scorecards for the 129 stores had been calculated, a summary was produced. All scores were calculated as means, based on the number of LSOAs that appeared within the isochrone catchment area for each location. For example, the first record in table \ref{tab:allzwsscrtable} shows that the mean for each variable (carrank, dedrank, occrank, pplrank, and tenrank) were 6, 3, 4, 5 and 7 respectively, while the lsoatotalscr mean was 26. By calculating the results in this way, it provided comparability across all stores for both the individual variables and the total score.

```{r all_zws_scr_table}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
a = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[1:10, c(2, 12:17)]))
kable(a, caption = "\\label{tab:allzwsscrtable}Scorecard table for first 10 zero waste stores")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 12) |>
  column_spec(1,width = "0.5in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.5in") |>
  column_spec(4,width = "0.5in") |>
  column_spec(5,width = "0.5in") |>
  column_spec(6,width = "0.5in") |>
  column_spec(7,width = "0.5in")

remove(a, zws_joined_lsoa_scr)
```

Table \ref{tab:zws_scrsummary} shows that across all 129 stores, the total scores (*lsoatotscr*) ranged from 15 through to 32, a mean of 24 and an interquartile range of between 22 to 27 was observed. This showed that all store scores fell within a centrally distributed range with no area scoring a particularly low or high score.

```{r}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
a  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$lsoatotscr)))
a = as.data.frame(a)
a = rbind(nrow(zws_joined_lsoa_scr), a)
a <- a  |>  rename_at('a', ~'ZWS total score summary value')
a = as.data.frame(t(a))
a <- a  |>  rename_at('1', ~'Total no. stores')
a = as.data.frame(t(a))

kable(t(a), caption = "\\label{tab:zws_scores_summary}Scorecard summary table for all zero waste stores.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 12)

remove(zws_joined_lsoa_scr, a)
```

Figure \ref{fig:corr_plot} shows the correlation between the individual variables and the total scores. This visualises the positive relationship between them and the total score (*lsoatotscr*) to varying strengths. For example, the degree educated (*dedrank*), occupation (*occrank*) and home-ownership (occrank) variables all have a more positive linear relationship with the total score, than the vehicle access (*carrank*) and household composition (pplrank) variables. Those variables that seemed to display a more negative relationship were between the *pplrank* and *dedrank* which may suggest areas that contain older couples than younger single households. Areas that have more interesting relationships were highlighted by the relationship between the *tenrank* and, *dedrank* and *occrank* variables. This relationship suggests that areas with higher *dedrank* and *occrank* scores and low *tenrank* scores were areas with younger professional populations that have a degree education level, but have not managed to get on the housing ladder for example.

```{r corr_plot, fig.cap="Plot showing correlations between total scores and the 5 variables"}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
a_cor = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[,c(17,12:16)]))
cor_plot <- plot(a_cor, cex = 0.3,
     col = grey(0.145,alpha=0.5), upper.panel=panel.smooth)
remove(a_cor, zws_joined_lsoa_scr, cor_plot)
```

To be able to see clearly, how the zero waste store data scores were distributed, they were plotted as histograms. As figure \fig{fig:zws_scores_hist} shows, the *lsoatotscr* (total scores) were distributed normally between around 15 and 30.

The smallest variation in the range of scores was seen in the *pplrank* variable, which ranged from 2 to 6, with a mean of 4. The largest variation between the ranges of scores was seen in the *tenrank* variable (*home-ownership*). This varied from 1 through to 9, with a mean of 5.9.

are fairly even, with a slight positive skew. This is showing that there were significant numbers of stores that scored less than and more than 80, but scores were concentrated around a similar score throughout. On an individual variable level for each area, around half of the households had access to a single car.

```{r, zws_scores_hist, fig.cap="Histogram plots showing distributions of all variables and total scores."}
###################################################################################
# All Zero Waste Store scores histograms
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# zw_hist1 <- ggplot(zws_joined_lsoa_scr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey")
# 
# zw_hist2 <- ggplot(zws_joined_lsoa_scr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zw_hist3 <- ggplot(zws_joined_lsoa_scr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zw_hist4 <- ggplot(zws_joined_lsoa_scr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zw_hist5 <- ggplot(zws_joined_lsoa_scr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# zw_hist6 <- ggplot(zws_joined_lsoa_scr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")
# 
# # Save the plotlist as a single item
# plot_list_zwshist <- list(zw_hist1, zw_hist2, zw_hist3, zw_hist4, zw_hist5, zw_hist6)
# remove(zw_hist1, zw_hist2, zw_hist3, zw_hist4, zw_hist5, zw_hist6)
# # Save the plot list
# saveRDS(object = plot_list_zwshist, file = "plot_list_zwshist.rds")
plot_list_zwshist <- readRDS("plot_list_zwshist.rds")
# Plot the group of histograms as one single plot image
do.call("grid.arrange", c(plot_list_zwshist, ncol = 3))
# remove the plot image
remove(plot_list_zwshist)
```

The distribution of the scores for education level (*dedscr).* were again, slightly positively skewed, showing that the majority of locations scored below 5. However, the distribution does indicate that there were locations that fairly high. This distribution indicates that the number of degree educated residents is a somewhat important factor.

The variable for the households comprised two people without children (*pplscr*) was very evenly distributed around a score of 4. Very few locations were made up of households with particularly low or high scores for this variable. This suggests that this variable is not as important as the literature (CITE) may imply.

A more varied distribution than the other variables was seen for home-ownership (*occscr)*. Here a negative skew can be seen, with the majority of locations scoring between 4 and 7. This does suggest a degree of wealth, and the importance of wealth in the location of the stores.

```{r}
###################################################################################
# TEST PLOT
#i= 0
#i=i+1
#ggplot(zws_joined_lsoa_scr[i,]) +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = zwsgeometry)) +
#  geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
#  geom_sf(aes(geometry = joinedlsoageom, alpha = lsoatotscr))
# THIS WORKED
#
#
###################################################################################
```

FIX THIS

Figure fig:min_store_map shows the store that scored the lowest of the 129, with a score of ??. As can be seen in the breakdown of the individual variables average scores, this area scored very low on all factors. This would at first glance suggest that it is not in the best location, however, the area it serves is highly residential

```{r}
# minstore = zws_joined_lsoa_scr[which.min(zws_joined_lsoa_scr$lsoatotscr), ]
# saveRDS(object = minstore, file = "minstore.rds")
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
minstore <- readRDS("minstore.rds")
kable(st_drop_geometry(zws_joined_lsoa_scr[1:5,c(2,3,12:17)]), caption = "\\label{tab:zws_scrsummary}Summary table for 5 zero waste store scores")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 10)|>
  column_spec(1,width = "0.8in", bold = T) |>
  column_spec(2,width = "0.8in") |>
  column_spec(3,width = "0.8in") |>
  column_spec(4,width = "0.8in") |>
  column_spec(5,width = "0.8in") |>
  column_spec(6,width = "0.8in")
remove(zws_joined_lsoa_scr, minstore)
```

CHANGE TO A TABLE The area that scored the highest overall can be seen in figure \ref{fig:maxstr_map}.

```{r}
# maxstore = zws_joined_lsoa_scr[which.max(zws_joined_lsoa_scr$lsoatotscr), ]
# saveRDS(object = maxstore, file = "maxstore.rds")
# maxstore <- readRDS("maxstore.rds")
```

```{r maxstr_map, fig.cap = "Map showing the store with the highest value scorecard, and the variable averages for the location.", warning=FALSE}
maxstore <- readRDS("maxstore.rds")
maxstoremap <- 
  ggplot(maxstore) +
  annotation_map_tile(zoomin = -1, type = "osm") +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "red") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = maxstore$joinedlsoageom, fill = maxstore$lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = "")) +
  guides(colour = guide_legend(title = str_wrap(maxstore$st_nam, width = 15), reverse = TRUE)) +
  # North arrow and scale bar
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tr", 
                         which_north = "true", 
                         pad_x = unit(0.1, "in"), 
                         pad_y = unit(0.1, "in"),
                         style = north_arrow_minimal) +
  theme_void()

maxvarhead <- 
  ggplot(maxstore) + 
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

maxcarscr <-
  ggplot(maxstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

maxdedscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

maxoccscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxpplscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxtenscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void()

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = maxstoremap,
           B = maxvarhead,
           C = maxcarscr,
           D = maxdedscr,
           E = maxoccscr,
           F = maxpplscr,
           G = maxtenscr,
           design = layout)
remove(maxstore)
```

This could highlight that the people score variable is less significant than it had first seemed. Given that the distribution was very narrow and the areas with the overall lowest and highest scores, for this variable scored 2 and 4 respectively.

```{r minstr_map, fig.cap="Map showing the store with the lowest value scorecard, and the variable averages for the location.", warning=FALSE}

minstore <- readRDS("minstore.rds")
minstoremap <- ggplot(minstore) +
  annotation_map_tile(zoomin = 0, type = "osm") +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "blue") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = joinedlsoageom, fill = lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = "")) +
  guides(colour = guide_legend(title = str_wrap(minstore$st_nam, width = 15), reverse = TRUE)) +
  # North arrow and scale bar
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tr", 
                         which_north = "true", 
                         pad_x = unit(0.1, "in"), 
                         pad_y = unit(0.1, "in"),
                         style = north_arrow_minimal) +
  theme_void()

minvarhead <- 
  ggplot(minstore) + 
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

mincarscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

mindedscr <- 
  ggplot(minstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

minoccscr <- 
  ggplot(minstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

minpplscr <- 
  ggplot(minstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

mintenscr <- 
  ggplot(minstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void()

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = minstoremap,
           B = minvarhead,
           C = mincarscr,
           D = mindedscr,
           E = minoccscr,
           F = minpplscr,
           G = mintenscr,
           design = layout)
remove(minstore)
```

```{r}
############### Try to fix zws_joined_lsoa_scr.rds geometries #####################
###################################################################################
# # Load zwsiso
# zwsdata <- readRDS("zws_joined_lsoa_scr.rds")
# a = as.data.frame(zwsdata)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$joinedlsoageom <- b$joinedlsoageom
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$isogeometry <- b$isogeometry
# 
# b = a[,c(1,18)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$zwsgeometry <- b$zwsgeometry
# 
# ###################################################################################
# # # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1) +
# #   geom_sf(aes(geometry = zwsgeometry))
# # 
# ###################################################################################
# # # FINAL TEST
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # #################################################################################
# zwsdata = a
# zwsdata = st_as_sf(zwsdata)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr = zwsdata
# zws_joined_lsoa_scr$zwsgeometry
# zws_joined_lsoa_scr$isogeometry
# zws_joined_lsoa_scr$joinedlsoageom
# 
# ###################################################################################
# # TEST PLOT
# ggplot(zws_joined_lsoa_scr[93,]) +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   geom_sf(aes(geometry = zwsgeometry)) +
#   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
#   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
```

```{r}
# # reindex he rc_joined_lsoa_scr data
# rownames(rc_joined_lsoa_scr) <- 1:nrow(rc_joined_lsoa_scr)
# ###################################################################################
# # TEST PLOT
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # i = 0
# # i = i + 1
# # a = rc_joined_lsoa_scr[i,]
# # a
# # st_geometry(a) <- "rcwalktime"
# # a
# # st_geometry(a) <- "joinedlsoageom"
# # a
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "black") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "brown", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "blue") +
# #   geom_sf(aes(geometry = joinedlsoageom, fill = lsoatotscr), alpha = 0.1, colour = "red")
# # THIS WORKED
# ###################################################################################
```

## Discussion

WRITE THE DISCUSSION HERE

do some writing

## Conclusions

WRITE THE CONCLUSIONS HERE

# Bibliography

::: {#refs}
\noindent \vspace{-2em} \setlength{\parindent}{-0.5in} \setlength{\leftskip}{0.5in} \setlength{\parskip}{15pt}
:::
