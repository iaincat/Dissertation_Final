---
geometry: left=1.2cm,right=1.2cm,top=1.5cm,bottom=1.5cm
output:
  pdf_document:
    latex_engine: xelatex
    fig_caption: yes
header-includes:
- \usepackage{setspace}
- \usepackage{lastpage}
- \usepackage{fontspec}
- \usepackage{placeins}
- \usepackage{fancyhdr}
- \usepackage{biblatex}
- \setlength\bibitemsep{1.5\itemsep}
- \setmainfont{Calibri}
- \onehalfspacing
csl: "C:/Users/James/OneDrive/Documents/R/win-library/4.1/markdown/csl/UoL_Harvard.csl"
bibliography: references.bib
---

```{=tex}
\fancyhf{}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\rfoot{\thepage\ of \pageref{LastPage}}
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	error = FALSE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE,
	comment = "",
	tidy = FALSE
)
cache.val = T

# Load / Install packages-------------------------------------------------------
#install.packages("", dependecies = TRUE)
library(knitr)
library(sf)
library(kableExtra)
library(ggplot2)
library(basemaps)
library(mapview)
library(openrouteservice)
library(ggspatial)
library(stringr)
library(patchwork)
library(dplyr)
library(rgdal)
library(viridis)
library(corrplot)
library(tidyr)
library(tidyverse)
library(sp)
library(maptools)
library(rgeos)
library(readxl)
library(gridExtra)
library(psych)
library(reshape2)
library(sjmisc)
library(spatstat)
library(raster)
library(ggthemes)
library(RColorBrewer)
library(ggrepel)

#API Key info - should only need loading once -  500
# ors_api_key("5b3ce3597851110001cf62480f8858be0885487ca2a78900b689815b")

# Extra 500
# ors_api_key("5b3ce3597851110001cf62481c9976fe80734502bc28ff74af4e101e")

#API Key info - should only need loading once -  2500
# ors_api_key("5b3ce3597851110001cf624810789863e851418a86e0341fb278a772")
```

\newpage

# Acknowledgements

I would like to thank my dissertation supervisor, Dr. Nick Hood, for his invaluable advice and support throughout this research process. I would also like to thank my partner and my friends for all their support and advice and continuous encouragement.

\newpage

# Abstract

Waste, and in particular, plastic waste is a huge environmental concern, with convenience in consumerism being a major driver. Zero waste stores aim to tackle not only the problem of waste, but aim to transform the complete retail path from producer/supplier through retail and consumer. They aim to source products locally, reducing supply chains and supporting local businesses, completely cut out plastic from the retail store environment, minimise the impact on the environment through (dangerous) chemical free household goods and produce, and minimise food waste This study aims to identify a number of optimal sites on retail centres where new zero waste stores could be located, based on an analysis of selected socio-demographic variables. During the study, it became apparent that there was no research into this area of retail, and due to the drive for net‐zero and more sustainable practices, the need for any research in this area was required.

The demographic data used in this study was taken from the 2021 census and retail centre data from the Consumer Data Research Centre (CDRC) for the study area of England and Wales. Using five variables chosen for their implications towards more environmentally conscious behaviours (home ownership, professional occupation type, higher education level, limited vehicle access and household composition), catchment areas around over 100 zero waste stores were calculated and their demographic constituents were analysed, resulting in the creation of scorecards for each. These were then used as the basis for the analysis of the catchment areas of retail centres that did not contain one of these stores.

The distributions of the scores for both the stores and the retail centres fell within a similar range, and it could therefore be argued that most retail centres would be a good choice of new store location. However, these were narrowed down using the mean score for each variable and the total scorecard score for each store as the target for retail centre scores. 9 retail centres were found and adjudged to be the most optimal new store location. These findings indicate the importance and urgency of the need for further research into environmentally conscious behaviour related to store location planning of ethical retail outlets.\

**Word count**

9,894

\newpage

\tableofcontents

\listoffigures

\listoftables

\newpage

# Introduction

### *Research Questions*

This research will investigate how socio‐demographic variables that relate to environmentally conscious behaviour can help to define optimal locations for zero-waste stores in England & Wales.

-   Can socio‐demographic data (education level, occupation type, vehicle access, household composition, and tenure) be used to identify optimal locations for new zero-waste stores?
-   Can these variables be used to provide evidence of environmentally conscious behaviour and therefore the likely customer base of the stores in the catchment areas?
-   Are these variables able to be used to find gaps in potential market provision?

### *Aims*

Extensive research concentrating on the importance of household waste, packaging, the concept of zero‐waste, and packaging's role in zero‐waste stores and supermarkets exists [@scharpenberg2021; @sastre2022; @mollaloGISbased2020]. Demographic analysis is a widely studied area in the social sciences and in retail more specifically, however, research into the potential links between environmentally conscious behaviour and zero-waste store locations, at the time of writing, is non‐existent. This indicates an important gap in ethical retail (supply and demand), and more generally, in environmentally conscious social and behavioural knowledge.

This study aims to...

-   Provide evidence of a customer base for this sector of retail, based on the demographic analysis of defined catchment areas
-   Provide the most likely optimal retail centre locations for new stores based on this demographic analysis

### *Objectives*

To meet the aims of the study, the following objectives were carried out: -

-   Scorecard creation for each area that is currently served by a zero waste store
-   Distribution analysis of selected socio‐demographics catchment areas around the stores
-   Investigate any similarities in the retail centre configuration / geography of these locations
-   Analyse similarities in the non‐serviced locations for potential new stores
-   Identify potential limitations and improvement of the study
-   Propose further research

The objectives were met through gathering data from various sources such as the Consumer Data Research Centre (CDRC), Office for National Statistics (ONS), Open Street Map (OSM), and Nomisweb. Distributions of the chosen variables helped to highlight factors that have the potential to allow a picture of the catchment areas of known existing zero‐waste stores to be developed. By drawing upon the literature around the analogue method for location-allocation, and the creation of composite indicators, scorecards were produced. These methods provided the basis for analysis of the catchments containing stores, which allowed for an evidence-based analysis of locations that are not currently serviced by a store, and revealed whether there are any locations that display good potential customer base.

A review of the literature follows this introduction, which provides the basis for the choice of variables and methods to be used. The steps taken throughout the study will then be described, followed by a results description section. The findings and limitations of the results and methods will then be discussed. Finally, the conclusion will pull together the study and provide recommendations for improvements and further research.

\newpage

# Literature Review

This section will review the literature on the most relevant and important methods of store location planning that are employed by the retail sector. Each will be discussed for appropriateness for use in this study. A review of studies that focus on environmentally conscious consumption behaviours and associated demographic profiles will be carried out. This will provide the justification for the choices of variables that will be used in the method of this research.

Waste, as a general concept; particularly packaging waste, and the way in which we as consumers can tackle the associated issues with the latter, will be discussed. A brief history of waste will be described for context, including some of the problems that are associated with production and consumerism. The review will move on to research related to zero‐waste lifestyles and the changes in attitudes and practices towards environmentally conscious consumption. Zero‐waste shops and the related product solutions that are linked to these, which aim to move retail towards zero‐waste consumer practices will then be addressed.

Table \ref{tab:srchtrms} shows the search terms used to research academic databases (Google Scholar, Web of Science, Scopus, and ProQuest)

```{r search_terms_table, echo=FALSE}
# Uses library(kableExtra)
# Load zws RDS file
srch_trms <- as.data.frame(read.csv("search_terms.csv"))
# srch_trms <- srch_trms  |> dplyr::rename_at('Search.Term', ~'Search Term')
saveRDS(object = srch_trms, file = "srch_trms.rds")
# Display a table of the first 10 records
kable(srch_trms,
      caption = "\\label{tab:srchtrms}Search terms used in database and Google Scholar searches.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8)
remove(srch_trms)
```

\

### *Zero Waste Concept: Then & Now*

Prior to industrialization, society produced very little waste [@mauch2022]. People fed livestock with leftover food, repaired broken items, and handed household goods like furniture down to the next generation. With the advent of industrial capitalism in the mid‐nineteenth century, production was designed to maintain itself, with old products discarded when a new, or better product is made available. This is the defining feature of consumerism [@graeber2011]. After World War II the world inevitably saw a huge rise in waste of all kinds due to mass‐production and mass‐consumerism. As figure \ref{globalwaste} shows, the amount of waste generated globally in 1965 was around 635 million tonnes (mt) increasing to 1999 mt in 2015 and is projected to rise to 3539 mt by 2050 [@chen2020]. This trajectory is clearly a problem that has become increasingly urgent to address.

\FloatBarrier

![Global Yearly Waste Production by Type [@chen2020]\label{globalwaste}](Images/Globalwaste.png){width="514"}

\FloatBarrier

The term "zero-waste" was coined in 1973 by Paul Palmer [@zaman2015] in relation to reusable "clean" chemical waste being produced in Silicon Valley. He started selling these 'waste' chemicals back to the industry with the principal strategy that everything should be reused rather than used once and discarded [@mauch2022]. The term evolved over the following years, and there is now no consensus on the definition [@pietzsch2017]. Zero‐waste now encompasses the theory, practice, and learning of governments and individuals, and is a catch‐all term for the response to the crisis of waste and the failure to manage it [@hannon2018] In the context of this study, the term 'zero-waste' will be used to define a sector of retail that eliminates plastic from products sold in stores that also seek to minimise waste and emissions from the rest of the supply chain.

In England in 2002, it was estimated that producers accounted for 91% of national waste [@murray2002]. Within the manufacturing and production sectors for example, zero‐waste as a concept is an effective way to help minimise solid waste, and through redesign, resource life cycles enable products to be reused [@song2015].

From a consumer perspective, food waste reduction has become one of the biggest areas of concern for zero waste research [@zhang2022]. Around one third of all the food bought is thrown away in England [@murray2002], with environmental deterioration caused by non‐sustainable consumption impeding sustainable development [@chekima2016]. Packaging is intrinsically linked to food waste. This is because food retail uses the highest amount of packaging of any sector and is the reason why packaging is the largest constituent of plastic waste [@sastre2022]. Figure \ref{globalplastic} shows that global plastic production in 2015 was just under 350 mt with over 35% of all plastic produced being used for packaging (see figure \ref{plasticuses}).

\FloatBarrier

![Global Plastic Production: 1950 - 2015 [@beckman2018] \label{globalplastic}](Images/WorldPlastic_1950_2015.png){width="300"}

![The different uses of plastic. [@beckman2018] \label{plasticuses}](Images/Plastic_use.png){width="300"}

\FloatBarrier

Figure \ref{ancum_plastic} shows that around 10 mt of plastics produced, end up in the world's oceans. Although the annual amount is predicted to fall, the cumulative effect of adding to the problem is still estimated to rise to over 1500 mt by 2100 [@chen2020].

\FloatBarrier

![Annual and Cumulative Plastic Input into Oceans [@chen2020]\label{ancum_plastic}](Images/ann_cum_plastic.png){width="514"}

\FloatBarrier

The problem of waste in food retail can partly be addressed through product design. Packaging can be produced to have as little impact on the environment as possible. Minimising environmental damage from packaging and its relationship with sustainability has seen a large increase in research and literature in recent years [@sastre2022], and in the UK there have been trials of changes to packaging-free retail in some of the larger supermarket chains. Waitrose launched a trial in its Oxford store in 2009, by dedicating a section of the floor‐space to a refill station, where cleaning materials, wine, and dried goods were made available to customers to use their own reusable containers. By testing this method of shopping in‐store, they were able to gauge the appetite for a different type of shopping experience [@smithers2019]. They have also shown how significant the role of the consumer is in how food retail operates, and how a move to sustainable consumerism can be achieved. Due to the Waitrose 'Unpacked' trial's success, they introduced refill options to three other stores, and as interest and demand grows, they hope to offer the 'Unpacked' option in more stores and online [@waitrose&partners].\

### *Zero Waste Shops (supply)*

Zero‐waste shops are dedicated to eliminating all unnecessary waste from the retail consumer experience [@watson2020]. Zero-waste stores use practices that eliminate plastic packaging by displaying products in bulk where they can, and customers bring their own containers, or use store supplied paper bags. These shops may also aim to send all food that expires to foodbanks or community kitchens, bulk purchase saleable products that minimise transport waste products such as CO~2~ and NO~x~ pollution and stock products with known origins from suppliers with similar priorities that are as local as possible [@bartek2022].

In addition to these practices, zero-waste shops can help in the building of a sense of community. They are often small neighbourhood stores started though crowdfunding or another local campaign [@greenpeaceusa2019]. This allows for the community to be involved from the start and provides a sense of investment in the success of the future of the store.

However, as the demand for sustainable retail rises, the competition for customers will increase, and as Waitrose have already stated, the larger stores will be able to offer more choice than smaller independent local stores. This may mean that product choice in the larger retailers will be greater, but as described above, there is more to environmentally conscious retail than simply packaging and the elimination of plastic. The larger retailers will also have to consider the ethical choices made by consumers in relation to the environmental impacts of supply chains, and support for local producers and other businesses.

During this research there were very few studies found, that focussed on zero-waste stores, and there were no studies found that address the locations, and the reasons for these locations of zero-waste stores. This constitutes an important gap in the literature that this study contributes to addressing.\

### *The customer (demand)*

Who the customers for zero-waste stores are likely to be is an important consideration. There are conflicting results from various studies that contradict the demographic characteristics that were found to influence environmentally conscious consumer behaviour. For example, a survey to identify the levels of environmental awareness in consumers was carried out in Slovakia. It targeted the age groups between 1965‐1980 (gen' x) and 1981‐1996 (gen' y), due to these groups' greater purchasing power over other groups. They found that amongst the gen' y group, 39% were likely to use zero‐waste stores 'often' as opposed to 10% of the gen' x group [@holotova2020]. This suggests that age is an important variable when analysing the demographics of the customer base of zero‐waste stores. @diamantopoulos2003 highlights the weakness in using socio‐demographics to try to define a 'green consumer', because 'environmental awareness' is not fully understood through gender, age, and education etc. However, there are a large number of studies [@bekhet2011; @yuan2013; @sang2015; and @zhao2014], who have all found contradictory evidence that environmentally conscious 'behaviours' are strongly associated with demographic characteristics such as age, sex, education, occupation type and higher income levels.\

## Store planning

### *The use of demographics to identify store locations and potential demand*

Knowing the market demand helps to understand the potential of a location. Retailers use, amongst other data, demographic classifications that have been aggregated from census and other sources to do this. Data are aggregated into small areas such as post‐code, or the Output Area Classification [@birkin2017]. Potential customers must be identified from the data and in the case of the zero‐waste store, environmentally conscious or green consumer behaviours and characteristics are essential for this purpose.

The census provides a snapshot of the age ranges, ethnicities, population density, household compositions, housing type, socio-economic composition, and employment classifications in each area, for example. This data can be used to target specific groups based on the demand for a particular service.

Around 86% of the UK population is classed as urban and as with many cities across the globe, population growth is expected to result in over 90% of the world's population living in cities, with the waste that is produced in them also growing [@statista]. Urban populations are more likely to be highly educated, and gain higher incomes [@wensing2023], therefore adults that have a high education level must be considered as potential ethical consumers in the first instance [@paul2016; @chekima2016a]. Gender and age are also indicators of environmentally conscious consumerism. @gilg2005 found that 65% of committed environmental consumer behaviours were attributed to females, with the mean age being 55 years, but in the UK, 18‐24 was the age at which females are especially likely to consume ethically.

One problem with the averaging of such characteristics, to gauge demand for example, is the ecological fallacy [@openshaw1984]. This is essentially when an averaged characteristic of an area is applied to the individual scale, which fails to recognise finer detail in demographic composition of an area. For example, an area may be calculated to be wealthy on aggregate, but within that region there may be a pocket of poverty that missed, resulting in that population being ignored when planning social and financial support.\

### *Catchment Area*

Defining the catchment area for a store is a highly important aspect of retail location analysis. To do this, a possible solution is to draw an arbitrary boundary around a store and include the population within that boundary as potential custom [@hernandez2000]. A better-defined catchment area would be to estimate how far a customer will travel, either by foot, car, or by public transport, to a store. Isochrones define boundaries that are the limit of distance accessibility within a time using a specified mode of locomotion from a specified point. A 20-minute walking time to a store location could be used for example and would consider terrain and route layout [@openrouteservicea]. It would also adhere to the concept of the 20-minute city, which aims to provide people with the ability to meet all everyday needs within a 20-minute walk or cycle from their home [@contardoayala2022].

Using a buffer and overlay system available in Geographical Information System (GIS) software can build an accurate picture of an area through the addition or removal of features. For example, a discount retailer looking for a new store location may filter out customers from a higher income class in an area, leaving lower income populations in the analysis data [@birkin2017]. It may also provide a better picture of the residential make‐up of an area, by allowing for non‐residential areas to be accounted for. This can be used in conjunction with a network analysis, where accessibility can be further investigated using a more comprehensive analysis of road networks to deduce the travel times to the providers of a service [@birkin2017].\

### *Location Choice*

Once locations have been identified, a choice must be made. There are numerous methods for choosing a new location for a store, and these can range from the simple to highly complex solutions. The simpler, cheaper, and traditional approach, where experience tells the planner where to locate a store has not entirely been replaced by the more complex methods such as checklists or scorecards [@hernandez2000].

Part of an analogue method of location analysis, checklists involve scoring several variables that positively influence store performance. Demographic and retail centre classification variables are identified and rated according to a points system which, when combined, can be used to compare potential locations and catchment areas [@hernandez2000], each of which can be classified accordingly.

Although checklists can be used to investigate the similarities and differences between each location, providing a picture of the customer base for a particular type of shop (in this case; zero‐waste stores), they are unable to estimate revenue [@birkin2017]. This study is not seeking to estimate the success or failure of a store on predicted or current revenue data due to the data being unavailable.

Multi‐variate regression methods are more complex still and require large amounts of (good quality) data, computing power, and expertise. Decisions are then based upon statistically significant results [@hernandez2000]. These methods are good at benchmarking sales and forecasting, and mainly used for future development for specific products, or new stores. The same restrictive factors such as computing power are also prevalent in methods such as cluster and factor-analysis. This is where a retailer's portfolio can be clustered into types of offering, and used to create a blueprint for strategic change, involving the creation of discount lines to be sold in stores located in lower income areas.

Gravity modelling, Spatial Interaction Models (SIM), and neural network methods are even more complex and expensive to facilitate, in terms of expertise, computing and data. SIM generally rely on the availability of data such as flows of revenue for example [@birkin1999]. They show the relationships between the flow of consumers and revenue, and are used in the analysis of the effects on existing provision and revenue of a competitor opening nearby [@hernandez2000]. Neural networks are essentially a scaled-up version of this and are used to forecast performance related to multiple new sites. Methods based on the link between flows of money are useful tools for retail location analysis and site planning [@hernandez2000; @wood2007; @birkin2017], however, access to sales data is highly restricted, hard to access for resource limited studies, and was unavailable for this study.

## *Conclusion*

Waste in general, but specifically plastic waste has become an increasingly important problem for society and the planet's health. Food, and other household item packaging is one of the main contributors to plastic waste, so it is vital that the aim is to minimise this burden. There is a gap in existing research into the problem of where zero-waste stores are ideally located, and there were no specific studies in this area at the time of writing. This means that the aims of this study are an important addition to existing knowledge on sustainable retail. This study will attempt to discover whether socio‐demographic characteristic analysis can signify potential customer bases for these stores and help to define the best locations for them.

\newpage

# Methodology

This section describes a quantitative approach to identifying catchment areas and their constituent demographics surrounding the stores in the study area. This involved creating scorecards for each location, based on selected variables, which were then used to identify similar locations of the study area in which new stores could ideally be placed. By incorporating statistical and geospatial techniques to the analysis of the data and presenting the results through geographical and statistical representations, a landscape of ethical consumption was built up and visualised. This fed the discussion of the rationale behind the choices of variable used, the methodological approach, and the evaluation of the results.

### *Zero Waste Store Location Data*

Store location data was extracted from the metadata of the 'The Zero Waste Network' [@thezerowastenetwork] website. This site was the most comprehensive listing found. Table \ref{tab:zws} shows examples of the raw data.

\FloatBarrier

```{r zwstab}
# Uses library(kableExtra)
# Load zws RDS file
zws <- readRDS("zws.rds")
# Display a table of the first 10 records
kable(zws[1:10,], caption = "\\label{tab:zws}Selected zero-waste stores data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(zws)
```

\FloatBarrier

Data were cleaned using Google searches to identify and remove any stores that were irrelevant to the study, such as incorrectly listed stores, wholesalers, and mobile refill vehicles, and to highlight any that had closed since being listed. Of the initial 172 stores, 135 remained. To ensure that the remaining stores had correct coordinate data and sat within the study area, a plot of all the locations was made (see figure \ref{zwstores}).

\FloatBarrier

![Map of all Zero Waste Stores in Study Area. \label{zwstores}](Images/zwsmap.png){width="400"}

\FloatBarrier

### *LSOA Area Scale Boundary Data*

Lower Super Output Area (LSOA) scale data was downloaded from the Open Geography Portal [@opengeographyportal2022a]. This related to the latest 2021 boundaries and included an identifier and the relevant spatial geometries. LSOA scale data was chosen so that the number of households or individual populations within each area were small enough to allow for comparison between the demographic composition of areas. Output areas (OA) scale data provides a more granular scale that LSOA scale data, however, at the time of extraction, all the chosen demographic variables were not available at the OA level, so LSOA scale data was chosen to provide consistency.

\FloatBarrier

```{r lsoa_table}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoas <- readRDS("lsoas.rds")

# # remove the scores from the lsoa data
# lsoas = lsoas |> select(-one_of('occrank', 'tenrank', 'carrank', 'pplrank', 'dedrank'))

kable(lsoas[1:5,c(1,3,9)], caption = "\\label{tab:lsoas}LSOA boundary data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

\FloatBarrier

### *Demographic data*

Nomisweb provided the ONS, 2021 census data, again, at the LSOA scale [@nomis]. LSOA area codes were included to provide linked identifiers for GIS processing. Because income data was unavailable, the some of the following demographic variables were chosen as part-proxies for this missing data, and were found under the following identifiers: -\

TS003 - Household composition

This data included households that were classified as married single family households with no children, or cohabiting couple households with no children (see Table \ref{tab:pplscr}). Household composition amongst committed environmentalist in the results of the study by @gilg2005 was smaller, with two person households accounting for 40%, which suggested greater income levels. This is because they had sufficient means to combine to either obtain a mortgage or rent, and secondly, because there were no children in the make‐up of the household, which indicated a higher level of disposable income [@officefornationalstatistics2019]. Behaviourally, as @tonglet2004 points out, cohabiting couples that share values, can also be more likely to encourage environmentally conscious behaviours and more ethical decisions.

\FloatBarrier

```{r 2ppl_data, echo=FALSE}
pplscr <- readRDS("pplscr.rds")
# pplscr <- pplscr[order(pplscr$mnemonic),]
# # Create a table for the Household composition data 
# Load the 2ppl data
# pplscr <- read.csv("2ppl.csv")
# # remove the country row
# pplscr = pplscr[-c(33756), ]
# pplscr = as.data.frame(pplscr)
# 
# # clean the unrequired columns
# pplscr = pplscr |> dplyr::select(-one_of('Total..All.households', 'X.', 'Single.family.household..Married.or.civil.partnership.couple..No.children', 'X..1', 'Single.family.household..Cohabiting.couple.family..No.children', 'X..2', 'tot_.', 'score_calc', 'hhld_.'))
# 
# pplscr <- pplscr  |> dplyr::rename_at('mnemonic', ~'LSOA21CD')
# pplscr <- pplscr |> dplyr::rename_at('X2021.super.output.area...lower.layer', ~'Area')
# pplscr <- pplscr |> dplyr::rename_at('score', ~'pplscr')
# pplscr <- pplscr  |> dplyr::rename_at('Single.family.household..All.aged.66.years.and.over', ~'2ppl >66yrs')
# saveRDS(object = pplscr, file = "pplscr.rds")

kable(pplscr[1:5,c(1,2,3,7)], row.names = F, caption = "\\label{tab:pplscr}Total LSOA scores for household composition data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "1in") |> 
  column_spec(4,width = "0.75in") 
remove(pplscr)
# saveRDS(object = pplscr, file = "pplscr.rds")
```

\FloatBarrier

TS045 - Car or van availability

This dataset included households which reported as having access to a single vehicle only (see table \ref{tab:carscr}). Vehicle availability was chosen due the balance that is required between necessity and environmentally conscious behaviours. Simply put; even the most environmentally conscious consumer must travel, and sustainable behaviour is influenced by both the reasons why travel is required, and the transportation environment. Employment is a major factor related to reasons for private vehicle travel, especially if public transport is not convenient and efficient. Many people balance these travel requirements with environmental concerns and self‐limit their impacts on the environment by minimising their own vehicle access [@taube2018]. This is also supported by the study into sustainable lifestyles and green consumption by @gilg2005, where they found that each of the survey respondent clusters, more than 50%, limited themselves to a single vehicle.

\FloatBarrier

```{r car_table, echo=FALSE}
carscr <- readRDS("carscr.rds")
# carscr <- carscr[order(carscr$LSOA21CD), ]
# 
# # # Load the vehicle access data
# # carscr <- read.csv("1car.csv")
# # # clean the unrequired columns and rename them for ease of use
# carscr = carscr |> dplyr::select(-one_of('score_calc', 'X.'))
# # carscr <- carscr  |>  dplyr::rename_at('X2021.super.output.area...lower.layer', ~'Area')
# # carscr <- carscr  |>  dplyr::rename_at('score', ~'carscr')
# # carscr <- carscr  |>  dplyr::rename_at('mnemonic', ~'LSOA21CD')
# carscr <- carscr  |>  dplyr::rename_at('Total..All.households', ~'total_hhld')
# carscr <- carscr  |>  dplyr::rename_at('X1.car.or.van.in.household', ~'hhld_vehicles')
# saveRDS(object = carscr, file = "carscr.rds")

kable(carscr[0:5,1:4], row.names = F, caption = "\\label{tab:carscr}Total LSOA scores for single vehicle access data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(carscr)
```

\FloatBarrier

TS054 - Tenure - Homeownership

This included households that reported as either owning their own homes outright, or under a mortgage/loan. (See Table \ref{tab:tenscr}). Tenure, and home ownership was identified as highly likely, amongst participants that were classified as the most committed to sustainable consumption [@gilg2005]. The variable aids the implication that those who can afford their own homes can provide a link to a partial proxy for the unavailable income level.

```{r tenure_table, echo=FALSE}
tenscr <- readRDS("tenscr.rds")
# tenscr <- tenscr[order(tenscr$LSOA21CD),]
# # Load the tenure data
# #tenscr <- read.csv("tenure.csv")
# 
# # clean the unrequired columns and rename them for ease of use
# tenscr = tenscr |> dplyr::select(-one_of('score_calc', 'X.', 'sum'))
# # tenscr <- tenscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
# # tenscr <- tenscr  |>  rename_at('score', ~'tenscr')
# # tenscr <- tenscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# # saveRDS(object = tenscr, file = "tenscr.rds")
# tenscr <- tenscr  |>  dplyr::rename_at('Total..All.households', ~'hhld_total')
# tenscr <- tenscr  |>  dplyr::rename_at('Owned..Owns.outright', ~'Owned')
# tenscr <- tenscr  |>  dplyr::rename_at('Owned..Owns.with.a.mortgage.or.loan', ~'Mortgage/loan')
# 
# saveRDS(object = tenscr, file = "tenscr.rds")

kable(tenscr[1:5,1:5], row.names = F, caption = "\\label{tab:tenscr}Total LSOA scores for homeowners that own outright or mortgage data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(tenscr)
```

\FloatBarrier

TS067 - Highest level of qualification - degree educated

Education level data was included only for those that have a degree level or above education (see table \ref{tab:dedscr}). @gilg2005 found that active and committed environmental behaviour was most prominent among those with a degree or higher level of education. This was also found to be important by @han2010 , who report that more than 80% of respondents to their study regarding green consumer decision making, were degree educated. Education level is also an important factor in the ability to have a good understanding of the complexity of environmental issues and can be a driver of green behaviour [@chekima2016a].

```{r deg_ed_table, echo=FALSE}
dedscr <- readRDS("dedscr.rds")
# dedscr <- dedscr[order(dedscr$LSOA21CD),]
# # Load the degree educated data
#  dedscr <- read.csv("degree_educated.csv")
# # 
# # # clean the unrequired columns and rename them for ease of use
#  dedscr = dedscr |> dplyr::select(-one_of('X.', 'MinMax'))
# #  dedscr <- dedscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
#  dedscr <- dedscr |> dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over', ~'residents_total')
#  
#  # dedscr <- dedscr |> dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over', ~'residents')
#  # dedscr <- dedscr |> dplyr::rename_at('score', ~'dedscr')
#  # dedscr <- dedscr |> dplyr::rename_at('mnemonic', ~'LSOA21CD')
# #  
# saveRDS(object = dedscr, file = "dedscr.rds")

kable(dedscr[1:5,1:4], row.names = F, caption = "\\label{tab:dedscr}Total LSOA scores for degree education level or above data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(dedscr)
```

\FloatBarrier

TS063 - Occupation

Occupation data included people classified as managers, directors, senior officials, and professional occupations (see table \ref{tab:occscr}). Occupation is somewhat related to the level of education, but more importantly ties in with the search for valid proxies for higher income levels. These occupations in general pay the most and are also likely to be filled by people that are educated to degree level or above, and therefore earn more on average [@departmentforeducation].

```{r occ_data, echo=FALSE}
occscr <- readRDS("occscr.rds")
# occscr <- occscr[order(occscr$LSOA21CD),]
# # Load the occupation data
# occscr <- read.csv("occ.csv")
# 
# # clean the unrequired columns and rename them for ease of use
# occscr = occscr |> dplyr::select(-one_of('X.', 'X..1', 'X..2', 'calc'))
# 
# occscr <- occscr  |>  dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over.in.employment.the.week.before.the.census', ~'residents_total')
# 
# occscr <- occscr  |>  dplyr::rename_at('X1..Managers..directors.and.senior.officials', ~'managers/directors')
# 
# occscr <- occscr  |>  dplyr::rename_at('X2..Professional.occupations', ~'professionals')
# 
# occscr <- occscr  |>  dplyr::rename_at('high_earners.', ~'high_earn_total')
# 
# #  occscr <- occscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
# #  occscr <- occscr  |>  rename_at('score', ~'occscr')
# #  occscr <- occscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# 
# # 
 # saveRDS(object = occscr, file = "occscr.rds")

kable(occscr[1:5,1:6], row.names = F, caption = "\\label{tab:occscr}Total LSOA scores for higher rated occupations for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "1in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(occscr)
```

\FloatBarrier

Using Excel to process the .csv files, percentages were calculated from reported total households/individual populations for each of the five variables. Each variable was standardised using the scaling method in which each LSOA was given a score/ranked from 0 to 1 using the following formula: -

$$
x_{norm} = (x_{raw} - min_{i})/(max_{i} - min_{i})
$$

Rankings were then multiplied by 10 and rounded to the nearest integer to provide final scores from 0 to 10 for each LSOA for each variable.

There could have been an argument to increase the weighting for either the education level or occupation variable to act as a proxy for spending power, but it was decided that with both variables being used in the study, they would provide a natural weighting, and would therefore not require any adjustments. There were no other weightings given to any of the variables.

### *Combining score data and calculating totals*

Scores for each variable were allocated to the matching LSOA's. A total score for each LSOA was then calculated. The resulting dataset (see table \ref{tab:rc_data} for examples), was inspected to provide assurance of accuracy, where scores ranged from 0 and 10 only, and total scores were within a 0 to 50 range.

\FloatBarrier

```{r score_prep}
# Convert lsoas to a sf file format and set the CRS to 3857
# lsoas = st_as_sf(lsoas)



#### Create a dataframe that holds the LSOA21CD id and the score for each variable
# Convert the lsoas sf file to a data.frame
#lsoas = as.data.frame(lsoas)

# Join each variables score data to the LSOA data and remove the unrequired columns each time
# carscr
#lsoas = left_join(lsoas, carscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# dedscr
#lsoas = left_join(lsoas, dedscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# occscr
#lsoas = left_join(lsoas, occscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# pplscr
#lsoas = left_join(lsoas, pplscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# tenscr
#lsoas = left_join(lsoas, tenscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# sum the individual LSOA row values in columns 10 to 14 and add the result to a new column at the end after tenscr
#lsoas = lsoas |> 
#  mutate(lsoatotscr = rowSums(lsoas[,10:14], na.rm = TRUE),
#         .after=tenscr)

# remove unrequired temporary dataframes etc
#remove(carscr, dedscr, occscr, pplscr, tenscr)

# Save the lsoa data with the newly added individual scores and the calculated total scores
#saveRDS(obj = lsoas, file = "lsoas.rds")
# Load the results of the above code to save processing and memory when knitting
# lsoas <- readRDS("lsoas.rds")
```

```{r lsoa_score_table, echo=FALSE}
lsoas <- readRDS("lsoas.rds")

kable(st_drop_geometry(lsoas[1:5,c(1,3,10:15)]), row.names = F, caption = "\\label{tab:lsoa_scores}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

\FloatBarrier

### *LSOA area scale population weighted centroids*

Population Weighted Centroids (PWC) were retrieved at the LSOA scale from the Open Geography Portal [@opengeographyportal2022]. This was required because once the stores and retail centre isochrones had been calculated, those isochrones that contained a PWC would be filtered and used to calculate the scorecard for each location. PWC data can be seen in table \ref{tab:lsoa_pwcs}.

\FloatBarrier

```{r pwc_data, echo=FALSE}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoa_pwc <- readRDS("lsoa_pwc.rds")

kable(lsoa_pwc[1:5,c(2,4)], row.names = F, caption = "\\label{tab:lsoa_pwcs}LSOA population weighted centroid data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoa_pwc)
```

\FloatBarrier

### *Retail Centres*

Retail centre boundaries for England and Wales were retrieved from the Consumer Data Research Centre [@consumerdataresearchcentre2022] so that once analysis of all zero-waste stores locations had been completed, potential retail centres that lack the supply of this type of store could be identified. The retail centre data was processed through QGIS to identify the centroid of each polygon, added to the main file, and can be seen in table \ref{tab:rc_data}.

```{r retail_centre_data, echo=FALSE}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
# retail_c <- readRDS("retail_c.rds")
all_rcs <- readRDS("all_rcs.rds")
# 
# # # # reindex the data
# # rownames(retail_c) <- 1:nrow(retail_c)
# # 
# # saveRDS(object = retail_c, file = "retail_c.rds")
# 
# retail_c <- retail_c  |>  dplyr::rename_at('Classifica', ~'Classification')
# saveRDS(object = retail_c, file = "retail_c.rds")

kable(st_drop_geometry(all_rcs[1:5,c(2:5)]), row.names = F, caption = "\\label{tab:rc_data}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(all_rcs)
```

\FloatBarrier

### *Creating a test scorecard using a known store location*

To test and refine the methods to be used to process the full dataset of zero-waste stores, a single test store was selected. This was a known store in a known area, and allowed for the method to be corrected as problems arose.

The following test store results shows the process that was followed for all zero-waste stores. Once the zero-waste stores data had been processed, the data for the retail centres that do not contain a zero-waste store were processed using the same methods. Table \ref{tab:bishytab} shows the store data and figure \ref{fig:bishylocation}, a map of the test area in question.

\FloatBarrier

```{r bishy_load, echo=FALSE}
# Load bishy store boundary shapefile
bishy <- readRDS("bishy.rds")

# Convert this to the correct 3857 CRS
# bishy = st_transform(bishy, crs = st_crs(3857))

# rename the geometry column
# bishy <- bishy  |>  rename_at('geometry', ~'store_location')

kable(st_drop_geometry(bishy[,1:7]), row.names = F, caption = "\\label{tab:bishytab}Test store data for the Bishy Weigh store in York, England")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T)
remove(bishy)
```

\FloatBarrier

```{r bishylocation, fig.height=4, fig.width=4, fig.cap="Location of The Bishy Weigh store in York", echo=FALSE}
bishy <- readRDS("bishy.rds")
ggplot(bishy) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  geom_sf(colour = "blue", aes(geometry = bishystorepoint, fill = st_nam)) +
  guides(fill = guide_legend(title = "Test Store Name")) +
  theme_void(base_size = 10) +
  theme(plot.margin = margin(t = 10,  # Top margin
                             r = 0,  # Right margin
                             b = 10,  # Bottom margin
                             l = 0)) # Left margin
remove(bishy, ywalktime20)
```

\FloatBarrier

### *Calculating the isochrone*

Using the OpenRouteService [@openrouteservicea], a 20‐minute walk‐time isochrone was calculated around the test store to define the catchment area. This distance/time was chosen partly due to the individual health benefits of walking [@sari2010; @tschentscher2013], and partly to fit in with the concept of a chrono‐urbanism and temporally accessible city design concepts such as the x-minute city [@moreno2021]. Benefits of this concept include decreasing vehicle pollution and helping towards achieving the goal of 'net‐zero' [@moreno2021; @ogorman2021]. The test store isochrone was mapped to ensure that the correct location and catchment area had been captured see figure \ref{fig:york_isochrone_test_map}.

\FloatBarrier

```{r york_isochrone_test_map, fig.height=3, fig.width=3, fig.cap="20-minutes walking distance isochrone from The Bishy Weigh store in York", echo=FALSE}
bishy <- readRDS("bishy.rds")
# Uses library(ggspatial)
# Convert the walktime20 isochrone to the correct CRS
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
ywalktime20 <- readRDS("ywalktime20.rds")
# Map the 20 mins isochrone and store location
# use the walktime LAYER isochrone as the main data layer
ggplot(ywalktime20, aes(colour = "20-minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(fill = "darkgrey", alpha = 0.4) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red", size = 1,
          aes(fill = st_nam)) +
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(ywalktime20, bishy)
```

\FloatBarrier

PWC data was clipped so that only those PWC that fell within the isochrone would be processed. This decision was made to ensure that only population centres and the corresponding LSOA(s) that fell within the catchment area were included. If this was not taken into consideration the scorecards could have been calculated using LSOA(s) that had a proportion of their boundary within the isochrone, but with PWC situated further than 20 minutes from the store and outside of the isochrone, resulting in population scores that include a walk‐time that is greater than 20 minutes. These were mapped to check method accuracy and can be seen in figure \ref{fig:bishy_pwc_clipped}.

```{r ypwc_clip, fig.height=3, fig.width=3, warning=FALSE}
# pwc_clip <- readRDS("pwc_clip.rds")

# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# lsoas = readRDS("lsoas.rds")
# lsoas = st_as_sf(lsoas)
# ywalktime20 = readRDS("ywalktime20.rds")
# ###################################################################################
# # Test plot an LSOA
# # ggplot(lsoas[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = lsoageometry))
# ###################################################################################
# lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
# lsoa_pwc = readRDS("lsoa_pwc.rds")
# lsoa_pwc = st_as_sf(lsoa_pwc)
# lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# lsoas = st_as_sf(lsoas)
# lsoas <- st_transform(lsoas, crs = st_crs(3857))
# lsoa_pwc = st_as_sf(lsoa_pwc)
# lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(3857))
# 
# # clip the PWCs to only show those inside the 20 minute walk time
# pwc_clip = lsoa_pwc[ywalktime20$geometry,]
# saveRDS(object = pwc_clip, file = "pwc_clip.rds")
###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = -1, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
#   geom_sf(data = pwc_clip, aes(geometry = pwcgeometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
#   guides(alpha = guide_legend(title = "Catchment Area")) +
#   theme_void()
##################################################################################
##################################################################################
# remove(bishy, lsoa_clip, lsoa_pwc, lsoas, pwc_clip, ywalktime20)
```

\FloatBarrier

```{r bishy_pwc_clipped, fig.height=3, fig.width=3, fig.cap="Population Weighted Centroids within the isochrone surrounding 'The Bishy Weigh' store in York.", echo=FALSE}
bishy <- readRDS("bishy.rds")
pwc_clip <- readRDS("pwc_clip.rds")
ywalktime20 <- readRDS("ywalktime20.rds")
ggplot() +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
  geom_sf(data = pwc_clip, aes(geometry = geometry, shape = ""), size = 1) +
  guides(shape = guide_legend(title = "Population Weighted Centroids")) +
  geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
  guides(alpha = guide_legend(title = "Catchment Area")) +
  
  #   # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", which_north = "true", 
  #                        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 8)
remove(bishy, pwc_clip, ywalktime20)
```

\FloatBarrier

Corresponding LSOA for that catchment area were then identified using the LSOA identifiers. These results were mapped to visualise and confirm the accuracy of the procedure (see figure \ref{fig:pwcs_lsoas_york_map}).

\FloatBarrier

```{r}
# lsoa_clip <- readRDS("lsoa_clip.rds")
# pwc_clip <- readRDS("pwc_clip.rds")
# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# #lsoas = readRDS("lsoas.rds")
# #lsoas = st_as_sf(lsoas)
# 
# ###################################################################################
# # Test plot an LSOA
# # ggplot(lsoas[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = lsoageometry))
# ###################################################################################
# # lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
# lsoa_pwc = readRDS("lsoa_pwc.rds")
# # lsoa_pwc = st_as_sf(lsoa_pwc)
# # lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# # lsoas <- st_transform(lsoas, crs = st_crs(4326))
# # lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(4326))
# 
# # clip the PWCs to only show those inside the 20 minute walk time
# pwc_clip = lsoa_pwc[ywalktime20$geometry,]
# # clip the LSOAs to only show those for the clipped PWCs
# # lsoas <- st_transform(lsoas, crs = st_crs(3857))
# # pwc_clip <- st_transform(pwc_clip, crs = st_crs(3857))
# lsoa_clip = lsoas[pwc_clip,]

###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry, alpha = "")) +
#   # guides(alpha = guide_legend(title = "LSOAs")) +
#   geom_sf(data = pwc_clip, aes(geometry = geometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, fill = ""), alpha = 0.1) +
#   guides(fill = guide_legend(title = "Isochrone"))
# #################################################################################
```

```{r pwcs_lsoas_york_map, fig.height=4, fig.width=4, warning=FALSE, fig.cap="Map showing the clipped LSOAs related to the PWCs that fall inside the 20-minute walk time catchment area.", echo=FALSE}

lsoa_clip <- readRDS("lsoa_clip.rds")
pwc_clip <- readRDS("pwc_clip.rds")
bishy <- readRDS("bishy.rds")
ywalktime20 <- readRDS("ywalktime20.rds")

# Map the test store, isochrone and corresponding LSOAs and PWCs
ggplot(ywalktime20, aes(colour = "20 minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(data = lsoa_clip,  colour = "black", aes(alpha = ""), linetype = "11", size = 0.1) +
  geom_sf(data = pwc_clip, colour = "black", aes(shape = ""), size = 1) +
    geom_sf(fill = "darkgrey", alpha = 0.3) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red",
          aes(fill = st_nam)) +
  
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  guides(alpha = guide_legend(title = "LSOA Boundaries")) +
  guides(shape = guide_legend(title = "LSOA PWCs")) +
  # 
  # # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", which_north = "true", 
  #                        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 8)
remove(ywalktime20, lsoa_clip, pwc_clip, bishy)
```

\FloatBarrier

The corresponding LSOA scores previously calculated for each variable were mapped individually. This was to provide both a picture of the spatial distribution of the variables and to ensure that the previous steps provided meaningful results in that no individual scores were above 10. Figure \ref{fig:teststr_maps} shows the breakdown of individual LSOA scores for each variable, and the total score for the each LSOA, to show how the process creates the subsequent final scorecard.

\FloatBarrier

```{r teststr_maps, fig.height=9, fig.width=7, fig.cap="Individual LSOA scores for each variable and total scores"}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

# Carmap
carmamp <- ggplot(lsoa_clip) +
  geom_sf(aes(fill = carrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Access to a\nsingle vehicle (carrank)", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)

# Education map
edmap <- ggplot(lsoa_clip) +
  geom_sf(aes(fill = dedrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Degree Educated\n(dedrank)", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)

# Occupation map
occmap <- ggplot(lsoa_clip) +
  geom_sf(aes(fill = occrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Highest occupation\ntypes (occrank)", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)

# People Map
pplmap <- ggplot(lsoa_clip) +
  geom_sf(aes(fill = pplrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households with 2\npeople & 0 children\n (pplrank)", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)

# Tenure Map
tenmap <- ggplot(lsoa_clip) +
  geom_sf(aes(fill = tenrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households\nthat own or\nmortgage their home\n(tenrank)", reverse = TRUE, ncol = 2)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)

# Total Score map
totmap <- ggplot(lsoa_clip) +
  geom_sf(aes(fill = lsoatotscr)) +
  scale_fill_viridis_c(breaks=seq(0,50,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Individual LSOA\ntotal scores\n(lsoatotscr) ",ncol = 3, reverse = TRUE)) +
    geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 8)

grid.arrange(carmamp, edmap, occmap, pplmap, tenmap, totmap)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Once the LSOA scores had been calculated, they were summed to provide a total score for the area by dividing that total by the constituent number of LSOA's. Mean scores for each of the five variables were also calculated in the same way. This method was used to maintain equivalence across the subsequent store and retail catchment areas, and to allow comparison between the scorecard results of each. Otherwise, stores may have had greater or fewer number of LSOA's within the catchment area, rendering them isolated and without comparability.

```{r}
# Create a new variable to hold the totals for the final joined data and convert to a data.frame # # CRS should be 3857 # 
#lsoa_clip_tot = as.data.frame(lsoa_clip)

# create a row in the lsoa_clip_tot dataframe for the total MEAN for all lsoas in the area and the total of those totals #   
#lsoa_clip_tot <- lsoa_clip_tot |>      
#  bind_rows(summarise(lsoa_clip_tot[,9:14], across(where(is.numeric), mean), #across(where(is.character), ~'Total')))
#lsoa_clip_tot = st_as_sf(lsoa_clip_tot)

# Join the lsoas to a single shape - USE THIS "JOINED_LSOAS" AS THE FINAL LSOA SHAPE
#gglpot() +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = lsoa_clip_tot$lsoageometry))

# Test Plot
#plot(st_union(lsoa_clip_tot$lsoageometry))
#joined_lsoas <- st_union(lsoa_clip_tot$lsoageometry)

# Create a temp df "FT" to hold the totals for the whole joined LSOAs for each variable
#ft <- data.frame(matrix(ncol = 6, nrow = 0))
#lsoa_clip_tot = as.data.frame(lsoa_clip_tot)
#ft = lsoa_clip_tot[nrow(lsoa_clip_tot),9:14]
#lsoa_clip_tot = st_as_sf(lsoa_clip_tot)

# sum the individual variables for the whole lsoa_clip_tot and add the result to the bottom of lsoa_clip_tot
#bishy = st_as_sf(bishy)
#joined_lsoas = st_as_sf(joined_lsoas)
#joined_lsoas <- st_transform(joined_lsoas, crs = st_crs(3857))


# Test Plot Bishy
#ggplot(bishy) +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = joined_lsoas$x)) +
#  geom_sf(aes(geometry = bishy$store_location))
# THIS WORKED 
###################################################################################

#joined_lsoas = st_as_sf(joined_lsoas)
#bishyjoined = cbind(bishy, round(ft[,1:6], digits = 0))
#bishyjoined = cbind(bishyjoined, joined_lsoas)
#bishyjoined <- bishyjoined  |>  rename_at('x', ~'joined_lsoas')

################################################################################## # # Test plot
#bishyjoined = st_as_sf(bishyjoined)
#bishyjoined <- st_transform(bishyjoined, crs = st_crs(3857))

#ggplot(bishyjoined) +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = bishyisochrone, alpha = ""), colour = "blue") +
#  guides(alpha = guide_legend(title = "20 minute walk time")) +
#  geom_sf(aes(geometry = joinedlsoageometry, fill = lsoatotscr), alpha = 0.2) +
#  guides(fill = guide_legend(title = "Joined LSOA\nTotal Score")) +
#  geom_sf(aes(geometry = bishystorepoint,  colour = "")) +
#  guides(colour = guide_legend(title = bishyjoined$st_nam))
# THIS WORKED
###################################################################################
#saveRDS(obj = bishyjoined, file = "bishyjoined.rds")
#bishyjoined <- readRDS("bishyjoined.rds")
```

The individual LSOA spatial data was combined to a single polygon by removing the individual boundaries so that this could be added as a single data-point to the store data. An example of this can be seen in figure \ref{fig:final_bishy_map} below.

\FloatBarrier

```{r final_bishy_map, fig.height=3, fig.width=3, fig.cap="Final map of the test store showing the catchment area, the joined LSOA and the corresponding total score for the area", echo=FALSE}
bishy <- readRDS("bishy.rds")

ggplot() +
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  
  geom_sf(data = bishy, aes(geometry = joinedlsoageometry, alpha = bishy$totalscore), fill = "darkgrey") +
  guides(alpha = guide_legend(title = "Joined LSOA & score")) +
  
  geom_sf(data = bishy, aes(geometry = bishyisochrone, shape = "" ), alpha = 0.1, colour = "red") +
  guides(shape = guide_legend(title = "Catchment Area")) +
  
  geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  
  theme_void(base_size = 10)

remove(bishy)
```

\FloatBarrier

### *Processing all stores*

Data for all zero-waste stores was then processed in full using the same steps as the test store. The results were combined with the data in the zero-waste store data.

Of the original 135 stores, 128 were successfully processed. Those that were not, either did not produce isochrone calculations that contained PWC, or did not have valid coordinate geometry data. The scores for the remaining 128 stores were processed to calculate the mean scores of the five individual variables. The total mean score was then calculated to produce the final scorecard result for each store location (see table \ref{tab:allzwsscrtable} for examples).

```{r zws_iso_loop}
# Load the results file from the code below
# zwsiso <- readRDS("zwsiso.rds")

# remove(i, zws, zwsiso)
# 
# zws <- readRDS("zws.rds")
# # Loops throughthe zws file and creates a new dataframe (zwsiso) that holds the zws store data and the isochrone for the walktime20 mins boundary.
# 
# #############################################################################
# #                                                                           #
# #          Commented out to stop it running                                 #
# #                                                                           #
# #############################################################################
# # create a dataframe to hold the iso results
# zwsiso <- data.frame(matrix(ncol = 12, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(zws)) {
#   # create a df variable to hold the zws values from row i of zws
#  isodf = zws[i,]
#   # embed data in the output file rather than html streaming option
#  mapviewOptions(fgb = FALSE)
#   
#   # Get the coordinates of the store in the (df)
#  coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   
#   # if there are no coordinates - skip to the next zws record
#    if(is.na(coordinates$lon)) {
#      cat(i, "No Coordinates\r")
#    next
#  }
#   
#   # Calculate a 20 minute walking time isochrone around the store
#  walktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                               output = "sf", profile = ors_profile("walking"))
#  values <- levels(factor(walktime20$value))
#  ranges <- split(walktime20, values)
#  ranges <- ranges[rev(values)]
#  names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
# #################################################################################### TEST PLOT THE ISOCHRONE
#  # ggplot(walktime20) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = geometry), alpha = 0.1) +
#  #   geom_sf(data = isodf, aes(geometry = geometry))
# # THIS WORKED 
# ###################################################################################
#   # Convert the walktime20 isochrone to the correct CRS
#   # USE THIS AS THE ISOCHRONE
#   # rename the walktime20 geometry column
#  walktime20 <- walktime20  |>  rename_at('geometry', ~'isogeometry')
# 
#   # Join the calculated walktime 20 data to the zws data in isodf
#  zwsisoc <- cbind(isodf, walktime20)
#  # rename the geometry column
#  zwsisoc <- zwsisoc  |>  rename_at('geometry', ~'zwsgeometry')
#  zwsiso = zwsiso <- rbind(zwsiso, zwsisoc)
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
# # ggplot(zwsiso) +
# #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #    geom_sf(aes(geometry = zwsgeometry)) +
# #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# ###################################################################################   # print i as a count of rows that have completed
#  cat(i, "completed\r")
#   
# # remove the temporary environments
#  remove(coordinates, isodf, ranges, values, walktime20, zwsisoc)
#  Sys.sleep(3)
# }
# # Save the zwsiso file
# saveRDS(obj = zwsiso, file = "zwsiso.rds")
# 
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
#  # ggplot(zwsiso[97,]) +
#  #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #    geom_sf(aes(geometry = zwsgeometry)) +
#  #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# #################################################################################
# remove(coordinates, i, isodf, zws)
```

```{r zws_scr_loop}
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

# # Loop through each store to find the pwcs in zwsiso$walktimegeometry
# # Find all the LSOAs related to those PWCs
# # Get the scores for each LSOA
# # Add the scores and the joined LSOA geometry to the [i] row for that store
# 
# # Load the data required
# lsoa_pwc <- readRDS("lsoa_pwc.rds")
# 
# lsoas <- readRDS("lsoas.rds")
# # convert to sf
# 
# lsoas = st_as_sf(lsoas)
# zwsiso <- readRDS("zwsiso.rds")
# 
# # Create a dataframe to hold all the joined results
# zws_joined_lsoa_scr <- data.frame(matrix(ncol = 16, nrow = 0))
# 
# #initialise i
# i = 0
# i = i + 1
# for (i in 1:nrow(zwsiso)) {
# 
# a = zwsiso[i,]
#   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
# # get all the pwcs that appear in the iso for that store
# a <- a  |>  rename_at('isogeometry', ~'geometry')
# a = st_transform(a$geometry, crs = st_crs(3857)) 
# 
# # st_geometry(b) <- "geometry"
# b = lsoa_pwc[a,]
#   
#   # Check if (a) has 0 rows. If so, sack it off and move to the next record
#  if(nrow(b) == 0) {
#    next
#  }
#   
#   # Convert a to a dataframe to manipulate it
#   b = as.data.frame(b)
#   
#   # Get all the lsoas that relate to the pwcs just found
#   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
#   
#   #convert b to a dataframe
#   c = as.data.frame(c)
#   
# ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
#   c <- c |>
#    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
#                        across(where(is.character), ~'Total')))
#   
#   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# 
#   # convert b to sf format
#   c = st_as_sf(c)
#   
# ###################################################################################
# # TEST PLOT
# # ggplot(c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# #THIS WORKED
# ################################################################################### 
#   # Join the lsoas together
#  joined_lsoas <- st_union(c$lsoageometry)
#   
# ###################################################################################
# # TEST PLOT
#  # ggplot(joined_lsoas) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   ## Create a new dataframe for the joined data
#   joined_lsoas = st_as_sf(joined_lsoas)
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
#   
#   # combine the joined lsoa data and the score data
#   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
#   #remove the empty multipolyon column
#   joined_lsoas_c = joined_lsoas_c |> select(-one_of('lsoageometry'))
#   # rename the x column to "joinedlsoageom"
#   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas_c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   # retrieve the store name from zwsiso
#   d = zwsiso[i,]
# 
#    # Join the store name and the scores and the joined LSOA geometry and the walktime geometry
#  e = cbind(d, joined_lsoas_c)
# ###################################################################################
# # TEST PLOT
# # ggplot(e) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################  
#   # add this to a row in a new dataframe
#   zws_joined_lsoa_scr <- rbind(zws_joined_lsoa_scr, e)
# 
#   # remove the temporary dataframes sf files etc 
#  remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# 
# ###################################################################################
# # TEST PLOT
# #ggplot(zws_joined_lsoa_scr) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################
#   # Print (i) as a counter
#   cat(i, "completed\r")
# }
# # clean the zws_joined_lsoa_scr names and columns
# # Round the scores to the nearest whole number
# zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# 
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(zws_joined_lsoa_scr[93,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom, alpha = lsoatotscr))
# # THIS WORKED
# ###################################################################################
# # Set the active geometry column
# # st_geometry(zws_joined_lsoa_scr) <- "isogeometry"
# # zws_joined_lsoa_scr
# # 
# # 
# # remove(a, zwsiso)
# # Save the zws_joined_lsoa_scr data
# #remove the errors
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr[-c(82), ]
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <-  as.data.frame(readRDS("zws_joined_lsoa_scr.rds"))
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr  |>  rename_at(21, ~'retail_centre_class')
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr  |>  rename_at(22, ~'joinedlsoageom')
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
```

\FloatBarrier

```{r all_zws_scr_table, echo=FALSE}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
my_theme = readRDS("my_theme.rds")
a = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[1:5, c(2, 12:17)]))
kable(a, caption = "\\label{tab:allzwsscrtable}Scorecard table for first 5 zero waste stores")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |>
  column_spec(1,width = "2in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.5in") |>
  column_spec(4,width = "0.5in") |>
  column_spec(5,width = "0.5in") |>
  column_spec(6,width = "0.5in") |>
  column_spec(7,width = "0.5in")

remove(a, zws_joined_lsoa_scr, my_theme)
```

\FloatBarrier

Using the final store scorecards, a summary table and correlation plot were produced. See figure \ref{fig:corr_plot} for the correlation plot and \ref{tab:zws_scrsummary} for the summary table.

```{r corr_plot, fig.height=4.5, fig.width=4.5, fig.cap="Plot showing correlations between total scores and the 5 variables for the stores data."}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
a_cor = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[,c(17,12:16)]))
cor_plot <- plot(a_cor, cex = 0.3,
     col = grey(0.145,alpha=0.5), upper.panel=panel.smooth)
remove(a_cor, zws_joined_lsoa_scr, cor_plot)
```

\FloatBarrier

```{r zws_scrsums_tab, echo=FALSE}
scrs_summary <- readRDS("scrs_summary.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# my_theme = readRDS("my_theme.rds")
# scrs_summary <- scrs_summary[-c(1:nrow(scrs_summary)), ]
# scrs_summary <- data.frame(matrix(ncol = 0, nrow = 0))
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(zws_joined_lsoa_scr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. stores')
# c = as.data.frame(t(c))
# scrs_summary = as.data.frame(t(scrs_summary))
# c = as.data.frame(t(c))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, c)
# #
# ## dedrank summary
# d  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(zws_joined_lsoa_scr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. stores')
# d = as.data.frame(t(d))
# scrs_summary = as.data.frame(t(scrs_summary))
# d = as.data.frame(t(d))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, d)
# #
# ## occrank summary
# o  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(zws_joined_lsoa_scr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. stores')
# o = as.data.frame(t(o))
# scrs_summary = as.data.frame(t(scrs_summary))
# o = as.data.frame(t(o))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, o)
# #
# ## pplrank summary
# p  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(zws_joined_lsoa_scr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. stores')
# p = as.data.frame(t(p))
# scrs_summary = as.data.frame(t(scrs_summary))
# p = as.data.frame(t(p))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, p)
# #
# ## tenrank summary
# t  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(zws_joined_lsoa_scr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. stores')
# t = as.data.frame(t(t))
# scrs_summary = as.data.frame(t(scrs_summary))
# t = as.data.frame(t(t))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, t)
# 
# 
# # lsoatotscr summary
# l  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(zws_joined_lsoa_scr), l)
# l <- l  |>  rename_at('l', ~'lsoa total score summary value')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. stores')
# l = as.data.frame(t(l))
# scrs_summary = as.data.frame(t(scrs_summary))
# l = as.data.frame(t(l))
# scrs_summary = as.data.frame(t(scrs_summary))
# scrs_summary = rbind(scrs_summary, l)
# saveRDS(object = scrs_summary, file = "scrs_summary.rds")
# 
# remove(a, c, d, o, p, t, l)

kable(scrs_summary, caption = "\\label{tab:zws_scrsummary}Scorecard summary table for all zero waste stores.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(zws_joined_lsoa_scr, a, c, d, o, p, t, scrs_summary, my_theme)
```

\FloatBarrier

Distribution histograms for the stores and retail centres was also produced (see figure \ref{fig:zw_scrs_hists})

\FloatBarrier

```{r theme_setup}
# my_theme = theme(axis.text = element_text(size = 6), axis.title = element_text(size = 8))
# saveRDS(object = my_theme, file = "my_theme.rds")
```

```{r zw_scrs_hists, fig.cap="Histograms showing individual variable mean scores for all zero waste stores.", fig.width = 5, fig.height = 4}
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# my_theme = readRDS("my_theme.rds")
# # nrow(zws_joined_lsoa_scr)
# 
# zwh1 <- ggplot(zws_joined_lsoa_scr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh2 <- ggplot(zws_joined_lsoa_scr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh3 <- ggplot(zws_joined_lsoa_scr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh4 <- ggplot(zws_joined_lsoa_scr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh5 <- ggplot(zws_joined_lsoa_scr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# zwh6 <- ggplot(zws_joined_lsoa_scr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# # Add the histograpms to a plot list
# zwh_plot_list <- list(zwh1, zwh2, zwh3, zwh4, zwh5, zwh6)
# saveRDS(object = zwh_plot_list, file = "zwh_plot_list.rds")
# remove(zwh1, zwh2, zwh3, zwh4, zwh5, zwh6)
# Plot them together in a grid
zwh_plot_list <- readRDS("zwh_plot_list.rds")
my_theme <- readRDS("my_theme.rds")
do.call("grid.arrange", c(zwh_plot_list, ncol = 3))
remove(zwh_plot_list, zws_joined_lsoa_scr, my_theme)
```

\FloatBarrier

```{r zws_rc_dist_table, echo=FALSE, fig.cap="Histogram of distribution of retail centres where stores are located."}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
my_theme = readRDS("my_theme.rds")
a = a <- as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[, 21]))
a <- a  |>  rename_at(1, ~'zws_rc_class')

ggplot(a) +
  geom_bar(aes(a$zws_rc_class), colour = "orange", fill = "darkgrey") +
  scale_x_discrete(guide = guide_axis(n.dodge=2)) +
  labs(x = "ZWS Retail centre classification", y = "Count of zero-waste store Retail Centres (n = 128)") +
  my_theme
```

\FloatBarrier

Table \ref{tab:minmaxstore_tab} shows the scorecards for the stores that had the lowest and highest scores of all stores.

\FloatBarrier

```{r min_max_store_tab}
# # Load the data to be used
minmaxstr <- readRDS("minmaxstr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# # my_theme = readRDS("my_theme.rds")
# # Get the store(s) with the lowest score
# minstore = zws_joined_lsoa_scr[which.min(zws_joined_lsoa_scr$lsoatotscr), ]
# # Save this for future reference
# saveRDS(object = minstore, file = "minstore.rds")
# 
# # prepare it for the table
# minstore =  as.data.frame(minstore[,c(2,3,12:17)])
# minstore = st_as_sf(minstore)
# minstore = st_drop_geometry(minstore)
# 
# # Get the store(s) with the highest score
# maxstore = zws_joined_lsoa_scr[which.max(zws_joined_lsoa_scr$lsoatotscr), ]
# # Save this for future reference
# saveRDS(object = maxstore, file = "maxstore.rds")
# 
# # Prepare it for the table
# maxstore =  as.data.frame(maxstore[,c(2,3,12:17)])
# maxstore = st_as_sf(maxstore)
# maxstore = st_drop_geometry(maxstore)
# 
# # Combine them ready for kable table
# minmaxstr <- rbind(maxstore, minstore)
# 
# # Save this for future reference
# saveRDS(object = minmaxstr, file = "minmaxstr.rds")

# Show the table for the 2 stores
kable(minmaxstr, row.names = F, caption = "\\label{tab:minmaxstore_tab}Summary table for zero waste store(s) with highest and lowest scores.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |> 
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.8in") |>
  column_spec(3,width = "0.8in") |>
  column_spec(4,width = "0.8in") |>
  column_spec(5,width = "0.8in") |>
  column_spec(6,width = "0.8in")

# clean the dataframes from the environment
remove(zws_joined_lsoa_scr, minstore, maxstore, minmaxstr, my_theme)
```

\FloatBarrier

These were then produced as histograms to easier visualise and compare the individual and total scores (See figure \ref{fig:minmaxcomp_plot}).

\FloatBarrier

```{r minmaxcomp_plot, fig.cap="Histograms showing the comparison between highest and lowest scoring stores variables and total scores"}
minstore <- readRDS("minstore.rds")
maxstore <- readRDS("maxstore.rds")
# create the dataframe for the plottble scores
minstr <- as.data.frame(minstore[,c(2,12:17)])
# change the data from wide to long
plotminstr <- gather(minstr, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)

# create the dataframe for the plottble scores
maxstr <- as.data.frame(maxstore[,c(2,12:17)])
# change the data from wide to long
plotmaxstr <- gather(maxstr, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)

# bind them together
plotcompare <- rbind(plotminstr, plotmaxstr)
# rename the columns
plotcompare <- plotcompare  |> dplyr::rename_at('st_nam', ~'Store_Name')

saveRDS(object = plotcompare, file = "plotcompare.rds")

# Load the data
plotcompare <- readRDS("plotcompare.rds")

# Plot it as a comparison
ggplot(plotcompare, aes(x = Store_Name, y= score, fill = variable)) +
  geom_histogram(stat="identity", width=0.9, position = "dodge") +
  scale_fill_brewer(palette="Dark2", name = "Variables (0-10)\n& total (0-50)", labels = c("Single vehicle access", "Degree education level", "Occupation type", "Two person household\nwith 0 children", "Home-ownership", "LSOA total score")) +
  xlab("Store Name") +
  scale_y_continuous(name="Score", breaks = seq(0, 50, by = 5), limits = c(0,50)) +
  geom_text(
    aes(label = score),
    position = position_dodge(0.9),
    vjust = -0.2,
    size = 3)

remove(maxstore, maxstr, minstore, minstr, plotmaxstr, plotminstr, plotcompare)
remove(b, i, joined_rc_results, lsoa_in_rciso, lsoa_pwc, lsoas, pwc_in_rciso, rc_joined_lsoa_scr)
```

\FloatBarrier

Maps were produced to help visualise the similarities and differences between the locations and surroundings of both stores (see figure \ref{fig:maxstr_map} and \ref{fig:minstr_map}), any associated retail centre, catchment area, and scorecard for the store with the highest score.

\FloatBarrier

```{r maxstr_map, fig.height=4, fig.width=5, warning=FALSE, fig.cap="Map showing the store with the highest value scorecard and the variable averages for the location."}
maxstore <- readRDS("maxstore.rds")
rcmaxstr <- readRDS("rcmaxstr.rds")
maxstoremap <- 
  ggplot(maxstore) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
    geom_sf(data = rcmaxstr, aes(geometry = geometry, shape = rcmaxstr$Classifica), alpha = 0.1, colour = "blue") +
  guides(shape = guide_legend(title = "RC Classification", reverse = TRUE)) +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "red") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = maxstore$geometry, fill = maxstore$lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = st_nam)) +
  guides(colour = guide_legend(title = str_wrap("Store name", width = 15), reverse = TRUE)) +
  #   # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", 
  #                        which_north = "true", 
  #                        pad_x = unit(0.1, "in"), 
  #                        pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 10)

maxvarhead <- 
  ggplot(maxstore) + 
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

maxcarscr <-
  ggplot(maxstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

maxdedscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

maxoccscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxpplscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxtenscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void(margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"))

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = maxstoremap,
           B = maxvarhead,
           C = maxcarscr,
           D = maxdedscr,
           E = maxoccscr,
           F = maxpplscr,
           G = maxtenscr,
           design = layout)

remove(rcmaxstr,maxstore, maxstoremap, maxvarhead, maxcarscr, maxdedscr, maxoccscr, maxpplscr, maxtenscr, layout)
```

\FloatBarrier

```{r minstr_map, fig.height=4, fig.width=5, warning=FALSE, fig.cap="Map showing the store with the lowest value scorecard, and the variable averages for the location."}
rcminstr <- readRDS("rcminstr.rds")
minstore <- readRDS("minstore.rds")
minstoremap <- ggplot(minstore) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "red") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = minstore$geometry, fill = lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = st_nam)) +
  guides(colour = guide_legend(title = str_wrap("Store name", width = 15), reverse = TRUE)) +
    geom_sf(data = rcminstr, aes(geometry = geometry, shape = rcminstr$Classifica), alpha = 0.1, colour = "blue") +
  guides(shape = guide_legend(title = "RC Classification", reverse = TRUE)) +
  theme_void()

minvarhead <-
  ggplot(minstore) +
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

mincarscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void(margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"))

mindedscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

minoccscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

minpplscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

mintenscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void(base_size = 8)

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = minstoremap,
           B = minvarhead,
           C = mincarscr,
           D = mindedscr,
           E = minoccscr,
           F = minpplscr,
           G = mintenscr,
           design = layout)
remove(rcminstr, minstore, minstoremap, minvarhead, mincarscr, mindedscr, minoccscr, minpplscr, mintenscr, layout)
```

\FloatBarrier

### Processing the retail centres

The final scorecards for the stores were used to identify the most suitable potential retail centre(s) that were not already supplied by a zero-waste store.

As before, isochrones were calculated, and those that contained a store were filtered out, leaving only those centres without a store located within them. PWC were identified and filtered, the relevant LSOA data was retrieved, and scorecards for each were produced.

\FloatBarrier

```{r rc_iso_additional}
# Load the data
# all_rcs <- readRDS("all_rcs.rds")
# 
# # Get the isochrones for the retail centres
# all_rcs$centoidgeom <-  st_point_on_surface(all_rcs$geometry)
# 
# # Transform the CRS 
# all_rcs = st_transform(all_rcs, crs = st_crs(3857))
# saveRDS(object = all_rcs, file = "all_rcs.rds")
# remove(all_rcs)

###################################################################################
# ggplot(all_rcs[5825,]) +
#   annotation_map_tile(zoomin = 1, type = "hotstyle") +
#   geom_sf(aes(geometry = geometry), colour = "red", alpha = 0.1) +
#   geom_sf(aes(geometry = centoidgeom), colour = "blue")
###################################################################################

# RE-DO THE RETAIL CENTRE ISOCHRONES

# SPLIT THE ALL_RCS FILE IN TO 3 (2500, 2500, 1423)
# rca <- all_rcs[1:2500,]
# saveRDS(object = rca, file = "rca.rds")


# rcb <- all_rcs[2501:5000,]
# saveRDS(object = rcb, file = "rcb.rds")

# rcc <- all_rcs[5001:6423,]
# saveRDS(object = rcc, file = "rcc.rds")

# remove(all_rcs, rca, rcb, rcc)

# rca <- readRDS("rca.rds")
# rcaa <- rca[500:2500,]
# saveRDS(object = rcaa, file = "rcaa.rds")


# rcb <- all_rcs[2501:5000,]
# saveRDS(object = rcb, file = "rcb.rds")
# rcc <- all_rcs[5001:6423,]
# saveRDS(object = rcc, file = "rcc.rds")
# remove(all_rcs, rca, rcb, rcc)
# rca <- readRDS("rca.rds")


# rc_final_results <- readRDS("rc_final_results.rds")

# # convert rciso to crs 4326
# #rciso <- st_transform(rciso, crs = st_crs(4326))
# # convert retail_c to crs 3857
# #rciso <- st_transform(rciso, crs = st_crs(3857))
# 
# 
# # Change the name of the centre column to make it identifiable
# # rca_results <- rca_results  |>  rename_at('center', ~'rcisocenter')
# 
# # remove the temporary dataframes
# remove(i)
# # save the rc_results and the rc_(x) files as RDS files
# saveRDS(obj = rc_a, file = "rc_a.rds")
# saveRDS(obj = rca_results, file = "rca_results.rds")
# remove(i)
# ###################################################################################
# # PROCESS THE RC_B FILE
# ###################################################################################
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_b)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_b[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_b, file = "rc_b.rds")
# saveRDS(obj = rcb_results, file = "rcb_results.rds")
# remove(i)
# 
# ###################################################################################
# ###################################################################################
# # PROCESS THE RC_C FILE
# ###################################################################################
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_c)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_c[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_c, file = "rc_c.rds")
# saveRDS(obj = rcc_results, file = "rcc_results.rds")
# remove(i)
# ###################################################################################
# ###################################################################################
# ###################################################################################
# # Convert all the geometries to work properly
# # load rca_results
# rca_results <- readRDS("rca_results.rds")
# a = as.data.frame(rca_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # Save a to rc_final_results
# rc_final_results <- a
# 
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcb_results <- readRDS("rcb_results.rds")
# a = as.data.frame(rcb_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[2,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # add the data to the final dataframe
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcc_results <- readRDS("rcc_results.rds")
# a = as.data.frame(rcc_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,21)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,26)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# 
# 
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'fid.1', 'RC_ID.1', 'RC_Name.1', 'Classifica.1', 'Country.1', 'Region_NM.1', 'H3_count.1', 'Retail_N.1', 'Area_km2.1', 'value', 'isodf.RC_ID'))
# # make sure the columns in a are in the same order as rc_final_results
# a <- a |> relocate(group_index, .before = rcgeometry)
# a <- st_as_sf(a)
# ###################################################################################
# # Fix the CRS of a
# # Try to fix zws_joined_lsoa_scr.rds geometries
# b = a[,c(1,10)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ###################################################################################
# # remove(rc_final_results)
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# b = rc_final_results[,c(13)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# rc_final_results$rcwalktime = b$rcwalktime
# 
# b = rc_final_results[,c(12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rccentroidgeom = b$rccentroidgeom
# 
# b = rc_final_results[,c(11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rcgeometry = b$rcgeometry
# 
# 
# ##################################################################################
# # TEST PLOT rc_final_results
# # ggplot(rc_final_results[2,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "blue")
# # THIS WORKED
# saveRDS(obj = rc_final_results, file = "rc_final_results.rds")
# ###################################################################################
# ###################################################################################
# # Remove unwanted dataframes and sf files
# remove(a, b, c, rc_a, rc_b, rc_c, rc_results, rca_results, rcb_results, rcc_results)
# ################################################################################
```

```{r rc_iso_calc}
# rc_final_results <- readRDS("rc_final_results.rds")
###################################################################################
# # RC ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# #### Process rc_a
# rca_results <- data.frame(matrix(ncol = 18, nrow = 0))
# 
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_a)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_a[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rca_results <- rbind(rca_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# # convert rciso to crs 4326
# #rciso <- st_transform(rciso, crs = st_crs(4326))
# # convert retail_c to crs 3857
# #rciso <- st_transform(rciso, crs = st_crs(3857))
# 
# 
# # Change the name of the centre column to make it identifiable
# # rca_results <- rca_results  |>  rename_at('center', ~'rcisocenter')
# 
# # remove the temporary dataframes
# remove(i)
# # save the rc_results and the rc_(x) files as RDS files
# saveRDS(obj = rc_a, file = "rc_a.rds")
# saveRDS(obj = rca_results, file = "rca_results.rds")
# remove(i)
# ###################################################################################
# # PROCESS THE RC_B FILE
# ###################################################################################
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_b)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_b[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_b, file = "rc_b.rds")
# saveRDS(obj = rcb_results, file = "rcb_results.rds")
# remove(i)
# 
# ###################################################################################
# ###################################################################################
# # PROCESS THE RC_C FILE
# ###################################################################################
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_c)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_c[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_c, file = "rc_c.rds")
# saveRDS(obj = rcc_results, file = "rcc_results.rds")
# remove(i)
# ###################################################################################
# ###################################################################################
# ###################################################################################
# # Convert all the geometries to work properly
# # load rca_results
# rca_results <- readRDS("rca_results.rds")
# a = as.data.frame(rca_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # Save a to rc_final_results
# rc_final_results <- a
# 
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcb_results <- readRDS("rcb_results.rds")
# a = as.data.frame(rcb_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[2,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # add the data to the final dataframe
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcc_results <- readRDS("rcc_results.rds")
# a = as.data.frame(rcc_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,21)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,26)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# 
# 
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'fid.1', 'RC_ID.1', 'RC_Name.1', 'Classifica.1', 'Country.1', 'Region_NM.1', 'H3_count.1', 'Retail_N.1', 'Area_km2.1', 'value', 'isodf.RC_ID'))
# # make sure the columns in a are in the same order as rc_final_results
# a <- a |> relocate(group_index, .before = rcgeometry)
# a <- st_as_sf(a)
# ###################################################################################
# # Fix the CRS of a
# # Try to fix zws_joined_lsoa_scr.rds geometries
# b = a[,c(1,10)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ###################################################################################
# # remove(rc_final_results)
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# b = rc_final_results[,c(13)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# rc_final_results$rcwalktime = b$rcwalktime
# 
# b = rc_final_results[,c(12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rccentroidgeom = b$rccentroidgeom
# 
# b = rc_final_results[,c(11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rcgeometry = b$rcgeometry
# 
# 
# ##################################################################################
# # TEST PLOT rc_final_results
# # ggplot(rc_final_results[2,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "blue")
# # THIS WORKED
# saveRDS(obj = rc_final_results, file = "rc_final_results.rds")
# ###################################################################################
# ###################################################################################
# # Remove unwanted dataframes and sf files
# remove(a, b, c, rc_a, rc_b, rc_c, rc_results, rca_results, rcb_results, rcc_results)
# ###################################################################################
```

```{r rca_isocalc, echo = FALSE}
###################################################################################
# # RCAA ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# # RC ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# remove(i)
# 
# rca_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rca)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rca[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rca_results <- rbind(rca_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = 1:499 inclusive (499)
# saveRDS(object = rca_results, file = "rca_results.rds")
# rca_results = 500:2500 inclusive (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")
```

```{r rcaa_isocalc, echo=FALSE}
###################################################################################
# # RCAA ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# remove(i)
# 
# rcaa <- readRDS("rcaa.rds")
# # #### Process rcaa
# rcaa_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcaa)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcaa[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcaa_results <- rbind(rcaa_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = 1:499 inclusive (499)
# saveRDS(object = rca_results, file = "rca_results.rds")
# rca_results = 500:2500 inclusive (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")
```

```{r rcbb_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcbb <- readRDS("rcbb.rds")
# # #### Process rcaa
# rcbb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcbb)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcbb[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcbb_results <- rbind(rcbb_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = (499)
# saveRDS(object = rca_results, file = "rca_results.rds")

# rca_results = (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")

# rcbb_results = (498)
# saveRDS(object = rcbb_results, file = "rcbb_results.rds")

# rcb_results = (2002)
# saveRDS(object = rcb_results, file = "rcb_results.rds")
```

```{r rcb_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)
# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcb <- readRDS("rcb.rds")
# # remove(rcb)
# # #### Process rcaa
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcb)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcb[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert  to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rca_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcb_results = (2002)
# saveRDS(object = rcb_results, file = "rcb_results.rds")
# remove(rcb)
# rcc_results = (1423)
# saveRDS(object = rcc_results, file = "rcc_results.rds")
```

```{r rcc_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")
# rcb <- rbind(rcb, rcc)
# rcc <- rcb[2501:2925,]
# # # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcc$RC_ID,]
# saveRDS(object = rcc, file = "rcc.rds")
# saveRDS(object = rcb, file = "rcb.rds")
###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcc <- readRDS("rcc.rds")
# # #### Process rcaa
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcc)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcc[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rcaa_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcb_results = (2500)
# # saveRDS(object = rcb_results, file = "rcb_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcc_results = (425)
# saveRDS(object = rcc_results, file = "rcc_results.rds")
# remove(rcc)
# rccc_results = (500)
# saveRDS(object = rccc_results, file = "rccc_results.rds")
```

```{r rccc_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")
# rccc <- rcc[924:1423,]
# # Remove the rows from rcc found in rccc
# rcc <- rcc[!rcc$RC_ID %in% rccc$RC_ID,]
# saveRDS(object = rccc, file = "rccc")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# # rcc <- readRDS("rcc.rds")
# # #### Process rcaa
# rccc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rccc)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rccc[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rccc_results <- rbind(rccc_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rca_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcb_results = (2002)
# # saveRDS(object = rcb_results, file = "rcb_results.rds")
# 
# # rcc_results = (1423)
# saveRDS(object = rccc_results, file = "rccc_results.rds")
# # remove(rccc)
```

\FloatBarrier

Table \ref{tab:rc_scrs_summary} shows the summary data for all retail centre scorecards.

```{r rc_scrsums_tab}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
rc_scrs_summary <- readRDS("rc_scrs_summary.rds")
# totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_joined_lsoa_scr), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total score summary value')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_scrs_summary <- data.frame(matrix(ncol = 7, nrow = 0))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# l = as.data.frame(t(l))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_joined_lsoa_scr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# c = as.data.frame(t(c))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_joined_lsoa_scr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# d = as.data.frame(t(d))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_joined_lsoa_scr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# o = as.data.frame(t(o))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_joined_lsoa_scr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# p = as.data.frame(t(p))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_joined_lsoa_scr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# t = as.data.frame(t(t))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, t)
# saveRDS(object = rc_scrs_summary, file = "rc_scrs_summary.rds")

kable(rc_scrs_summary, caption = "\\label{tab:rc_scrs_summary}Scorecard summary table for all retail centres.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary)
```

\FloatBarrier

Comparative histograms (see figure \ref{fig:rcminmax_hists}) were then produced to visualise the RC with the lowest and highest scores.

```{r rcminmax_hists, fig.cap="Histogram comparing the retail centres with the lowest and highest scorecard total value", fig.height=4, fig.width=7, warning=FALSE}
rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
rc_scrs_summary <- readRDS("rc_scrs_summary.rds")

# Get the retail centre(s) with the lowest score
rcmin = rc_joined_lsoa_scr[which.min(rc_joined_lsoa_scr$lsoatotscr), ]
# Get the retail centre(s) with the highest score
rcmax = rc_joined_lsoa_scr[which.max(rc_joined_lsoa_scr$lsoatotscr), ]

# create the dataframe for the plottble scores
rcmin <- as.data.frame(rcmin[,c(2,3,10:15)])
# change the data from wide to long
plotminrc <- gather(rcmin, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)

# create the dataframe for the plottble scores
rcmax <- as.data.frame(rcmax[,c(2,3,10:15)])
# change the data from wide to long
plotmaxrc <- gather(rcmax, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)

# bind them together
rcplotcompare <- rbind(plotminrc, plotmaxrc)
# rename the columns
rcplotcompare <- rcplotcompare  |> dplyr::rename_at('RC_Name', ~'Retail_Centre_Name')
saveRDS(object = rcplotcompare, file = "rcplotcompare.rds")
rcplotcompare <- readRDS("rcplotcompare.rds")

ggplot(rcplotcompare, aes(x = Retail_Centre_Name, y= score, fill = variable)) +
  geom_histogram(stat="identity", width=0.9, position = "dodge") +
  scale_fill_brewer(palette="Dark2", name = "Variables (0-10)\n& total (0-50)", labels = c("Single vehicle access", "Degree education level", "Occupation type", "Two person household\nwith 0 children", "Home-ownership", "LSOA total score")) +
  xlab("Retail Centre Name") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 30)) +
  scale_y_continuous(name="Score", breaks = seq(0, 50, by = 5), limits = c(0,50)) +
  geom_text(
    aes(label = score),
    position = position_dodge(0.9),
    vjust = -0.2,
    size = 3)

remove(plotmaxrc, plotminrc, rc_joined_lsoa_scr, rc_scrs_summary, rcmax, rcmin, rcplotcompare)
```

\FloatBarrier

Distributions of all retail centre scores were then visualised using distribution histograms (see figure \ref{fig:all_rc_hists}).

```{r all_rc_hists, fig.cap="Histograms showing distributions for individual variable scores for all retail centres.", fig.width = 5, fig.height = 4}
# ###################################################################################
# All rc_total scores
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# rc_hist1 <- ggplot(rc_joined_lsoa_scr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rc_hist2 <- ggplot(rc_joined_lsoa_scr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist3 <- ggplot(rc_joined_lsoa_scr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist4 <- ggplot(rc_joined_lsoa_scr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist5 <- ggplot(rc_joined_lsoa_scr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist6 <- ggplot(rc_joined_lsoa_scr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# plot_list_rchist <- list(rc_hist1, rc_hist2, rc_hist3, rc_hist4, rc_hist5, rc_hist6)
# saveRDS(object = plot_list_rchist, file = "plot_list_rchist.rds")
# remove(rc_hist1, rc_hist2, rc_hist3, rc_hist4, rc_hist5, rc_hist6)
plot_list_rchist <- readRDS("plot_list_rchist.rds")
do.call("grid.arrange", c(plot_list_rchist, ncol = 3))
remove(plot_list_rchist, rc_joined_lsoa_scr)
```

\FloatBarrier

The number of retail centres were then narrowed down to identify those that would be the potential optimal location(s) for new zero-waste stores.

Firstly, those retail centres that scored a total that fell within the full range of store scores were identified, and distributions were visualised through a summary table (see table \ref{tab:rc_zwsmm_scrs_summary}) and distribution histograms (figure \ref{fig:rc_minmax_hists}).

```{r rc_eq_zws_minmax_tab, echo=FALSE}
# Load the data
# zws_joined_lsoa_scr <- as.data.frame(readRDS("zws_joined_lsoa_scr.rds"))
# rc_joined_lsoa_scr <- as.data.frame(readRDS("rc_joined_lsoa_scr.rds"))
# rc_in_zws_mm <- readRDS("rc_in_zws_mm.rds")
rc_in_zws_mm_summary <- readRDS("rc_in_zws_mm_summary.rds")
# zwsmeans <- as.data.frame(readRDS("zwsmeans.rds"))
# allmatches <- as.data.frame(readRDS("allmatches.rds"))

# # totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_in_zws_mm$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_in_zws_mm), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nsit within the ZWS  range.')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_in_zws_mm_summary <- data.frame(matrix(ncol = 6, nrow = 0))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# l = as.data.frame(t(l))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_in_zws_mm$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_in_zws_mm), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# c = as.data.frame(t(c))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_in_zws_mm$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_in_zws_mm), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# d = as.data.frame(t(d))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_in_zws_mm$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_in_zws_mm), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# o = as.data.frame(t(o))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_in_zws_mm$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_in_zws_mm), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# p = as.data.frame(t(p))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_in_zws_mm$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_in_zws_mm), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# t = as.data.frame(t(t))
# rc_in_zws_mm_summary = as.data.frame(t(rc_in_zws_mm_summary))
# rc_in_zws_mm_summary = rbind(rc_in_zws_mm_summary, t)
# saveRDS(object = rc_in_zws_mm_summary, file = "rc_in_zws_mm_summary.rds")
# 
kable(rc_in_zws_mm_summary, caption = "\\label{tab:rc_zwsmm_scrs_summary}Scorecard summary table for all retail centres with total scores that sit within the zero-waste store total score range.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, rc_zwsiqr_scrs_summary, rc_in_zws_iqr)
```

\FloatBarrier

```{r rc_minmax_hists, fig.height=5, fig.width=5, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that falls within the minimum and maximum score range for the zero waste stores.", echo=FALSE}
# my_theme = readRDS("my_theme.rds")
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# # rc_in_zws_mm <- readRDS("rc_in_zws_mm.rds")
# ###################################################################################
# # Using the range min-max
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (min(zws_joined_lsoa_scr$lsoatotscr)) & rc_joined_lsoa_scr$lsoatotscr <= (max(zws_joined_lsoa_scr$lsoatotscr))
# #
# rc_in_zws_mm <- subset(rc_joined_lsoa_scr, identify_rows)
# remove(identify_rows)
# #
# rcm1 <- ggplot(rc_in_zws_mm, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm2 <- ggplot(rc_in_zws_mm, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm3 <- ggplot(rc_in_zws_mm, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm4 <- ggplot(rc_in_zws_mm, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm5 <- ggplot(rc_in_zws_mm, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm6 <- ggplot(rc_in_zws_mm, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# #
# plot_list_minmax <- list(rcm1, rcm2, rcm3, rcm4, rcm5, rcm6)
# saveRDS(object = plot_list_minmax, file = "plot_list_minmax.rds")
# remove(rcm1, rcm2, rcm3, rcm4, rcm5, rcm6)
plot_list_minmax <- readRDS("plot_list_minmax.rds")
do.call("grid.arrange", c(plot_list_minmax, ncol = 3))
remove(plot_list_minmax, rc_joined_lsoa_scr, rc_in_zws_mm, rc_in_zws_mm_summary, zws_joined_lsoa_scr, my_theme, rcm1, rcm2, rcm3, rcm4, rcm5, rcm6, zws_joined_lsoa_scr)
```

\FloatBarrier

The interquartile range of the stores total scores was used to narrow the retail centres down further. See table \ref{tab:rc_zwsiqr_scrs_summary} for a summary, and figure \ref{fig:rc_iqr_hists} for distributions.

```{r rc_zwiqrsummary_tab}
# Load the data
# rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
# rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
# rc_in_zws_iqr <- readRDS("rc_in_zws_iqr.rds")
rc_zwsiqr_scrs_summary <- readRDS("rc_zwsiqr_scrs_summary.rds")
# # totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_in_zws_iqr), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nsit within the ZWS interquartile range.')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_zwsiqr_scrs_summary <- data.frame(matrix(ncol = 6, nrow = 0))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# l = as.data.frame(t(l))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_in_zws_iqr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# c = as.data.frame(t(c))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_in_zws_iqr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# d = as.data.frame(t(d))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_in_zws_iqr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# o = as.data.frame(t(o))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_in_zws_iqr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# p = as.data.frame(t(p))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_in_zws_iqr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# t = as.data.frame(t(t))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, t)
# saveRDS(object = rc_zwsiqr_scrs_summary, file = "rc_zwsiqr_scrs_summary.rds")
# 
kable(rc_zwsiqr_scrs_summary, caption = "\\label{tab:rc_zwsiqr_scrs_summary}Scorecard summary table for all retail centres with total scores that sit within the zero-waste stores interquartile range.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, rc_zwsiqr_scrs_summary, rc_in_zws_iqr)
```

\FloatBarrier

```{r rc_iqr_hists, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that falls within the interquartile range of the zero waste stores total scores.", fig.width = 5, fig.height = 4}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

# # ###################################################################################
# # # Using the interquartile range
# # # Find the 1st and 3rd Quartiles of the zws results
# a <- data.frame(unclass(summary(zws_joined_lsoa_scr$lsoatotscr)), check.names = F)
# # # rotate the dataframe
# a = a |> rotate_df()
# # 
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (a$`1st Qu.`) & rc_joined_lsoa_scr$lsoatotscr <= (a$`3rd Qu.`)
# # 
# rc_in_zws_iqr <- subset(rc_joined_lsoa_scr, identify_rows)
# # 
# rcq1 <- ggplot(rc_in_zws_iqr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq2 <- ggplot(rc_in_zws_iqr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq3 <- ggplot(rc_in_zws_iqr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq4 <- ggplot(rc_in_zws_iqr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq5 <- ggplot(rc_in_zws_iqr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq6 <- ggplot(rc_in_zws_iqr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # 
# plot_list_iqr <- list(rcq1, rcq2, rcq3, rcq4, rcq5, rcq6)
# saveRDS(object = plot_list_iqr, file = "plot_list_iqr.rds")
# remove(rcq1, rcq2, rcq3, rcq4, rcq5, rcq6)
plot_list_iqr <- readRDS("plot_list_iqr.rds")
do.call("grid.arrange", c(plot_list_iqr, ncol = 3))
remove(plot_list_iqr, rc_joined_lsoa_scr, rc_in_zws_iqr, zws_joined_lsoa_scr, identify_rows, a)
```

\FloatBarrier

Those retail centres that scored a total that was the same as the mean for the stores total mean score (24) filtered the retail centres further (See table \ref{tab:rc_eqzws_scrs_summary} for a summary table and figure \ref{fig:rc_zws_mean_hists} for distributions).

```{r rc_eq_zw_ave_tab}
# Load the data
# # rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
#  # rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
#  zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
#  rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # # # Find and round the average zws score to the nearest while number
#  # zws_ave = round(mean(zws_joined_lsoa_scr$lsoatotscr))
# # # Identify the rows in the retail centre total score data that match the average total score for the stores data
#  # identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (zws_ave) & rc_joined_lsoa_scr$lsoatotscr <= (zws_ave)
# # # Get the rows identified as matching the zws mean score
#  rc_eq_zws_ave <- subset(rc_joined_lsoa_scr, identify_rows)
# saveRDS(object = rc_eq_zws_ave, file = "rc_eq_zws_ave.rds")
rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
remove(rc_joined_lsoa_scr, zws_joined_lsoa_scr)
# # totalscore summary
l  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$lsoatotscr)))
l = as.data.frame(l)
l = rbind(nrow(rc_eq_zws_ave), l)
l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nmatch the ZWS average score')
l = as.data.frame(t(l))
l <- l  |>  rename_at('1', ~'Total no. retail centres')
l = as.data.frame(t(l))
rc_eqzws_scrs_summary <- data.frame(matrix(ncol = 6, nrow = 0))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
l = as.data.frame(t(l))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, l)

# carrank summary
c  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$carrank)))
c = as.data.frame(c)
c = rbind(nrow(rc_eq_zws_ave), c)
c <- c  |>  rename_at('c', ~'carrank total score summary value')
c = as.data.frame(t(c))
c <- c  |>  rename_at('1', ~'Total no. retail centres')
c = as.data.frame(t(c))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
c = as.data.frame(t(c))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, c)

# dedrank summary
d  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$dedrank)))
d = as.data.frame(d)
d = rbind(nrow(rc_eq_zws_ave), d)
d <- d  |>  rename_at('d', ~'dedrank total score summary value')
d = as.data.frame(t(d))
d <- d  |>  rename_at('1', ~'Total no. retail centres')
d = as.data.frame(t(d))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
d = as.data.frame(t(d))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, d)

# occrank summary
o  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$occrank)))
o = as.data.frame(o)
o = rbind(nrow(rc_eq_zws_ave), o)
o <- o  |>  rename_at('o', ~'occrank total score summary value')
o = as.data.frame(t(o))
o <- o  |>  rename_at('1', ~'Total no. retail centres')
o = as.data.frame(t(o))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
o = as.data.frame(t(o))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, o)

# pplrank summary
p  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$pplrank)))
p = as.data.frame(p)
p = rbind(nrow(rc_eq_zws_ave), p)
p <- p  |>  rename_at('p', ~'pplrank total score summary value')
p = as.data.frame(t(p))
p <- p  |>  rename_at('1', ~'Total no. retail centres')
p = as.data.frame(t(p))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
p = as.data.frame(t(p))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, p)

# tenrank summary
t  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$tenrank)))
t = as.data.frame(t)
t = rbind(nrow(rc_eq_zws_ave), t)
t <- t  |>  rename_at('t', ~'tenrank total score summary value')
t = as.data.frame(t(t))
t <- t  |>  rename_at('1', ~'Total no. retail centres')
t = as.data.frame(t(t))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
t = as.data.frame(t(t))
rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, t)
# saveRDS(object = rc_eqzws_scrs_summary, file = "rc_eqzws_scrs_summary.rds")
# remove(c,d,l,o,p,t)

# rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
kable(rc_eqzws_scrs_summary, caption = "\\label{tab:rc_eqzws_scrs_summary}Scorecard summary table for all retail centres that total the same as the ZWS average.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave)
```

\FloatBarrier

```{r rc_zws_mean_hists, fig.height=6, fig.width=6, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that equals the mean score for the zero waste stores."}
# Find the mean total score for the zero waste stores
# Load the data required
 # zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
 # rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
 # my_theme <- readRDS("my_theme.rds")
 # plot_list_ave <- readRDS("plot_list_ave.rds")
#  rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
#  zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
#  rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # # # Find and round the average zws score to the nearest while number
#  zws_ave = round(mean(zws_joined_lsoa_scr$lsoatotscr))
#
# # # Identify the rows in the retail centre total score data that match the average total score for the stores data
#  identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (zws_ave) & rc_joined_lsoa_scr$lsoatotscr <= (zws_ave)
# #
# # # Get the rows identified as matching the zws mean score
#  rc_eq_zws_ave <- subset(rc_joined_lsoa_scr, identify_rows)
#
# rcnum = as.data.frame(nrow(rc_eq_zws_ave))
# # # Plot these distributions
#  rca1 <- ggplot(rc_eq_zws_ave, aes(x=lsoatotscr)) +
#    geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") +
#      geom_text(stat="bin", label = rcnum, vjust = -0.2, size = 3) +
#    my_theme
# # #
#  rca2 <- ggplot(rc_eq_zws_ave, aes(x=tenrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca3 <- ggplot(rc_eq_zws_ave, aes(x=pplrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca4 <- ggplot(rc_eq_zws_ave, aes(x=occrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca5 <- ggplot(rc_eq_zws_ave, aes(x=dedrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca6 <- ggplot(rc_eq_zws_ave, aes(x=carrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # # #
#  plot_list_ave <- list(rca1, rca2, rca3, rca4, rca5, rca6)
#  saveRDS(object = plot_list_ave, file = "plot_list_ave.rds")
 plot_list_ave <- readRDS("plot_list_ave.rds")
 do.call("grid.arrange", c(plot_list_ave, ncol = 3))
 remove(rca1, rca2, rca3, rca4, rca5, rca6, plotmaxrc, plotminrc, rc_eq_zws_ave, rc_joined_lsoa_scr, rc_scrs_summary, rcmax, rcmin, rcplotcompare, zws_ave, zws_joined_lsoa_scr, my_theme, plot_list_ave, identify_rows, rcnum)
```

```{r rc_scores}
# # # remove(joined_rc_results, rc_joined_lsoa_scr, rcs)
# # joined_rc_results <- readRDS("joined_rc_results.rds")
# # joined_rc_results <- joined_rc_results |> rename_at('geometry', ~'rcgeometry')
# # 
# # ##################################################################################
# # #                                                                                #
# # #          Calclate the isochrones around the retail centres without zws         #
# # #                                                                                #
# # ##################################################################################
# # # remove(i, rc_joined_lsoa_scr)
# # # # Load the data required
# # lsoa_pwc <- readRDS("lsoa_pwc.rds")
# # lsoas <- readRDS("lsoas.rds")
# # # # convert to sf
# # lsoa_pwc = st_as_sf(lsoa_pwc)
# # lsoas = st_as_sf(lsoas)
# # # 
# # # # # Find all the PWCs that appear in any of the rc_isochrones
# # st_geometry(joined_rc_results) <- "rcwalktime"
# # joined_rc_results$rcwalktime = st_transform(joined_rc_results$rcwalktime, crs = st_crs(3857))
# # joined_rc_results = st_as_sf(joined_rc_results)
# # pwc_in_rciso = lsoa_pwc[joined_rc_results$rcwalktime,]
# # # #
# # # ## # find all the pwc_in_rciso related LSOAs
# # lsoa_in_rciso = lsoas[(lsoas$LSOA21CD  %in% pwc_in_rciso$LSOA21CD),]
# # # 
# # # # Create a dataframe to hold all the joined results
# # rc_joined_lsoa_scr <- data.frame(matrix(ncol = 19, nrow = 0))
# # # 
# # # #initialise i
# # i = 0
# # i = i + 1
# # for (i in 1:nrow(joined_rc_results)) {
# # # 
# #   a = joined_rc_results[i,]
# # #   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(a) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = a$rcgeometry), alpha = 0.1, colour = "blue") +
# # # #   geom_sf(aes(geometry = a$rcwalktime), alpha = 0.1, colour = "red")
# # # #THIS WORKED
# # # ###################################################################################
# # # 
# # # # get all the pwcs that appear in the iso for that store
# # # a <- a  |>  rename_at('isogeometry', ~'geometry')
# # # a = st_transform(a$geometry, crs = st_crs(3857))
# # # 
# # # st_geometry(b) <- "geometry"
# # b = lsoa_pwc[a$rcwalktime,]
# # #   
# # #   # Check if (a) has 0 rows. If so, sack it off and move to the next record
# #  if(nrow(b) == 0) {
# #    cat(i, "..errored\r")
# #    next
# #  }
# # #   
# # #   # Convert a to a dataframe to manipulate it
# #   b = as.data.frame(b)
# # #   
# # #   # Get all the lsoas that relate to the pwcs just found
# #   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
# # #   
# # #   #convert b to a dataframe
# #   c = as.data.frame(c)
# # #   
# # # ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
# #   c <- c |>
# #    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
# #                        across(where(is.character), ~'Total')))
# # #   
# # #   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# # # 
# # #   # convert c to sf format
# #   c = st_as_sf(c)
# # #   
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(c) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# # # #THIS WORKED
# # # ################################################################################### 
# # #   # Join the lsoas together
# #   joined_lsoas <- st_union(c$lsoageometry)
# # #   
# # # ###################################################################################
# # # # TEST PLOT
# # #  # ggplot(joined_lsoas) +
# # #  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # #  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1, colour = "black")
# # # #THIS WORKED
# # # ###################################################################################
# # #   # Convert joined_lsoas to sf
# #   joined_lsoas = st_as_sf(joined_lsoas)
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(joined_lsoas) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1, colour = "blue")
# # # #THIS WORKED
# # # ###################################################################################
# # #   
# #   # combine the joined lsoa data and the score data
# #   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
# #   #remove the empty multipolyon column
# #   joined_lsoas_c = as.data.frame(joined_lsoas_c)
# #   joined_lsoas_c = joined_lsoas_c |> dplyr::select(-one_of('lsoageometry'))
# #   # rename the x column to "joinedlsoageom"
# #   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # #   # ggplot(joined_lsoas_c) +
# # #   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # #   #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1, colou = "red")
# # # #THIS WORKED
# # # ###################################################################################
# # # 
# #   # retrieve the retail center ID from rc_final_results
# #   d = joined_rc_results[i,]
# # 
# #   # Join the retail center data, the scores, the joined LSOA geometry and the walktime geometry
# #   e = cbind(d, joined_lsoas_c)
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(e) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = rcgeometry), colour = "green") +
# # # #   geom_sf(aes(geometry = rccentroidgeom), alpha = 0.1, colour = "black") +
# # # #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# # # #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1, colour = "blue")
# # # # THIS WORKED
# # # ###################################################################################  
# #   # add this to a row in a new dataframe
# #   rc_joined_lsoa_scr <- rbind(rc_joined_lsoa_scr, e)
# # 
# #   # remove the temporary dataframes sf files etc
# #   remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# # 
# #   # Print (i) as a counter
# #   cat(i, "completed\r")
# # }
# # saveRDS(object = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
# 
# # # clean the rc_joined_lsoa_scr names and columns
# # # Round the scores to the nearest whole number
# # rc_joined_lsoa_scr = as.data.frame(rc_joined_lsoa_scr)
# # rc_joined_lsoa_scr = st_as_sf(rc_joined_lsoa_scr)
# # rc_joined_lsoa_scr <- rc_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# # # # 
# # # # # reindex the data
# # rownames(rc_joined_lsoa_scr) <- 1:nrow(rc_joined_lsoa_scr)
# # # Delete the irrelevant columns
# # rc_joined_lsoa_scr = rc_joined_lsoa_scr |> dplyr::select(-one_of('fid', "center", "value", 'group_index'))
# # # rename the columns that require renaming
# # rc_joined_lsoa_scr <- rc_joined_lsoa_scr  |>  rename_at('centoidgeom', ~'rccentroidgeom')
# # saveRDS(object = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # 
# # ###################################################################################
# # # # Convert all the geometries
# b = rc_joined_lsoa_scr[,c(1,19)]
# # b = as.data.frame(b)
# # b = b |> dplyr::select(-one_of('rcgeometry'))
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# 
# rc_joined_lsoa_scr$joinedlsoageom = b$joinedlsoageom
# 
# # # ###################################################################################
# # # # TEST PLOT
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # # # THIS WORKED
# # # ###################################################################################
# # # 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,18)]
# # remove rcgeometry
# # b = as.data.frame(b)
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rcwalktime = b$rcwalktime
# 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,17)]
# # remove rcgeometry
# # b = as.data.frame(b)
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rccentroidgeom = b$rccentroidgeom
# 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,16)]
# # remove rcgeometry
# # b = as.data.frame(b)
# # b = b |> select(-one_of('rcgeometry'))
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rcgeometry = b$rcgeometry
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # # rc_joined_lsoa_scr <- st_as_sf(rc_joined_lsoa_scr)
# ggplot(rc_joined_lsoa_scr[67,]) +
#   annotation_map_tile(zoomin = 0, type = "osm") +
#   geom_sf(aes(geometry = joinedlsoageom, alpha = round(lsoatotscr, digits = 0)), colour = "blue") +
#   guides(alpha = guide_legend(title = "LSOAs total score")) +
#   geom_sf(aes(geometry = rcgeometry, colour = ""), colour = "black", alpha = 0.1) +
#   geom_sf(aes(geometry = rcwalktime, fill = ""), colour = "purple",alpha = 0.1) +
#   guides(fill = guide_legend(title = "Retail centre isochrone")) +
#   geom_sf(aes(geometry = rccentroidgeom), colour = "red")
# # # THIS WORKED
# # #################################################################################
# 
# # saveRDS(obj = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
```

\FloatBarrier

The final set of potential retail centres were identified using the five variables and the total score of the stores data. Those retail centre variables that scored an average within +‐0.5 of the same variable in the stores data were identified and only those that scored the same as the store mean total score (24) were identified (see table \ref{tab:allmatches}, and figure \ref{fig:finalrcs}).

```{r rc_allmatched, echo=FALSE}
# Load the data
# zws_joined_lsoa_scr <- as.data.frame(readRDS("zws_joined_lsoa_scr.rds"))
# rc_joined_lsoa_scr <- as.data.frame(readRDS("rc_joined_lsoa_scr.rds"))
# zwsmeans <- as.data.frame(readRDS("zwsmeans.rds"))
allmatches <- as.data.frame(readRDS("allmatches.rds"))
# ################################################################################
# # # Get the column names for the scores
# # zwcolnames <- as.data.frame(t(colnames(st_drop_geometry(zws_joined_lsoa_scr[,12:17]))))
# # # Create a dataframe to hold the mean scores
# # zwsmeans <- data.frame(matrix(ncol = 6, nrow = 1))
# # # Change the column names
# # colnames(zwsmeans) <- zwcolnames
# #
# # # Add the mean scores for each of the variables to the mean dataframe
# # zwsmeans$carrank = round(mean(zws_joined_lsoa_scr$carrank), digits = 0)
# # zwsmeans$dedrank = round(mean(zws_joined_lsoa_scr$dedrank), digits = 0)
# # zwsmeans$occrank = round(mean(zws_joined_lsoa_scr$occrank), digits = 0)
# # zwsmeans$pplrank = round(mean(zws_joined_lsoa_scr$pplrank), digits = 0)
# # zwsmeans$tenrank = round(mean(zws_joined_lsoa_scr$tenrank), digits = 0)
# # zwsmeans$lsoatotscr = round(mean(zws_joined_lsoa_scr$lsoatotscr), digits = 0)
# # remove(zwcolnames, zws_joined_lsoa_scr)
# ##################################################################################
# # # Use this mean dataframe to find the retail centres that have scores that match this data.
# allmatches <- subset(rc_joined_lsoa_scr,
#                      (rc_joined_lsoa_scr$lsoatotscr == zwsmeans$lsoatotscr) &
#                      (rc_joined_lsoa_scr$carrank > zwsmeans$carrank-0.5) &
#                      (rc_joined_lsoa_scr$carrank < zwsmeans$carrank+0.5) &
#                      (rc_joined_lsoa_scr$dedrank > zwsmeans$dedrank-0.5) &
#                      (rc_joined_lsoa_scr$dedrank < zwsmeans$dedrank+0.5) &
#                      (rc_joined_lsoa_scr$occrank > zwsmeans$occrank-0.5) &
#                      (rc_joined_lsoa_scr$occrank < zwsmeans$occrank+0.5) &
#                      (rc_joined_lsoa_scr$pplrank > zwsmeans$pplrank-0.5) &
#                      (rc_joined_lsoa_scr$pplrank < zwsmeans$pplrank+0.5) &
#                      (rc_joined_lsoa_scr$tenrank > zwsmeans$tenrank-0.5) &
#                      (rc_joined_lsoa_scr$tenrank < zwsmeans$tenrank+0.5))
# 
# # Reindex the matches table
# rownames(allmatches) <- 1:nrow(allmatches)
# 
# # Save the all_matches data
# saveRDS(object = allmatches, file = "allmatches.rds")
# 
# 
# Print the matches table
kable(allmatches[,c(2:4, 10:15)], caption = "\\label{tab:allmatches}Scorecard summary table for all retail centres that contain all variable scores that sit within +-0.5 of the rounded mean zero waste store variable scores and match the mean total store score.") |> 
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |> 
  column_spec(1,bold = T, width = "2in")
  # column_spec(2,width = "0.1in") |>
  # column_spec(3,width = "0.1in") |>
  # column_spec(4,width = "0.1in") |>
  # column_spec(5,width = "0.1in") |>
  # column_spec(6,width = "0.1in") |>
  # column_spec(7,width = "0.1in") |>
  # column_spec(8,width = "0.1in") |>
  # column_spec(9,width = "0.1in")

#saveRDS(object = zwsmeans, file = "zwsmeans.rds")
#saveRDS(object = allmatches, file = "allmatches.rds")

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, allmatches, zwsmeans)
```

![Map of optimal retail centres in the study area. See table \ref{tab:allmatches} for retail centre names. \label{fig:finalrcs}](matchmap.png){alt="Map of optimal retail centres in the study area. See table \\ref{tab:allmatches} for retail centre names. \\label{finalrcs}" width="438"}

\FloatBarrier

\newpage

# Results

\FloatBarrier

This section will describe the results of the zero-waste store scorecard calculations and the demographic composition of the store catchment areas, before describing the results of the retail centres and the optimal locations for new stores.

### *Zero waste stores scorecard*

```{r, echo=FALSE}
# # Remove the COGS store
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr[-c(128), ]
# # Reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# # save it
# saveRDS(object = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
```

The first record of the examples in table \ref{tab:allzwsscrtable} shows that the mean for each variable (*carrank*, *dedrank*, *occrank*, *pplrank*, and *tenrank*) were 6, 3, 4, 5 and 7 respectively, while the total mean score (*lsoatotscr*) was 26.

Table \ref{tab:zws_scrsummary} shows the summary values for each variable. Across all 128 stores, the total scores out of a possible maximum of 50 (*lsoatotscr*) ranged from 15 through to 32; a mean of 24, and an interquartile range of between 22 to 27 was observed. The variables were scored out of 10, with the greatest range of scores was seen in the *tenrank* variable which ranged from one to nine. The interquartile range of the tenrank variable was between five and seven with a mean of six. The smallest total range was seen in the carrank variable (between three and seven) and had an interquartile range of zero (25th % and 75% were both six) and had a mean of six.

Figure \ref{fig:zw_scrs_hists} shows the *lsoatotscr* (total scores) were distributed normally between 15 and 32. The *tenrank* (homeownership) variable was distributed widely with a negative skew. The variable for the households comprised two people without children (*pplrank*) and was distributed narrowly with a slight positive skew. The occupation type (*occrank*) and education level (*dedrank*) variables were more widely distributed with a slight positive skew. The car accessibility (*carrank*) variable was by contrast narrowly distributed and showed a negative skew.

Figure \ref{fig:corr_plot} shows the correlation between the individual variables (and the total score, which is less important because the higher any individual score, the greater the total score will be). Vehicle access (*carrank*) remains flat as education (*dedrank*) and occupation type (*occrank*) rise. However, as household composition (*pplrank*) and homeownership (tenrank) rise, vehicle access (*carrank*) is positively correlated to a similar point for each and then flattens. As education level (*dedrank*) rises, occupation type (*occrank*) is positively correlated, but household composition (*pplrank*) is negatively correlated. Education level (*dedrank*) and tenure (*tenrank*) are curvilinear correlated, where *tenrank* drops then rises. Occupation (*occrank*) is somewhat negatively correlated with household composition (*pplrank*) but has a curvilinear relationship with homeownership (*tenrank*). Household composition (*pplrank*) has a positive relationship with homeownership (*tenrank*).

So that comparisons could be made between the store(s) with the lowest and the store(s) with the highest scores as seen in table \ref{tab:minmaxstore_tab}, distribution histograms were produced side by side (see figure \ref{fig:minmaxcomp_plot}).

The smallest difference between the individual scores in these two stores was seen in household composition (*pplrank*) with the lowest and highest scoring stores having two and four respectively. The vehicle access variable (*carrank*) was also low with the lowest to the highest scoring store being five and eight respectively. All other variables were considerably higher for the store with the highest score than the lowest scoring store, with the totals for each being 32 and 15 respectively.

These were mapped individually so that physical locations could be visualised and compared. Both stores appear to be in urban areas of cities. (See figures \ref{fig:maxstr_map} and \ref{fig:minstr_map}).

The highest scoring store (see figure \ref{fig:maxstr_map}) is located within Teddington, an area of South‐West London in the borough of Richmond upon Thames. Teddington is a relatively small residential area, with a Small Local retail Centre at its centre (on which the store was found) and is surrounded by large areas of greenspace. This and the scores hint at a higher level of demographic wealth than the lowest scoring store.

```{r}
# Get the retail centres for the min and max stores
# Load the retail centres data
# rcs <- readRDS("joined_rc_results.rds")
# # Load the maxstore data
# maxstore <- readRDS("maxstore.rds")
# 
# # Look to see if the store sits within a retail centre
# rcmaxstr = rcs[maxstore$zwsgeometry,]
# # Save the max store retail centre
# saveRDS(object = rcmaxstr, file = "rcmaxstr.rds")
```

The lowest scoring store (see figure \ref{fig:minstr_map}) is located within the City of Leicester, in the Midlands. The store was found not to be located in a retail centre but is situated on the campus of Leicester University. The isochrone however covers a large area of the city showing urban centrality and accessibility for a large population.

Figure \ref{fig:zws_rc_dist_table} shows that the majority of stores are not located within a retail centre. The majority of stores that are located within a retail centre, are in a 'Small Local Centre', or a 'Town Centre', with very few being in a 'Large Retail Park' or 'Regional Centre'.

```{r, echo=FALSE}
# Get the retail centres for the min stores
# Load the retail centres data
# rcs <- readRDS("retail_c.rds")
# Load the minstore data
# minstore <- readRDS("minstore.rds")

# Look to see if the store siits within a retail centre
# rcminstr = rcs[minstore$zwsgeometry,]
# Save the min store retail centre
# saveRDS(object = rcminstr, file = "rcminstr.rds")
```

```{r}
############### Try to fix zws_joined_lsoa_scr.rds geometries #####################
###################################################################################
# # Load zwsiso
# zwsdata <- readRDS("zws_joined_lsoa_scr.rds")
# a = as.data.frame(zwsdata)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$joinedlsoageom <- b$joinedlsoageom
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$isogeometry <- b$isogeometry
# 
# b = a[,c(1,18)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$zwsgeometry <- b$zwsgeometry
# 
# ###################################################################################
# # # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1) +
# #   geom_sf(aes(geometry = zwsgeometry))
# # 
# ###################################################################################
# # # FINAL TEST
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # #################################################################################
# zwsdata = a
# zwsdata = st_as_sf(zwsdata)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr = zwsdata
# zws_joined_lsoa_scr$zwsgeometry
# zws_joined_lsoa_scr$isogeometry
# zws_joined_lsoa_scr$joinedlsoageom
# 
# ###################################################################################
# # TEST PLOT
# ggplot(zws_joined_lsoa_scr[93,]) +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   geom_sf(aes(geometry = zwsgeometry)) +
#   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
#   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
```

```{r}
# # reindex the rc_joined_lsoa_scr data
# rownames(rc_joined_lsoa_scr) <- 1:nrow(rc_joined_lsoa_scr)
# ###################################################################################
# # TEST PLOT
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # i = 0
# # i = i + 1
# # a = rc_joined_lsoa_scr[i,]
# # a
# # st_geometry(a) <- "rcwalktime"
# # a
# # st_geometry(a) <- "joinedlsoageom"
# # a
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "black") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "brown", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "blue") +
# #   geom_sf(aes(geometry = joinedlsoageom, fill = lsoatotscr), alpha = 0.1, colour = "red")
# # THIS WORKED
# #################################################################################
```

\newpage

### Retail centres results

```{r join_rc_results, echo=FALSE}
# joined_rc_results <- rbind(rca_results, rcaa_results, rcb_results, rcbb_results, rcc_results, rccc_results)
# saveRDS(object = joined_rc_results, file = "joined_rc_results.rds")
# remove(rca_results, rcaa_results, rcb_results, rcbb_results, rcc_results, rccc_results)
```

Table \ref{tab:rc_scrs_summary} shows a summary of the retail centre scores. A total of 5139 retail centres were processed. The total scores ranged from 12 to 36. The mean was calculated to 23 with a median value of 22 and an interquartile range of between 20 and 25.

Again, each individual variable (scored out of 10), showed a very wide range of scores, with vehicle access (*carrank*) being the narrowest range (between two and eight) and home ownership (tenrank) being the widest range (between one and 10).

Distributions of scores for all retail centres were produced. Figure \ref{fig:all_rc_hists} shows that all retail centres were distributed normally. The home-ownership (*tenrank*) and vehicle access (*carrank*) variables were negatively skewed with home ownership (*tenrank*) widely distributed and vehicle access (*carrank*) more narrowly distributed. The widely distributed household composition (*pplrank*) and occupation type (*occrank*), and narrowly distributed education level (*dedrank*) variables were all positively skewed.

Retail centres that scored a total that fell within the interquartile range (22 to 27) of the stores scores can be seen in the summary (table \ref{tab:rc_zwsiqr_scrs_summary}). The results here show that there were 2089 retail centres. The lowest scoring variable was the education level (*dedrank*) variable which ranged from zero to seven. Figure \ref{fig:rc_iqr_hists} shows the distribution histograms and shows show that the widely distributed homeownership (*tenrank*) and narrowly distributed vehicle access (*carrank*) variables were negatively skewed. The occupation type (*occrank*) and education level (*dedrank*) variables were more widely distributed than the household composition (*pplrank*) variable and all were positively skewed to varying degrees.

The average total store score was calculated and rounded to 24. This score was used to locate all the retail centres that also scored 24. There were 529 of these (summaries can be seen in table \ref{tab:rc_eqzws_scrs_summary}. The distribution histograms (see figure \ref{fig:rc_zws_mean_hists}) show the single average total score (24) for the retail centres. The variables were narrowly distributed with homeownership (*tenrank*), household composition (*pplrank*) and vehicle access (*carrank*) all negatively skewed. Occupation type (*occrank*) and education level (*dedrank*) were positively skewed. The homeownership (*tenrank*) and vehicle access (*carrank*) variables were particularly high scoring, while the education level (*dedrank*) variable was particularly low.

The final potential retail centres that scored within +‐0.5 of the same variable in the stores data, and the same mean score (24) for the total score can be seen in table \ref{tab:allmatches} and figure \ref{fig:finalrcs} The majority of the final nine, were Small Local Centres and were found in the west of England and in Wales.

```{r zws_rc_join}
# remove(a, i, z, rc_with_zws, retail_c, b, zws_joined_lsoa_scr, all_rcs)
# rc_with_zws <- readRDS("rc_with_zws.rds")
# # retail_c <- readRDS("retail_c.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# 
# ###############################################################################
# # ALL RETAIL CENTRES SETUP
# all_rcs <- read_sf('all_retailcentres.shp')
# saveRDS(object = all_rcs, file = "all_rcs.rds")
# 
# all_rcs <- readRDS('all_rcs.rds')
# all_rcs = st_transform(all_rcs, crs = st_crs(3857))
# ##############################################################################
# 
# # delete the RC geometry column
# zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr = zws_joined_lsoa_scr |> dplyr::select(-one_of('V21'))
# zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)
# 
# # Create a blank dataframe to hold the new data ready to copy to the zws data
# b <- data.frame(matrix(ncol = 22, nrow = 0))
# 
# # set up the counter
# i = 0
# i = i + 1
# missingrcs = 0
# # Start the loop
# for(i in 1:nrow(zws_joined_lsoa_scr)) {
#   # take the i row of zws_joined_lsoa_scr
#  z = zws_joined_lsoa_scr[i,]
#  # # Set the active geometry column
#   # st_geometry(z) <- "rcgeometry"
#  # get the retail centre that i sits in
#  a = all_rcs[z,]
# 
#  # check to see of the store is contaned within a retail centre
#    if(nrow(a) == 0) {
#      cat(i, "No Coordinates\r")
# # Add the row from z to the b dataframe 
#     z = cbind(z, a[i,c(4,10)])
#   b = rbind(b, z)
#   missingrcs = missingrcs + 1
#    next
#  }
# dammt = cbind(z, a[,c(4,10)])
# # Add the row from z to the b dataframe 
#   b = rbind(b, dammt)
# 
# # remove a and z
#   remove(a, z, dammt)
# 
# ##   # print i as a count of rows that have completed
#  cat(i, ".....completed\r")
#   # Sys.sleep(1)
# 
# }
# # Make the zwsjoined dataframe the same as the b dataframe
# zws_joined_lsoa_scr[,c(21:22)] = b[,c(18,22)]
# saveRDS(object = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
# 
# remove(a, i, z, rc_with_zws, retail_c, b, all_rcs)
```

\newpage

# Discussion

Whether or not, socio‐demographic variables that relate to environmentally conscious consumer behaviours can help to define optimal locations for zero-waste stores will be discussed in this section, along with the findings and their links to relevant literature. It will discuss the demographic variables and their ability to provide evidence that justify new store locations, the store locations and scores, the retail centres and their scores, and the optimal new stores' locations.

### *Assessing the relevance of demographic characteristics used*

Figure \ref{fig:corr_plot} shows that there are varying degrees of strength in the relationship between the individual variables for each catchment area, with the majority being strong and positive. These relationships positively reflect the bulk of the literature related to demographic characteristics in the context of environmentally conscious behaviours. It is important to note that there is also a body of work that contradicts some of the findings of these studies. Contradictory research includes [@chekima2016], where results indicate gender, and level of education do not have a positive effect on environmentally conscious purchasing behaviours. @panzone2016 found that, in that their own research, results for higher wealth, females and home-ownership demographic importance may have been overstated in previous studies. @figueroa-garcia2018 found that gender, age, and education levels are not significant indicators of environmentally conscious behaviours. The main limiting factor in these contradictory findings is that environmentally conscious behaviour drivers are extremely broad, complex, and yet to be clearly defined @figueroa-garcia2018.

However, occupation type and education level can individually indicate increased spending potential and environmental concern/awareness, resulting in more ethical consumption decisions [@chen2023]. Occupation and education variables and the link between them (as seen in figure \ref{fig:corr_plot}) is consistent with the increased environmentally conscious behaviours seen in the study by @chen2023. They found that the link between these and the resultant higher spending potential allowed respondents to make more environmentally ethical decisions around consumption. Individually, education was an important factor as seen in the results by @roberts1997, in which a higher level of education signified a higher level of environmental knowledge that influenced more environmentally conscious behaviour. Occupation types that are often from degree education levels, and therefore offer higher earnings, combined to act as partial proxies for wealth and spending power. This was required, because firstly the lack of availability of income data, and secondly, as @martinsons1997 points out, more educated and wealthier consumers are more likely to be more environmentally sensitive.

Household composition can also be seen as a partial proxy for increased spending potential, but also as an indicator for behavioural influence and change, whilst tenure also reflects the increased spending potential. Tenure in this study was defined by home ownership and is also linked to the variable for the number of people in a household, which was limited to two people per household with no resident children. Combined, these households generally have a greater spending power, but household composition also plays an important role in that members of the household are more likely to influence each other's environmental consciousness [@diamantopoulos2003]. This study showed that there was a positive relationship between the number of the people in a household and home ownership (see figure \ref{fig:corr_plot}).

Vehicle access was an important characteristic for two reasons. Car ownership amongst the most environmentally conscious is lower. However, this group of people often tend to own a single car that is used infrequently for longer journeys, or due to the lack of public transport options [@gilg2005]. This was perhaps the variable with the weakest relationship between other variables but was important to include due to the aforementioned reasons.\

### *Zero waste stores and their catchment area scores*

Demographic constituents of a catchment area of an existing store are the logical starting point for analysis in retail [@birkin2017]. This can help retail suppliers target specific demographic markets, such as McDonald's who will target younger consumers from a wide range of backgrounds. In this study, catchment areas around the stores were defined as a 20-minute walk‐time rather an arbitrary distance and because of the choice of scale (LSOA), and captured a range of population differences, including the demographic variables used to define the scores.

Comparison between the stores with the lowest and highest scores as seen in figures \ref{fig:minmaxcomp_plot}, \ref{fig:maxstr_map} and \ref{fig:minstr_map}, suggests that the results for individual stores and their physical locations are less important than looking at the results as a complete set of data. For example, the store with the highest score, was the 'Refill Larder' sited in Teddington in the London borough of Richmond upon Thames. It was on a Small Local Retail Centre, in a relatively wealthy urban location and scored relatively high across all variables. Contrast this with the store with the lowest overall score, which was called NADA. This was located on the University of Leicester campus. This difference in score and location does not automatically equate to success or failure, or an optimal versus sub‐optimal location, and highlights potential issues in determining optimal locations based solely upon analysis of variables such as those used in this study, rather than looking at the distributions and averages of all the results.

Without spending data, it is difficult to say whether any store is more or less successful than others, however, in terms of potential demand the NADA store score does not score highly on any variable, but due to its location, the individual low scores (especially for education level), and location, become less relevant. The evidence that degree-educated populations are more likely to understand and engage with the environmental concepts involved in the ethos of zero-waste stores has been discussed as one of the most important demographic characteristics [@balderjahn1988; @chekima2016; @bogusz2021; @aprilia2022]. Situated on a university campus, the majority of the demand population for the NADA store are not educated to degree level (yet) but are however on that path and it could be argued that this should increase the weighting of the education level score for this and other similar locations.

Taking the above difficulties into account, and by looking at the complete set of store scores, there are no stores that signify and more or less optimal location, and that none sit at either extremity of the range of scores (see figure \ref{fig:zw_scrs_hists} for all store score distributions). This suggests that firstly, all stores sit in locations that display, on average, demographics that have relatively normal distributed populations related to the variables used. This in turn suggests that narrowing down the potential locations for new stores should be based on this range of scores or a combination of averages taken from the range of scores, rather than using a range from the highest scoring stores.\

### *Identifying optimal retail centres using the scores from existing stores*

Retail centres that could be classified as potential new store locations were identified through a series of steps that incrementally narrowed the results down. This was done by decreasing the range of store scores to derive the results from.

The full range of retail centre total and individual variable scores can be seen in the summary table \ref{tab:rc_scrs_summary} and distribution histograms can be seen in figure \ref{fig:rcminmax_hists}. When compared to the distributions of the stores (see table \ref{tab:zws_scrsummary} and figure \ref{fig:zw_scrs_hists}, the distributions show similar shapes and ranges. This suggests that most of the stores are located within a retail centre. However, as discussed, the NADA store on the University of Leicester campus is not on a retail centre. This may hint at the possibility that it is not entirely necessary that a store is placed in a retail centre. especially when taking into consideration the scores for each of the lowest scoring locations (retail centre and store). The NADA store scored higher than the lowest retail centre score, implying some retail centres are less optimal than some non-retail centre locations. This feature is not uncommon, as according to @birkin2017, in the context of UK Post Office locations, the use of 'fuzzy' membership of a retail centre can be used because stores / services that are located close to retail centres, may still experience some of the benefits of retail adjacency and centre quality.

Initially, the majority of the 5876 retail centres scores were found to be within the store score range with only 258 sitting outside of this, leaving 5618 potential locations. These were filtered using the interquartile range of store scores, which resulted in 2089 RC locations. Further filtering was carried out using the mean store total score, which left 529 retail centres as potential locations. The final filter was to apply the mean of each of the five variables and the mean of the total store scores, which resulted in the final results. Nine retail centres remained, and these were identified as the most optimal. Table \ref{tab:allmatches} shows these and highlights some important points.

Figure \ref{fig:finalrcs} shows that the optimal retail centres for new zero-waste stores are located around the west of England and in Wales. The majority of the potential retail centres are classified as 'Small Local Centre' which positively reflects the link between the 'local' aims of the store's practices and the literature in terms of community, and the reduction in environmentally damaging supply practices such as vehicle emissions. This also points to the importance of proximity, which coincides with the ethical framework of the environmentally conscious retail principles of zero-waste stores. In terms of the environment and social equity, the sourcing of local produce from local producers, minimising supply chains, and an ethical approach to trading, are important issues that this sector aims to address. All these aims can help to minimise excessive transportation requirements and reduce the amount of chemicals needed to preserve food items that are used in the longer supply chains of the larger supermarkets [@beitzen-heineke2017]. Local proximity also brings increased social benefits, such as linking local suppliers to the local demand market. It can also, encourage more engagement from residents with their local neighbourhoods, including other stores in these smaller local centres, providing greater convenience, and an enhanced community [@carrigan2004; @beitzen-heineke2017]. Overall, when considering these overlaps of the literature and the resulting identified locations, it suggests that the methods in this study are robust.

```{r final_rcs_map, fig.height=5, fig.width=5, fig.cap="Classifications of final optimal retail centres."}
# allmatches <- readRDS("allmatches.rds")
# lsoas <- readRDS("lsoas.rds")
# 
# # set the active geometry (rccentroidgeom)
# st_geometry(allmatches) <- "rccentroidgeom"
# st_geometry(lsoas) <- "lsoageometry"
# 
# # Set the CRS
# allmatches <- st_transform(allmatches, crs = st_crs(4326))
# lsoas <- st_transform(lsoas, crs = st_crs(4326))
# 
# # Add the row id to a new column
# allmatches <- tibble::rowid_to_column(allmatches, "ID")
# 
# # Plot the data
# matchmap <- ggplot(allmatches, aes(geometry = rccentroidgeom)) +
#   annotation_map_tile(zoomin = -1, type = "cartolight") +
#   geom_sf(aes(colour = allmatches$Classifica)) +
#   geom_sf_text(aes(label = allmatches$ID),
#                nudge_x = c(-0.1, 0.1, -0.1),
#                nudge_y = c(0.1, 0.1, 0.1)) +
#   geom_sf(data = lsoas, aes(geometry = lsoageometry), linewidth = NA, fill = NA) +
#   guides(colour = guide_legend(title = "Retail Centre Classification", reverse = FALSE)) +
#   theme_void(base_size = 10)
# 
# ggsave("matchmap.png")
```

### *Discussion of the benefits and limitations of the methods used in the study*

The variables used in this study were chosen for their relationship to environmentally conscious consumer behaviours. Creating scorecards based upon these behavioural characteristics at the LSOA scale was successful in terms of the processes followed, however, the number of variables chosen limited the findings by increasing the range of potential store locations.

The inclusion of additional variables could have been argued for. For example, with regards to sex, there are bodies of work that conclude that women are more likely to actively engage with environmentally conscious behaviour [@tonglet2004; @badowska2019; @bartek2022], amongst others. However, due to the nature of the data available the impact of including this variable would have been minimal because LSOA data is in general split 50/50 between male and female population counts, as is the population of England and Wales. This implies that smaller scale data would be beneficial, such as analysing individual customer data for each store.

Another variable that could have been argued for inclusion in this study is age. There are bodies of work that provide evidence that individually cover wide ranging age bands as being more actively in the environmentally conscious behaviours. For example, @gilg2005 amongst others have shown that older people are more likely to provide evidence of demand for zero-waste stores through their environmentally conscious behaviour, but @balderjahn1988 and @papaoikonomou2011 amongst others have shown younger people are more likely to exhibit the same behaviour. This potentially indicates a shift in environmentally conscious attitudes amongst the general population, and that all age ranges are equally valid and should be included in the study.

With regards to the process of narrowing down and filtering optimal retail centre locations based on scorecards, this study has shown that due to the range of store scores and retail centre scores, without sales data, and the use of more sophisticated methods, such as spatial interaction modelling for example, it is very difficult to predict optimal locations. It could be argued that because both sets of score distributions were similar, any of the retail centres would be a good potential location for a new store. Sales data would have been able to give a metric of success and could be correlated with each variable. This would have given an idea of the most influential variables, which would have allowed for decisions about their inclusion/exclusion and weighting to have been made.

\newpage

# Conclusion & Recommendations

This research investigated the potential for consumer socio-demographic characteristics to be used to help locate optimal locations for zero-waste stores in England and Wales. It has provided evidence of customer bases for stores in these new locations and has identified potential gaps in market provision in this sector. This was achieved using scorecards produced from the characteristics of environmentally conscious consumers (identified through previous literature in this area) and using these to analyse current and possible future store locations. Based on this analysis, nine retail centres were identified as optimal locations for new stores to be situated in, derived from the criteria set out in the scorecards.

The literature review revealed that socio-demographic characteristics of environmentally conscious consumers are difficult to identify; in short, socio-demographic characteristics do not map directly onto consumer behaviours. Furthermore, there is a lack of research identifying and defining socio-demographic characteristics that may drive or correlate with environmentally conscious behaviours. However, the variables chosen for this study -- based on a critical reading of relevant literature in this area -- indicated that there are links between environmentally conscious retail behaviours and particular demographic characteristics. This allowed for stores to be scored in a way that led to plausible and useful findings.

The scorecard method allowed for nine retail centres to be identified as optimal locations for new stores, the majority (n=5) of these being Small Local Centres. The preponderance of small local centres in the optimal locations for new stores suggests that the environmental aims of zero-waste store are best suited to smaller local retail centres that can provide a local community with environmentally conscious retail choices. This finding points towards the significance of the classic high street -- aka a Small Local Centre -- as potentially important locations for future zero-waste stores. This finding is also underlined by literature on the x-minute city, which supports the significance of the local and easily accessible. Situating zero-waste stores in Small Local Centres could also allow them to utilise local suppliers, which is an important part of their philosophy.

The study was limited by the low number of variables used in the creation of the scorecards and also (possibly more importantly) the lack of availability of spending data for existing stores. To provide a greater understanding of the potential of demographics related to environmentally conscious consumerism, analysis of the behaviours of environmentally-motivated customers in this sector, and a deeper dive in to their characteristics will be required. Future studies could analyse political loyalties, spending patterns and real-world travel times to better understand this type of consumer and the lengths they will go to in order to consume in an environmentally conscious way.

This study provides a starting point on which further research can be based to optimise environmentally conscious retail locations and more sustainable retail models in the future. Further research could build upon the scorecards used here and include a more granular picture of the likely customer base, and would ideally include spatial-interaction analysis of spending in order to quantify ethical consumption.

\newpage

# References

::: {#refs}
\noindent \vspace{-2em} \setlength{\parindent}{-0.5in} \setlength{\leftskip}{0.5in} \setlength{\parskip}{15pt}
:::

# Appendices
