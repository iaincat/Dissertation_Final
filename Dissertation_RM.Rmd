---
title: "An Investigation Into The Use Of Socio-Demographics For The Location Optimisation Of 'Zero-Waste' Shops In England & Wales"
#author: "Student id: 201578497"
geometry: "left=1.2cm,right=1.2cm,top=1.5cm,bottom=1.5cm"
output:
  pdf_document: 
    latex_engine: xelatex
    fig_caption: yes
    toc: yes
  
header-includes:
# Use the packages
  - \usepackage{setspace}
  - \usepackage{lastpage}
  - \usepackage{fontspec}
  - \usepackage{placeins}
  - \usepackage{fancyhdr}
  - \usepackage{biblatex}
  - \setlength\bibitemsep{1.5\itemsep}
# Set the font
  - \setmainfont{Calibri}

# Set line spacing
  - \onehalfspacing

# Header and Footer Settings
  - \fancyhf{}
  - \pagestyle{fancy}

# References and bibliography settings
csl: C:/Users/James/OneDrive/Documents/R/win-library/4.1/markdown/csl/UoL_Harvard.csl

#csl: https://www.zotero.org/styles/harvard-university-of-leeds
bibliography: references.bib
---

```{=tex}
\fancyhf{}
\thispagestyle{fancy}
\fancyhead[R]{201578497}
\fancyhead[L]{GEOG3050}
\rfoot{\thepage\ of \pageref{LastPage}}
```

------------------------------------------------------------------------

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	error = FALSE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE,
	comment = "",
	tidy = FALSE
)
cache.val = T

# Load / Install packages-------------------------------------------------------
#install.packages("", dependecies = TRUE)
library(knitr)
library(sf)
library(kableExtra)
library(ggplot2)
library(basemaps)
library(mapview)
library(openrouteservice)
library(ggspatial)
library(stringr)
library(patchwork)
library(dplyr)
library(rgdal)
library(viridis)
library(corrplot)
library(tidyr)
library(tidyverse)
library(sp)
library(maptools)
library(rgeos)
library(readxl)
library(gridExtra)
library(psych)
library(reshape2)
library(sjmisc)
library(spatstat)
library(raster)
library(ggthemes)
library(RColorBrewer)

#API Key info - should only need loading once -  500
# ors_api_key("5b3ce3597851110001cf62480f8858be0885487ca2a78900b689815b")

# Extra 500
# ors_api_key("5b3ce3597851110001cf62481c9976fe80734502bc28ff74af4e101e")

#API Key info - should only need loading once -  2500
ors_api_key("5b3ce3597851110001cf624810789863e851418a86e0341fb278a772")
```

\FloatBarrier

\maketitle

------------------------------------------------------------------------

\newpage

------------------------------------------------------------------------

\newpage

# Acknowledgements

Thanks everyone

\newpage

------------------------------------------------------------------------

\newpage

# Abstract

WRITE THE ABSTRACT HERE

\newpage

# Introduction

WRITE THE INTROCUDTION HERE

\newpage

# Literature Review

This section will review the literature on some of the most relevant and important methods of store location planning that are employed in the retail sector. Each will be discussed and critiqued for appropriateness for use in this study. A review of studies that focus on environmentally conscious consumption behaviours and associated demographic profiles will be carried out. This will provide the justification for the decisions taken around the choices of data that will be used in the chosen method for this piece of work.

Municipal waste, as a general concept, and in particular packaging waste, and the way in which we all as consumers can tackle the associated issues with the latter will be discussed. Firstly, a brief history of waste will be described for context, including some of the problems that are associated with production and consumerism. Secondly, the review will move on to a critique of the research in relation to zero-waste lifestyles and the changes in attitudes and practices towards environmentally conscious consumption. Insight in to the growth of zero-waste shops and the related product solutions that are linked to these, which help move retail towards zero-waste consumer practices will be addressed. The picture will move towards a focus on how these solutions are being practised in England and Wales.

### Zero Waste Concept: Then & Now

Prior to industrialization, society produced very little waste [@mauch2022]. People would feed livestock with leftover food, repair broken items, and household goods such as furniture would be handed down to the next generation. With the advent of industrial capitalism in the mid-nineteenth century, production was designed to maintain itself, and old products discarded when a new, or better product when one is made available. This is the defining feature of consumerism [@graeber2011]. After World War II the world inevitably saw a huge rise in waste of all kinds due to mass-production and mass-consumerism. As Figure \ref{globalwaste} shows, the amount of waste generated globally in 1965 was around 635 million tonnes (mt) increasing to 1999 mt in 2015, and is projected to rise to 3539 mt by 2050 [@chen2020].

\FloatBarrier

![Global Yearly Waste Production by Type [@chen2020]\label{globalwaste}](Images/Globalwaste.png){width="514"}

\FloatBarrier

The term "zero waste" was coined in 1973 by Paul Palmer [@zaman2015] in relation to the reusable "clean" chemical waste being produced in Silicone Valley. He started selling these chemicals back to the industry with the principal strategy that everything should be reused rather than used once and discarded [@mauch2022]. The term evolved over the following years and today, there seems to be no consensus on the definition as such [@pietzsch2017]. Zero-waste as a term that now encompasses the theory, practice, and learning of governments through to individuals, and is a catch-all term for the response to the perceived crisis of waste and the failure to manage it [@hannon2018].

In England in 2002 for example, it was estimated that producers accounted for 91% of national waste [@murray2002]. Within the area of manufacturing and production for example, zero-waste as a concept is an effective way to help minimise solid waste, and through redesign, resource life cycles enable products to be reused [@song2015].

From a consumer perspective, food waste reduction has become one of the biggest areas of concern for zero waste research [@zhang2022]. Around one third of all the food bought is thrown away in England [@murray2002], and environmental deterioration that is caused by this non-sustainable consumption impedes sustainable development [@chekima2016; @badowska2019]. Food waste is linked to packaging. Food retail uses the highest amount of plastics and is the reason why packaging makes up the largest constituent of plastic waste [@sastre2022]. Figure \ref{globalplastic} shows that global plastic production in 2015 was just under 350 mt with over 35% of all plastic produced being used for packaging (see figure \ref{plasticuses}).

\FloatBarrier

![Global Plastic Production : 1950 - 2015 [@beckman2018] \label{globalplastic}](Images/WorldPlastic_1950_2015.png){width="300"}

![The different uses of plastic. [@beckman2018] \label{plasticuses}](Images/Plastic_use.png){width="300"}

\FloatBarrier

Figure \ref{ancum_plastic} shows that around 10 mt of plastics that are produced end up in the worlds oceans. Although the annual amount is predicted to fall, the cumulative effect of adding to the problem, is estimated to rise, albeit slower, to over 1500 mt by 2100.

\FloatBarrier

![Annual and Cumulative Plastic Input into Oceans [@chen2020]\label{ancum_plastic}](Images/ann_cum_plastic.png){width="514"}

\FloatBarrier

The problem of waste in food retail can partly be addressed through product design, where packaging can be produced to have as little impact on the environment as possible. The idea of minimising environmental damage from packaging and it's relationship with sustainability has indeed seen a large increase in research and literature [@sastre2022], and in the UK there have even been trials of changes to packaging free retail in some of the larger supermarket chains.

In 2019, Waitrose launched a trial in its Oxford store where it dedicated a section of the store to a new refill station, where cleaning materials, wine, and dried goods such as rice were made available to customers that wanted to use their own reusable containers. By testing this method of shopping in store, they were able to gauge how much appetite there was for a different type of shopping experience [@smithers2019]. by doing this they have shown how significant the role of the consumer is in how food retail operates. and the problem of food waste and how a move to sustainable consumerism can be achieved. Due to the success of the trial of Waitrose "Unpacked", they introduced the refill options to three other stores, and as interest and demand grows, they hope to offer the "Unpacked" option in more stores and online over time [@waitrose&partners].

### Zero Waste Shops

Zero-waste shops are shops that are dedicated to eliminating all unnecessary waste from the retail consumer experience [@watson2020]. They do this with practices that eliminate plastic packaging by displaying products in bulk where they can, and customers bring their own containers for items, or use paper bags for supplied by the store. They also aim to send all food that expires to food-banks or community kitchens, further eliminating waste in this way. Bulk purchasing of saleable products is another goal, which minimises transport waste products such as CO~2~. Another important aim for zero-waste shops is to stock products with known origins from suppliers with similar priorities that are as local as possible [@believeearth2017].

Zero-waste shops, using these practices, can help in the building of a sense of community. They are often small neighbourhood stores that have been started though crowd-funding or another local campaign [@greenpeaceusa2019]. This allows for the community around them to be involved from the start and provides a sense of investment in the success of the store.

However, as the demand for sustainable retail rises, the competition for customers will increase, and as Waitrose have already stated, the larger stores will be able to offer more choice than perhaps the smaller dedicated local stores can. This may mean that product choice in the larger retailers will be greater, but as described above, there is more to environmentally conscious retail than simply packaging and the elimination of plastic. The larger retailers will also have to consider the ethical choices made by consumers in relation to the environmental impacts of supply chains, and the related support for local producers.

### The customer

Because the community tends to provide the customers for these shops, an important question to answer, is one that asks who these customers are likely to be. A survey to identify the levels of environmental awareness in consumers was carried out in Slovakia. It targeted the age groups between 1965-1980 (*gen' x*) and 1981-1996 (*gen' y*), due to their greater purchasing power over other groups. They found that amongst the *gen' y* group, 39% were likely to use zero-waste stores often as opposed to 10% of the *gen' x* group [@holotova2020]. This suggests that age is an important variable when analysing the demographics of the customer base of zero-waste stores. @diamantopoulos2003 highlights the weakness in using socio-demographics to try to define a 'green consumer', as environmental 'awareness' is not fully understood through gender, age and education etc. However, there are a large number of studies including [@sang2015; @bekhet2011; @yuan2013; @zhao2014], who have all found that environmentally conscious 'behaviours' are strongly associated with demographic characteristics such as age, education, occupation type, and income to name a few. AGE SHOULD ONT BE A VARIABLE AND SHOULD BE TESTED AFTER RESULTS HAVE BEEN SHOWN. THIS CAN HIGHLIGHT THE IMPORTANCE OF AGE RATHER THAN ARBITRARILY CHOOSING AN AGE A A VARIABLE TO INCLUDE IN THE SCORECARD.

### Store planning

**Geodemographics**

1)  I think it is too general. Be specific in how this can relate to customers for this type of retail

In order to analyse the potential of a location, retailers need to know the market demand that exists. To do this, they use, amongst other data, geodemographic classifications that have been aggregated from census and other sources. Data are aggregated in to small areas such as post-code, or the Output Area Classification [@birkin2017]. Potential customers must be identified from the data and in the case of the zero-waste store, environmentally conscious or green consumer behaviours and characteristics are essential to understand the demand.

Around 86% of the UK population is classed as urban and as with cities across the globe, population growth is expected to see over 90% of the worlds population living in cities, and the waste that is produced in them also grow [@statista]. This hints at the need to look at the demographic make-up of urban populations rather than rural communities.

The environmental context is complex to understand, therefore adults that have a high education level must be considered as potential ethical consumers in the first instance [@paul2016; @chekima2016]. It is known that urban populations are more likely to be highly educated, and gain higher incomes [@wensing2023a]. Gender and age are also indicators of environmentally conscious consumerism. @gilg2005 found that 65% of committed environmental behaviours in relation to consumerism were attributed to females in the study, and the mean age was 55 years. **HAS THIS CHANGED - GOTTEN YOUNGER RECENTLY??** However, in the UK 18-24 is the age at which females especially are likely to consume ethically.

The UK urban population population is

These provide a snapshot of the age ranges, ethnicities, population density, household compositions, housing type and socio-economic make-up and employment classifications for example, in each area, which can in turn be used to target specific groups based on the market for a particular service. A problem with the averaging of characteristics in this way is known as the ecological fallacy [@openshaw1984]. This is essentially when an averaged characteristic of an area is applied to the individual scale, which potentially ignores or fails to recognise finer detail in demographic make-up of an area. For example, an area may be calculated to be wealthy, but within that region there may be a pocket of poverty that is aggregated out and vital support for this population may be missed.

**Catchment Area**

Defining the catchment area for a store is highly important aspect of retail location analysis. To do this, a possible solution would be to draw an arbitrary boundary around the store location and include the population within that boundary as potential custom [@hernandez2000]. A more realistic catchment area definition would be to estimate how far a customer will travel, either by foot, car, or by public transport, to a store location. A boundary that is 20 minutes walk to the store location could be used for example, and would take in to account terrain and route layout in terms of accessibility. Using a buffer and overlay system available in GIS can build an accurate picture of an area through the addition or removal of features. For example, a discount retailer looking for a new store location may filter out customers from a higher income class in an area leaving lower income populations in the analysis data [@birkin2017]. It may also provide a better picture of the residential make-up of an area, by allowing for non-residential areas to be accounted for, thus providing a more accurate picture of the demographics of an area, and therefore potential custom. This can be used in conjunction with a network analysis, in which accessibility can be further investigated. This entails a more comprehensive analysis of road networks to deduce the travel times to the providers of a service [@birkin2017].

**Location Choice**

Once various locations have been identified, a choice must be made. There are numerous methods for choosing a location of a store, and these can range from the more simple to highly complex. The simpler, cheaper and traditional approach, where experience tells the planner where to locate a store has not entirely been replaced by the more complex methods such as checklists or scorecards [@hernandez2000].

Checklists involve the scoring of a number of chosen variables that positively influence store performance. The variables are rated according to a points system which when combined, can be used to compare other potential locations [@hernandez2000]. This is part of an analogue method of location analysis, in which, once the demographic and retail centre classification variables to be used for the scorecard have been identified, each catchment area can be classified. It is apparent that this technique can be used to investigate the similarities and differences between each location, providing a picture of the customer base for a particular type of shop (in this case; zero-waste stores). Although this method is good at providing a rating of different locations based on potential customers, and allows comparisons between locations to be made, it is unable to estimate revenue [@birkin2017]. This study is not seeking to estimate the success or failure of a store on predicted or current revenue data due to it being unavailable.

Multi-variate regression methods are more complex still, and require a great deal of (good quality) data, computing power, and expertise. Decisions are based upon statistically significant results [@hernandez2000]. These methods are good at benchmarking sales forecasting, for example, and mainly used for future development for specific products, or new stores. The same restrictive factors such as computing power are also prevalent in methods such as cluster and factor analysis, where a retailers portfolio can be clustered in to types of offering and used to create a blueprint for strategic change, such as creating discount lines to be sold in cheaper stores based in lower income demographic areas.

Gravity modelling, Spatial Interaction Models (SIMs), and neural network methods are even more complex and expensive to facilitate, in terms of expertise, computing and data. SIMs generally rely on the availability of data such as flows of revenue for example [@birkin1999]. They show the relationships between the flow of consumers and revenue, and are used in the analysis of a new store, or a competitor opening in a location, and the effect it will have on existing provision. [@hernandez2000]. Neural networks are essentially a scaled up version of this and are used to forecast performance related to a large number of new sites

### Conclusion

It has been suggested that statistical modelling such as regression analysis and Spatial interaction Modelling based on the link between flows of money are useful tools for retail location analysis and site planning [@wood2007; @birkin2017; @hernandez2000], however, access to sales data will is restricted and hard to access for resource limited studies. Buffer and overlay techniques take in to account non-residential areas, travel time, and mode of transport, and can be applied to define appropriate catchment areas. Using carefully chosen demographic features, a scorecard or rating system can be applied to these catchment areas which can then replicate the analogue method, in which comparison can be made between the stores and their surrounding demographics related to environmental consumer behaviour. This information can then be extended to look for similar retail centres or demographically similar areas, in which one would expect to find a similar store.

\newpage

# Methodology

In order to achieve the objectives set out in the previous section, a quantitative approach was taken to determining the demographics that surround the locations of the stores in the study area. This included the creation of a scorecard for each location, based on the selected demographic variables. The scorecards were then used to identify similar locations of the study area in which stores could be expected to be found. By incorporating statistical and geospatial techniques to the analysis of the data, and presenting the results of the study through geographical representation, a landscape of ethical consumption will be built up and visualised. This analysis will feed in to the discussion of the rationale behind the choices of variable used in the data, the methodological approach taken and an evaluation of the results.

### Zero Waste Store Location Data

Location data for the stores to be used was retrieved using the metadata of the The Zero Waste Network (ZWN)[@thezerowastenetwork] website. This was, by comparison to other similar website's and directories, the most comprehensive listing found. Table \ref{tab:zws} shows examples of the raw data used.

```{r zwstab}
# Uses library(kableExtra)
# Load zws RDS file
zws <- readRDS("zws.rds")
# Display a table of the first 10 records
kable(zws[1:10,], caption = "\\label{tab:zws}Zero-waste stores data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
```

These data were cleaned through Google searches to identify and remove any stores that were irrelevant to the study, such as incorrectly listed stores, wholesalers, and mobile refill vehicles, and also to highlight any that had closed since being listed. Of the initial 172 stores, 135 remained. To ensure that the remaining stores had correct coordinate data and sat within the study area, a plot of all the locations was made and can be seen in figure \ref{zwstores}.

![Map of all Zero Waste Stores in Study Area. \label{zwstores}](Images/zwsmap.png){width="400"}

### LSOA Area Scale Boundary Data

Lower Super Output Area (LSOA) data was downloaded for the study area from the Open Geography Portal [@opengeographyportala]. This related to the latest 2021 boundaries at the LSOA scale and includes the LSOA identifier and the attached geometries. LSOA scale data was chosen so that the number of households or individual populations within each area were to be small enough to allow for more accuracy in when comparing the demographic composition of an area. Output areas (OA) scale data provides a more granular scale that LSOA scale data, however, at the time of data extraction, all the chosen demographic variables were not available at the OA level, so LSOA scale data was to provide consistency across the variables.

```{r lsoa_table}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoas <- readRDS("lsoas.rds")

# # remove the scores from the lsoa data
# lsoas = lsoas |> select(-one_of('occrank', 'tenrank', 'carrank', 'pplrank', 'dedrank'))

kable(lsoas[1:5,c(1,3,9)], caption = "\\label{tab:lsoas}LSOA boundary data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

### Demographic data

Nomisweb provided the latest Office for National Statistics, 2021 census data, at the LSOA scale [@nomis]. LSOA area codes were included to provide linked identifiers for GIS processing. The demographic variables were found under the following identifiers: -

TS003 - Household composition

This dataset included those households that were classified as either, married single family households with no children, or, cohabiting couple households with no children. See Table \ref{tab:pplscr}. Household composition amongst committed environmentalist in the study by @gilg2005 was smaller, with two people households accounting for 40%. Household composition suggesting greater income because firstly, they had sufficient means to obtain a mortgage, or had completed paying off their mortgage, and due to the fact that there were no children in the make-up of the household, indicated a certain level of disposable income. Behaviourally, as @tonglet2004 points to, cohabiting couples that share values, can be more likely to encourage environmentally conscious behaviours and more ethical decisions.

```{r 2ppl_data}
pplscr <- readRDS("pplscr.rds")
# # Create a table for the Household composition data 
# Load the 2ppl data
# pplscr <- read.csv("2ppl.csv")
# 
# # remove the country row
# pplscr = pplscr[-c(33756), ]
pplscr = as.data.frame(pplscr)
# 
# # clean the unrequired columns
pplscr = pplscr |> dplyr::select(-one_of('Total..All.households', 'X.', 'Single.family.household..Married.or.civil.partnership.couple..No.children', 'X..1', 'Single.family.household..Cohabiting.couple.family..No.children', 'X..2', 'tot_.', 'score_calc', 'hhld_.'))
# 
# pplscr <- pplscr  |> dplyr::rename_at('mnemonic', ~'LSOA21CD')
pplscr <- pplscr |> dplyr::rename_at('X2021.super.output.area...lower.layer', ~'Area')
pplscr <- pplscr |> dplyr::rename_at('score', ~'pplscr')
pplscr <- pplscr  |> dplyr::rename_at('Single.family.household..All.aged.66.years.and.over', ~'2ppl >66yrs')

kable(pplscr[0:4,c(1,2,4,3,5)], caption = "\\label{tab:pplscr}Total LSOA scores for household composition data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(pplscr)
# saveRDS(object = pplscr, file = "pplscr.rds")
```

TS045 - Car or van availability

This dataset included only those households that were reported as having access to a single vehicle only. See Table \ref{tab:carscr}. Vehicle availability was chosen due the balance that is required between environmentally conscious choices and behaviours that are made. Simply put; even the most environmentally conscious consumer has to travel, and sustainable behaviour is influenced by both the reasons why travel is required, and the transportation environment. Employment is a major factor related to reasons for travel and public transport is not the most convenient and efficient mode. Many people balance these neccessary travel requirements with environmental concerns and self-limit their impacts on the environment by minimising their own vehicle access [@taube2018]. This is also supported by the study in to sustainable lifestyles and green consumption by @gilg2005. In this they found that in each of the survey respondent clusters, more than 50%, limited themselves to a single vehicle.

```{r car_table}
carscr <- readRDS("carscr.rds")

# # Load the vehicle access data
# carscr <- read.csv("1car.csv")
# # clean the unrequired columns and rename them for ease of use
carscr = carscr |> dplyr::select(-one_of('score_calc', 'X.'))
# carscr <- carscr  |>  dplyr::rename_at('X2021.super.output.area...lower.layer', ~'Area')
# carscr <- carscr  |>  dplyr::rename_at('score', ~'carscr')
# carscr <- carscr  |>  dplyr::rename_at('mnemonic', ~'LSOA21CD')
carscr <- carscr  |>  dplyr::rename_at('Total..All.households', ~'total_hhld')
carscr <- carscr  |>  dplyr::rename_at('X1.car.or.van.in.household', ~'hhld_vehicles')
# saveRDS(object = carscr, file = "carscr.rds")

kable(carscr[0:4,1:5], caption = "\\label{tab:carscr}Total LSOA scores for single vehicle access data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(carscr)
```

TS054 - Tenure - Home Ownership

This variable included those households that were reported as having either owning their own homes outright, or under a mortgage. See Table \ref{tab:tenscr}. Tenure, and home ownership was identified as highly likely, amongst those participants that were classified as the most commitetd to sustainable consumption [@gilg2005]. The variable aids to implicate those that can afford their own homes so links to provide a part proxy for the unavailable earnings data.

```{r tenure_table}
tenscr <- readRDS("tenscr.rds")

# Load the tenure data
#tenscr <- read.csv("tenure.csv")

# clean the unrequired columns and rename them for ease of use
tenscr = tenscr |> dplyr::select(-one_of('score_calc', 'X.', 'sum'))
# tenscr <- tenscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
# tenscr <- tenscr  |>  rename_at('score', ~'tenscr')
# tenscr <- tenscr  |>  rename_at('mnemonic', ~'LSOA21CD')
# saveRDS(object = tenscr, file = "tenscr.rds")
tenscr <- tenscr  |>  dplyr::rename_at('Total..All.households', ~'hhld_total')
tenscr <- tenscr  |>  dplyr::rename_at('Owned..Owns.outright', ~'Owned')
tenscr <- tenscr  |>  dplyr::rename_at('Owned..Owns.with.a.mortgage.or.loan', ~'Mortgage/loan')

kable(tenscr[0:4,1:6], caption = "\\label{tab:tenscr}Total LSOA scores for home owners that own outright or mortgage data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(tenscr)
```

TS067 - Highest level of qualification - degree educated

Education level data was included only for those people that have degree level education or above as seen in table \ref{tab:dedscr}. @gilg2005 found that active and committed environmental behaviour was most prominent among those with a level of degree education or higher. This was a finding that was also found to be important by @han2010, in which they found that more than 80% of the respondents to their study relating to green consumer decision making were degree educated. Education level is also highlighted as an important factor in the ability to have a good level of understanding of the complexity of environmental issues, and can be a driver of green behaviour [@chekima2016].

```{r deg_ed_table}
dedscr <- readRDS("dedscr.rds")
# # Load the degree educated data
#  dedscr <- read.csv("degree_educated.csv")
# # 
# # # clean the unrequired columns and rename them for ease of use
 dedscr = dedscr |> dplyr::select(-one_of('X.', 'MinMax'))
#  dedscr <- dedscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
 dedscr <- dedscr |> dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over', ~'residents_total')
 
 # dedscr <- dedscr |> dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over', ~'residents')
 # dedscr <- dedscr |> dplyr::rename_at('score', ~'dedscr')
 # dedscr <- dedscr |> dplyr::rename_at('mnemonic', ~'LSOA21CD')
#  
#  saveRDS(object = dedscr, file = "dedscr.rds")

kable(dedscr[0:4,1:5], caption = "\\label{tab:dedscr}Total LSOA scores for degree education level or above data for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(dedscr)
```

TS063 - Occupation

Occupation data included those people whose occupations were classified as managers, directors, senior officials, and professional occupations. See Table \ref{tab:occscr}. This variable is somewhat related to the level of education, but more importantly ties in with the search for a valid proxies for higher income levels. These occupations can be seen as those that pay the most, and are also filled by people that are educated to degree level or above, and therefore earn more on average [@departmentforeducation]. It was chosen as a suitable variable for these reasons and for the fact that individual income data is unavailable.

```{r occ_data}
occscr <- readRDS("occscr.rds")
# # Load the occupation data
# occscr <- read.csv("occ.csv")
# 
# # clean the unrequired columns and rename them for ease of use
occscr = occscr |> dplyr::select(-one_of('X.', 'X..1', 'X..2', 'calc'))

occscr <- occscr  |>  dplyr::rename_at('Total..All.usual.residents.aged.16.years.and.over.in.employment.the.week.before.the.census', ~'residents_total')

occscr <- occscr  |>  dplyr::rename_at('X1..Managers..directors.and.senior.officials', ~'managers/directors')

occscr <- occscr  |>  dplyr::rename_at('X2..Professional.occupations', ~'professionals')

occscr <- occscr  |>  dplyr::rename_at('high_earners.', ~'high_earn_total')

#  occscr <- occscr  |>  rename_at('X2021.super.output.area...lower.layer', ~'Area')
#  occscr <- occscr  |>  rename_at('score', ~'occscr')
#  occscr <- occscr  |>  rename_at('mnemonic', ~'LSOA21CD')

# 
#  saveRDS(object = occscr, file = "occscr.rds")

kable(occscr[0:4,1:7], caption = "\\label{tab:occscr}Total LSOA scores for higher rated occupations for England and Wales")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T) |>
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.75in")
remove(occscr)
```

Using excel to process the .csv files, the percentages were calculated from reported total households or individual populations for each of the 5 variables, and each was standardised using the scaling method in which each LSOA data point for each variable was scored / ranked from 0 to 1 using the following formula:-

$$
x_{norm} = (x_{raw} - min_{i})/(max_{i} - min_{i})
$$

These rankings were then multiplied up by 10 and rounded to the nearest integer to provide a final score for each individual LSOA for each variable between 0 and 10 inclusive.

### EXPLAIN WHY WEIGHTING WAS NOT GIVEN TO ANY OF THESE - IE WHY THEY ARE EQUALLY IMPORTANT OR WHY NONE ARE MORE IMPORTANT THAN ANY OTHER.

### Combining score data and calculating totals

The scores for each individual variable were allocated to the matching LSOA in the LSOA data. A total score for each LSOA was then calculated. The resulting dataset (see table \ref{tab:lsoa_scores} for examples), was inspected to provide assurance that the process had resulted in individual scores that ranged from 0 and 10 only, and total scores were within a 0 to 50 range. These scores would then be available when analysing the current store locations and the potential un-supplied retail centres.

```{r score_prep}
# Convert lsoas to a sf file format and set the CRS to 3857
# lsoas = st_as_sf(lsoas)



#### Create a dataframe that holds the LSOA21CD id and the score for each variable
# Convert the lsoas sf file to a data.frame
#lsoas = as.data.frame(lsoas)

# Join each variables score data to the LSOA data and remove the unrequired columns each time
# carscr
#lsoas = left_join(lsoas, carscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# dedscr
#lsoas = left_join(lsoas, dedscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# occscr
#lsoas = left_join(lsoas, occscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# pplscr
#lsoas = left_join(lsoas, pplscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# tenscr
#lsoas = left_join(lsoas, tenscr, "LSOA21CD")
#lsoas = lsoas |> select(-one_of('Area'))

# sum the individual LSOA row values in columns 10 to 14 and add the result to a new column at the end after tenscr
#lsoas = lsoas |> 
#  mutate(lsoatotscr = rowSums(lsoas[,10:14], na.rm = TRUE),
#         .after=tenscr)

# remove unrequired temporary dataframes etc
#remove(carscr, dedscr, occscr, pplscr, tenscr)

# Save the lsoa data with the newly added individual scores and the calculated total scores
#saveRDS(obj = lsoas, file = "lsoas.rds")
# Load the results of the above code to save processing and memory when knitting
# lsoas <- readRDS("lsoas.rds")
```

```{r lsoa_score_table}
lsoas <- readRDS("lsoas.rds")

kable(st_drop_geometry(lsoas[1:5,c(1,3,9:14)]), caption = "\\label{tab:lsoa_scores}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoas)
```

### LSOA area scale population weighted centroids

Population Weighted Centroids (PWC) data was retrieved at the LSOA scale from the Open Geography Portal [@opengeographyportal2022]. This data was required because once the stores and retail centre isochrones had been calculated, those isochrones that contained a PWC would be filtered and used to calculate the scorecard for each location. PWC data can be seen in table \ref{tab:lsoa_pwcs}.

```{r pwc_data}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
lsoa_pwc <- readRDS("lsoa_pwc.rds")

kable(lsoa_pwc[1:5,c(2,4)], caption = "\\label{tab:lsoa_pwcs}LSOA population weighted centroid data")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(lsoa_pwc)
```

### Retail Centres

Retail centre boundaries for the study area were retrieved from the Consumer Data Research Centre [@consumerdataresearchcentre2022]. This data provided all retail centres in England and Wales, so that once analysis of all current zero waste store locations had been completed, potential retail centres that lack the supply of this type of store could be identified. The retail centre data was processed through QGIS to identify the centroid of each polygon, which was then added to the main file and saved and can be seen in table \ref{tab:rc_data}.

```{r retail_centre_data}
# Create a dataframe to summarise the LSOA Boundary and PWC data
# Load lsoas and pwc RDS files
retail_c <- readRDS("retail_c.rds")

# # # reindex the data
# rownames(retail_c) <- 1:nrow(retail_c)
# 
# saveRDS(object = retail_c, file = "retail_c.rds")

retail_c <- retail_c  |>  dplyr::rename_at('Classifica', ~'Classification')

kable(st_drop_geometry(retail_c[1:5,c(2:5)]), caption = "\\label{tab:rc_data}Retail centres data.")|>
  kable_styling(full_width = FALSE, latex_options = "HOLD_position", font_size = 8) |> row_spec(0,bold = T)
remove(retail_c)
```

### Creating a test scorecard using a known store location

To test and refine the methods that will be used to process the full dataset of zero waste stores, a single test store was selected. This consisted of a store that was known and was located in a known area, which allowed for the method to be corrected due to erroneous or anomalous results.

The following test store results shows the process that will be followed for all ZWS. Once the ZWS data has been processed, the data for the retail centres that do not contain a zero waste store will be processed using the same methods. Table \ref{tab:bishytab} shows the store information data and figure \ref{fig:bishylocation}, a visual representation of the test area in question.

\FloatBarrier

```{r bishy_load}
# Load bishy store boundary shapefile
bishy <- readRDS("bishy.rds")

# Convert this to the correct 3857 CRS
# bishy = st_transform(bishy, crs = st_crs(3857))

# rename the geometry column
# bishy <- bishy  |>  rename_at('geometry', ~'store_location')

kable(st_drop_geometry(bishy[,1:7]), caption = "\\label{tab:bishytab}Test store data for the Bishy Weigh store in York, England")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T)
remove(bishy)
```

\FloatBarrier

```{r bishylocation, fig.height=4, fig.width=4, fig.cap="Location of The Bishy Weigh store in York"}
bishy <- readRDS("bishy.rds")
ywalktime20 <- readRDS("ywalktime20.rds")
ggplot(bishy) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  geom_sf(data = ywalktime20, aes(geometry = geometry), alpha = 0.1, colour = NA) +
  geom_sf(colour = "blue", aes(geometry = bishystorepoint, fill = st_nam)) +
  guides(fill = guide_legend(title = "Test Store Name")) +
  theme_void(base_size = 10) +
  theme(plot.margin = margin(t = 0,  # Top margin
                             r = 0,  # Right margin
                             b = 0,  # Bottom margin
                             l = 0)) # Left margin
remove(bishy)
```

\FloatBarrier

### Calculating the isochrone

Using the OpenRouteService [@openrouteservice], a 20 minute walking time isochrone was calculated around the test store to define the catchment area. This distance/time was chosen partly due to the individual health benefits of walking [@tschentscher2013; @sari2010], and partly to fit in with the concept of a chrono-urbanism and temporally accessible city design such as the currently popular 15 and 20 minute city. The benefits of this concept include decreasing vehicle pollution and can help towards achieving the goal of net-zero amongst others [@ogorman2021; @moreno2021].

EXPAND THIS CONCEPTUAL LINK

```{r bishy_iso}
# Load the York isochrone data from the previously run code below
# ywalktime20 <- readRDS("ywalktime20.rds")

# Uses library(mapview) and library(openrouteservice)
# Create an isochrone around the Bishy Weigh zero waste store

# embed data in the output file
# mapviewOptions(fgb = FALSE)

# Get the coordinates of the bishy weigh
#coordinates <- data.frame(lon = bishy$Lon, lat = bishy$Lat)

## Calculate a 20 minute walking time to the store
#ywalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                     output = "sf", profile = ors_profile("walking"))
#values <- levels(factor(ywalktime20$value))
#ranges <- split(ywalktime20, values)
#ranges <- ranges[rev(values)]
#names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)

# Convert the walktime20 isochrone to the correct CRS
#ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))

#remove(coordinates, values, ranges)
#
# Save the York isochrone data
#saveRDS(obj = ywalktime20, file = "ywalktime20.rds")
```

Once the isochrone had been calculated from the test store, it was mapped to ensure that the correct store location and catchment area had been calculated for the the known store. See Figure \ref{fig:york_isochrone_test_map}.

\FloatBarrier

```{r york_isochrone_test_map, fig.height=4, fig.width=4, fig.cap="20 minutes walking distance isochrone from The Bishy Weigh store in York"}
bishy <- readRDS("bishy.rds")
# Uses library(ggspatial)
# Convert the walktime20 isochrone to the correct CRS
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
ywalktime20 <- readRDS("ywalktime20.rds")
# Map the 20 mins isochrone and store location
# use the walktime LAYER isochrone as the main data layer
ggplot(ywalktime20, aes(colour = "20 minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(fill = "blue", alpha = 0.1) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red", size = 2,
          aes(fill = st_nam)) +
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(ywalktime20, bishy)
```

\FloatBarrier

After confirming that the isochrone calculation and store location data produced the desired results, the PWC data was clipped so that a set of data was produced that contained only those PWC that fell within the isochrone. This decision was made to ensure that only population centres and, importantly, the corresponding LSOA(s) that fell within the catchment area were included. If this was not taken in to consideration, the resulting scorecards could be open to possible inaccuracy. For example, the scorecards could be calculated using LSOA(s) that had a proportion within the isochrone, but with PWC situated further than 20 minutes from the store and outside of the isochrone, resulting in scores that include populations that have a walk-time that is greater than 20 minutes. These results were then mapped to check method accuracy and can be seen in figure \ref{fig:bishy_pwc_clipped}.

```{r ypwc_clip, warning=FALSE}
# pwc_clip <- readRDS("pwc_clip.rds")

# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# lsoas = readRDS("lsoas.rds")
# lsoas = st_as_sf(lsoas)
# ywalktime20 = readRDS("ywalktime20.rds")
# ###################################################################################
# # Test plot an LSOA
# # ggplot(lsoas[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = lsoageometry))
# ###################################################################################
# lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
# lsoa_pwc = readRDS("lsoa_pwc.rds")
# lsoa_pwc = st_as_sf(lsoa_pwc)
# lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# lsoas = st_as_sf(lsoas)
# lsoas <- st_transform(lsoas, crs = st_crs(3857))
# lsoa_pwc = st_as_sf(lsoa_pwc)
# lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(3857))
# 
# # clip the PWCs to only show those inside the 20 minute walk time
# pwc_clip = lsoa_pwc[ywalktime20$geometry,]
# saveRDS(object = pwc_clip, file = "pwc_clip.rds")
###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = -1, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
#   geom_sf(data = pwc_clip, aes(geometry = pwcgeometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
#   guides(alpha = guide_legend(title = "Catchment Area")) +
#   theme_void()
##################################################################################
##################################################################################
# remove(bishy, lsoa_clip, lsoa_pwc, lsoas, pwc_clip, ywalktime20)
```

\FloatBarrier

```{r bishy_pwc_clipped, fig.height=4, fig.width=4, fig.cap="Population Weighted Centoids within the isochrone sourrounding The Bishy Weigh store in York"}
bishy <- readRDS("bishy.rds")
pwc_clip <- readRDS("pwc_clip.rds")
ywalktime20 <- readRDS("ywalktime20.rds")
ggplot() +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry), alpha = 0.1) +
  geom_sf(data = pwc_clip, aes(geometry = geometry, shape = ""), size = 1) +
  guides(shape = guide_legend(title = "Population Weighted Centroids")) +
  geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  geom_sf(data = ywalktime20, aes(geometry = geometry, alpha = "")) +
  guides(alpha = guide_legend(title = "Catchment Area")) +
  
  #   # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", which_north = "true", 
  #                        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 8)
remove(bishy, pwc_clip, ywalktime20)
```

\FloatBarrier

Once the PWC that sat within the isochrone were found, the corresponding LSOA for that catchment area were identified using the LSOA identifiers. These were then mapped to visualise the results and confirm the accuracy of the procedure. Figure \ref{fig:pwcs_lsoas_york_map} shows these results.

```{r}
# lsoa_clip <- readRDS("lsoa_clip.rds")
# pwc_clip <- readRDS("pwc_clip.rds")
# bishy <- readRDS("bishy.rds")
# ywalktime20 <- readRDS("ywalktime20.rds")
# #lsoas = readRDS("lsoas.rds")
# #lsoas = st_as_sf(lsoas)
# 
# ###################################################################################
# # Test plot an LSOA
# # ggplot(lsoas[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = lsoageometry))
# ###################################################################################
# # lsoas <- lsoas  |>  rename_at('lsoageometry', ~'geometry')
# lsoa_pwc = readRDS("lsoa_pwc.rds")
# # lsoa_pwc = st_as_sf(lsoa_pwc)
# # lsoa_pwc <- lsoa_pwc  |>  rename_at('pwcgeometry', ~'geometry')
# ywalktime20 <- st_transform(ywalktime20, crs = st_crs(3857))
# # lsoas <- st_transform(lsoas, crs = st_crs(4326))
# # lsoa_pwc <- st_transform(lsoa_pwc, crs = st_crs(4326))
# 
# # clip the PWCs to only show those inside the 20 minute walk time
# pwc_clip = lsoa_pwc[ywalktime20$geometry,]
# # clip the LSOAs to only show those for the clipped PWCs
# # lsoas <- st_transform(lsoas, crs = st_crs(3857))
# # pwc_clip <- st_transform(pwc_clip, crs = st_crs(3857))
# lsoa_clip = lsoas[pwc_clip,]

###################################################################################
# Test plot an LSOA
# ggplot() +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   # geom_sf(data = lsoa_clip, aes(geometry = lsoageometry, alpha = "")) +
#   # guides(alpha = guide_legend(title = "LSOAs")) +
#   geom_sf(data = pwc_clip, aes(geometry = pwcgeometry, shape = "")) +
#   guides(shape = guide_legend(title = "Population Weighted Centroids")) +
#   geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
#   guides(colour = guide_legend(title = "Store Name")) +
#   geom_sf(data = ywalktime20, aes(geometry = geometry, fill = ""), alpha = 0.1) +
#   guides(fill = guide_legend(title = "Isochrone"))
# #################################################################################
```

```{r pwcs_lsoas_york_map, fig.height=4, fig.width=4, warning=FALSE, fig.cap="Map showing the clipped LSOAs related to the PWCs that fall inside the 20 minute walk time catchment area."}

lsoa_clip <- readRDS("lsoa_clip.rds")
pwc_clip <- readRDS("pwc_clip.rds")
bishy <- readRDS("bishy.rds")
ywalktime20 <- readRDS("ywalktime20.rds")

# Map the test store, isochrone and corresponding LSOAs and PWCs
ggplot(ywalktime20, aes(colour = "20 minutes walk time")) +
  # Add the basemap tile 
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  # set the walktime LAYER colour fill and transparency
  geom_sf(data = lsoa_clip,  colour = "black", aes(alpha = ""), linetype = "11", size = 0.1) +
  geom_sf(data = pwc_clip, colour = "black", aes(shape = ""), size = 1) +
    geom_sf(fill = "blue", alpha = 0.1) +
  # add the store and set its colour
  geom_sf(data = bishy, colour = "red", shape = 10, size = 2,
          aes(fill = st_nam)) +
  
  # Adjust the legend titles based on the aes settings for both layers
  guides(color = guide_legend(title = "Catchment Area")) +
  guides(fill = guide_legend(title = "Store Name")) +
  guides(alpha = guide_legend(title = "LSOA Boundaries")) +
  guides(shape = guide_legend(title = "LSOA PWCs")) +
  # 
  # # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", which_north = "true", 
  #                        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 8)
remove(ywalktime20, lsoa_clip, pwc_clip, bishy)
```

\FloatBarrier

The resulting test store catchment area contained 18 population weighted centroids. The corresponding LSOA scores previously calculated for each variable were mapped individually. This was to provide both a picture of the spatial distribution of the variables and to ensure that the processing of the previous steps were providing results that were meaningful.

Figure \ref{fig:bishycar_map} shows the individual LSOA scores for households that have single vehicle access and evidence that no individual scores were above 10.

\FloatBarrier

```{r bishycar_map, fig.height=3, fig.width=3, warning=FALSE, fig.cap="Map showing individual lsoas vehicle access scores for the test store area"}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")
ggplot(lsoa_clip) +
  geom_sf(aes(fill = carrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Access to a\nsingle vehicle", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ydedscr_map} shows the individual LSOA scores for individuals that have been educated to degree level or above and shows that no individual scores were above 10.

```{r ydedscr_map, fig.height=3, fig.width=3, warning=FALSE, fig.cap="Map showing individual LSOA scores for the dedscr variable which relates to percentage of population that is degree educated and above."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = dedrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Degree Educated", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:yoccscr_map} shows the individual LSOA scores for individuals with the occupation types of managers, directors, senior officials, and professional occupations and also shows that no individual scores were above 10.

```{r yoccscr_map, fig.height=3, fig.width=3, warning=FALSE, fig.cap="Map showing individual LSOA scores for the occscr variable which relates to the populations with the highest occupation types."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = occrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Highest occupation\ntypes", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ypplscr_map} shows the individual LSOA scores for households that consist of two people with no children, and again shows that no individual scores were above 10.

```{r ypplscr_map, fig.height=3, fig.width=3, warning=FALSE, fig.cap="Map showing individual LSOA scores for the pplscr variable which relates to percentage of households that contain 2 people with no children."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = pplrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households with 2\npeople & 0 children", reverse = TRUE)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy, ypplscr_map)
```

\FloatBarrier

Figure \ref{fig:ytenscr_map} shows the individual LSOA scores for households that either own their homes outright, or have purchased under a mortgage or loan, and also, again, shows that no individual scores were above 10.

```{r ytenscr_map, fig.height=3, fig.width=3, warning=FALSE, fig.cap="Map showing individual LSOA scores for the tenscr variable, which relates to percentage of households that either own outright or mortgage their home."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")

ggplot(lsoa_clip) +
  geom_sf(aes(fill = tenrank)) +
  scale_fill_viridis_c(breaks=seq(0,10,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Households\nthat own or\nmortgage their home", reverse = TRUE, ncol = 2)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Figure \ref{fig:ytotscr_map} shows the total scores for each individual LSOA and shows that these totals do not sum to a value above 50.

```{r ytotscr_map, fig.height=3, fig.width=3, warning=FALSE, fig.cap="Map showing the total score for the 5 variables for each individual LSOA."}
lsoa_clip <- readRDS("lsoa_clip.rds")
bishy <- readRDS("bishy.rds")
ggplot(lsoa_clip) +
  geom_sf(aes(fill = lsoatotscr)) +
  scale_fill_viridis_c(breaks=seq(0,50,by=1), alpha = 0.7) +
  guides(fill = guide_legend(title = "Individual LSOA total scores\nfor the 5 variables", reverse = TRUE, ncol = 2)) +
  geom_sf(data = bishy, aes(colour = bishy$st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  theme_void(base_size = 10)
remove(lsoa_clip, bishy)
```

\FloatBarrier

Once the total score for each LSOA had been calculated, these were combined to provide a total score for the area as a whole by summing the total score for each LSOA and dividing that total by the number of LSOAs in the area. Mean scores for each of the five variables was also calculated in the same way for future reference. This method was used to maintain equivalence across the subsequent store and retail catchment areas, and allow comparison between the scorecard results of each due to the fact that stores may have greater or fewer number of LSOAs within the catchment area, rendering them isolated in terms of data without comparison.

```{r}
# Create a new variable to hold the totals for the final joined data and convert to a data.frame # # CRS should be 3857 # 
#lsoa_clip_tot = as.data.frame(lsoa_clip)

# create a row in the lsoa_clip_tot dataframe for the total MEAN for all lsoas in the area and the total of those totals #   
#lsoa_clip_tot <- lsoa_clip_tot |>      
#  bind_rows(summarise(lsoa_clip_tot[,9:14], across(where(is.numeric), mean), #across(where(is.character), ~'Total')))
#lsoa_clip_tot = st_as_sf(lsoa_clip_tot)

# Join the lsoas to a single shape - USE THIS "JOINED_LSOAS" AS THE FINAL LSOA SHAPE
#gglpot() +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = lsoa_clip_tot$lsoageometry))

# Test Plot
#plot(st_union(lsoa_clip_tot$lsoageometry))
#joined_lsoas <- st_union(lsoa_clip_tot$lsoageometry)

# Create a temp df "FT" to hold the totals for the whole joined LSOAs for each variable
#ft <- data.frame(matrix(ncol = 6, nrow = 0))
#lsoa_clip_tot = as.data.frame(lsoa_clip_tot)
#ft = lsoa_clip_tot[nrow(lsoa_clip_tot),9:14]
#lsoa_clip_tot = st_as_sf(lsoa_clip_tot)

# sum the individual variables for the whole lsoa_clip_tot and add the result to the bottom of lsoa_clip_tot
#bishy = st_as_sf(bishy)
#joined_lsoas = st_as_sf(joined_lsoas)
#joined_lsoas <- st_transform(joined_lsoas, crs = st_crs(3857))


# Test Plot Bishy
#ggplot(bishy) +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = joined_lsoas$x)) +
#  geom_sf(aes(geometry = bishy$store_location))
# THIS WORKED 
###################################################################################

#joined_lsoas = st_as_sf(joined_lsoas)
#bishyjoined = cbind(bishy, round(ft[,1:6], digits = 0))
#bishyjoined = cbind(bishyjoined, joined_lsoas)
#bishyjoined <- bishyjoined  |>  rename_at('x', ~'joined_lsoas')

################################################################################## # # Test plot
#bishyjoined = st_as_sf(bishyjoined)
#bishyjoined <- st_transform(bishyjoined, crs = st_crs(3857))

#ggplot(bishyjoined) +
#  annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  geom_sf(aes(geometry = bishyisochrone, alpha = ""), colour = "blue") +
#  guides(alpha = guide_legend(title = "20 minute walk time")) +
#  geom_sf(aes(geometry = joinedlsoageometry, fill = lsoatotscr), alpha = 0.2) +
#  guides(fill = guide_legend(title = "Joined LSOA\nTotal Score")) +
#  geom_sf(aes(geometry = bishystorepoint,  colour = "")) +
#  guides(colour = guide_legend(title = bishyjoined$st_nam))
# THIS WORKED
###################################################################################
#saveRDS(obj = bishyjoined, file = "bishyjoined.rds")
#bishyjoined <- readRDS("bishyjoined.rds")
```

Once the final total score had been calculated, the individual LSOAs spatial data was combined to a single polygon to make mapping clearer by removing the boundaries for the individual LSOAs in the area, and so that this boundary shape could be added to the relevant line in the store data. An example of this result can be seen in figure \ref{fig:final_bishy_map} below.

```{r final_bishy_map, fig.height=3, fig.width=3, fig.cap="Final map of the test store showing the catchment area, the joined LSOA and the corresponding total score for the area"}
bishy <- readRDS("bishy.rds")

ggplot() +
  annotation_map_tile(zoomin = 0, type = "hotstyle") +
  
  geom_sf(data = bishy, aes(geometry = joinedlsoageometry, alpha = bishy$totalscore), fill = "lightblue") +
  guides(alpha = guide_legend(title = "Joined LSOA & score")) +
  
  geom_sf(data = bishy, aes(geometry = bishyisochrone, shape = "" ), alpha = 0.1, colour = "red") +
  guides(shape = guide_legend(title = "Catchment Area")) +
  
  geom_sf(data = bishy, aes(geometry = bishystorepoint, colour = st_nam)) +
  guides(colour = guide_legend(title = "Store Name")) +
  
  theme_void(base_size = 10)

remove(bishy)
```

\FloatBarrier

### Processing all stores

Once the test store data had been processed and mapped to ensure validity, the data for all 140 zero waste stores, including the test store, were processed in full using the same processing steps as the test store, and the results were combined with the location data in the zero waste store data for analysis.

Firstly, as with the test store, isochrones were calculated, PWC were found, and LSOA data was filtered accordingly.

```{r zws_iso_loop}
# Load the results file from the code below
# zwsiso <- readRDS("zwsiso.rds")

# remove(i, zws, zwsiso)
# 
# zws <- readRDS("zws.rds")
# # Loops throughthe zws file and creates a new dataframe (zwsiso) that holds the zws store data and the isochrone for the walktime20 mins boundary.
# 
# #############################################################################
# #                                                                           #
# #          Commented out to stop it running                                 #
# #                                                                           #
# #############################################################################
# # create a dataframe to hold the iso results
# zwsiso <- data.frame(matrix(ncol = 12, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(zws)) {
#   # create a df variable to hold the zws values from row i of zws
#  isodf = zws[i,]
#   # embed data in the output file rather than html streaming option
#  mapviewOptions(fgb = FALSE)
#   
#   # Get the coordinates of the store in the (df)
#  coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   
#   # if there are no coordinates - skip to the next zws record
#    if(is.na(coordinates$lon)) {
#      cat(i, "No Coordinates\r")
#    next
#  }
#   
#   # Calculate a 20 minute walking time isochrone around the store
#  walktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                               output = "sf", profile = ors_profile("walking"))
#  values <- levels(factor(walktime20$value))
#  ranges <- split(walktime20, values)
#  ranges <- ranges[rev(values)]
#  names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
# #################################################################################### TEST PLOT THE ISOCHRONE
#  # ggplot(walktime20) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = geometry), alpha = 0.1) +
#  #   geom_sf(data = isodf, aes(geometry = geometry))
# # THIS WORKED 
# ###################################################################################
#   # Convert the walktime20 isochrone to the correct CRS
#   # USE THIS AS THE ISOCHRONE
#   # rename the walktime20 geometry column
#  walktime20 <- walktime20  |>  rename_at('geometry', ~'isogeometry')
# 
#   # Join the calculated walktime 20 data to the zws data in isodf
#  zwsisoc <- cbind(isodf, walktime20)
#  # rename the geometry column
#  zwsisoc <- zwsisoc  |>  rename_at('geometry', ~'zwsgeometry')
#  zwsiso = zwsiso <- rbind(zwsiso, zwsisoc)
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
# # ggplot(zwsiso) +
# #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #    geom_sf(aes(geometry = zwsgeometry)) +
# #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# ###################################################################################   # print i as a count of rows that have completed
#  cat(i, "completed\r")
#   
# # remove the temporary environments
#  remove(coordinates, isodf, ranges, values, walktime20, zwsisoc)
#  Sys.sleep(3)
# }
# # Save the zwsiso file
# saveRDS(obj = zwsiso, file = "zwsiso.rds")
# 
# ###################################################################################
# # TEST PLOT THE DATA AGAIN
#  # ggplot(zwsiso[97,]) +
#  #    annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #    geom_sf(aes(geometry = zwsgeometry)) +
#  #    geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# # THIS WORKED
# #################################################################################
# remove(coordinates, i, isodf, zws)
```

```{r zws_scr_loop}
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

# # Loop through each store to find the pwcs in zwsiso$walktimegeometry
# # Find all the LSOAs related to those PWCs
# # Get the scores for each LSOA
# # Add the scores and the joined LSOA geometry to the [i] row for that store
# 
# # Load the data required
# lsoa_pwc <- readRDS("lsoa_pwc.rds")
# 
# lsoas <- readRDS("lsoas.rds")
# # convert to sf
# 
# lsoas = st_as_sf(lsoas)
# zwsiso <- readRDS("zwsiso.rds")
# 
# # Create a dataframe to hold all the joined results
# zws_joined_lsoa_scr <- data.frame(matrix(ncol = 16, nrow = 0))
# 
# #initialise i
# i = 0
# i = i + 1
# for (i in 1:nrow(zwsiso)) {
# 
# a = zwsiso[i,]
#   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
# # get all the pwcs that appear in the iso for that store
# a <- a  |>  rename_at('isogeometry', ~'geometry')
# a = st_transform(a$geometry, crs = st_crs(3857)) 
# 
# # st_geometry(b) <- "geometry"
# b = lsoa_pwc[a,]
#   
#   # Check if (a) has 0 rows. If so, sack it off and move to the next record
#  if(nrow(b) == 0) {
#    next
#  }
#   
#   # Convert a to a dataframe to manipulate it
#   b = as.data.frame(b)
#   
#   # Get all the lsoas that relate to the pwcs just found
#   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
#   
#   #convert b to a dataframe
#   c = as.data.frame(c)
#   
# ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
#   c <- c |>
#    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
#                        across(where(is.character), ~'Total')))
#   
#   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# 
#   # convert b to sf format
#   c = st_as_sf(c)
#   
# ###################################################################################
# # TEST PLOT
# # ggplot(c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# #THIS WORKED
# ################################################################################### 
#   # Join the lsoas together
#  joined_lsoas <- st_union(c$lsoageometry)
#   
# ###################################################################################
# # TEST PLOT
#  # ggplot(joined_lsoas) +
#  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   ## Create a new dataframe for the joined data
#   joined_lsoas = st_as_sf(joined_lsoas)
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
#   
#   # combine the joined lsoa data and the score data
#   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
#   #remove the empty multipolyon column
#   joined_lsoas_c = joined_lsoas_c |> select(-one_of('lsoageometry'))
#   # rename the x column to "joinedlsoageom"
#   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(joined_lsoas_c) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1)
# #THIS WORKED
# ###################################################################################
# 
#   # retrieve the store name from zwsiso
#   d = zwsiso[i,]
# 
#    # Join the store name and the scores and the joined LSOA geometry and the walktime geometry
#  e = cbind(d, joined_lsoas_c)
# ###################################################################################
# # TEST PLOT
# # ggplot(e) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################  
#   # add this to a row in a new dataframe
#   zws_joined_lsoa_scr <- rbind(zws_joined_lsoa_scr, e)
# 
#   # remove the temporary dataframes sf files etc 
#  remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# 
# ###################################################################################
# # TEST PLOT
# #ggplot(zws_joined_lsoa_scr) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # THIS WORKED
# ###################################################################################
#   # Print (i) as a counter
#   cat(i, "completed\r")
# }
# # clean the zws_joined_lsoa_scr names and columns
# # Round the scores to the nearest whole number
# zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# 
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(zws_joined_lsoa_scr[93,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom, alpha = lsoatotscr))
# # THIS WORKED
# ###################################################################################
# # Set the active geometry column
# # st_geometry(zws_joined_lsoa_scr) <- "isogeometry"
# # zws_joined_lsoa_scr
# # 
# # 
# # remove(a, zwsiso)
# # Save the zws_joined_lsoa_scr data
# #remove the errors
# zws_joined_lsoa_scr <- zws_joined_lsoa_scr[-c(82), ]
# # reindex the data
# rownames(zws_joined_lsoa_scr) <- 1:nrow(zws_joined_lsoa_scr)
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
```

\FloatBarrier

Of the original 135 stores, 129 were successfully processed. Those that were not, either did not produce isochrone calculations that contained PWCs situated inside them, or did not have valid coordinate geometry data, as they were stores that closed prior to the study.

The results for the remaining 129 stores were processed to calculate the mean scores of the 5 individual variables. The total mean score was then calculated to produce the final scorecard result for each store location.

Using the final scorecards, distribution histograms were produced for the complete store data. This showed how all 129 stores total and individual variable scores were distributed. In addition, comparison histograms for the stores that had the lowest and highest scores were produced and were used to compare their individual variables and total scores. Cartographic mapping was also used to visualise the physical locations of both stores.

### Processing the retail centres

Once comparative analysis was completed on the stores, the scorecards were then used to identify the most suitable potential retail centre(s) that were not already supplied by a zero waste store.

Firstly, the isochrones were calculated as before.

\FloatBarrier

```{r rc_iso_additional}
# Load the data
# all_rcs <- readRDS("all_rcs.rds")
# 
# # Get the isochrones for the retail centres
# all_rcs$centoidgeom <-  st_point_on_surface(all_rcs$geometry)
# 
# # Transform the CRS 
# all_rcs = st_transform(all_rcs, crs = st_crs(3857))
# saveRDS(object = all_rcs, file = "all_rcs.rds")
# remove(all_rcs)

###################################################################################
# ggplot(all_rcs[5825,]) +
#   annotation_map_tile(zoomin = 1, type = "hotstyle") +
#   geom_sf(aes(geometry = geometry), colour = "red", alpha = 0.1) +
#   geom_sf(aes(geometry = centoidgeom), colour = "blue")
###################################################################################

# RE-DO THE RETAIL CENTRE ISOCHRONES

# SPLIT THE ALL_RCS FILE IN TO 3 (2500, 2500, 1423)
# rca <- all_rcs[1:2500,]
# saveRDS(object = rca, file = "rca.rds")


# rcb <- all_rcs[2501:5000,]
# saveRDS(object = rcb, file = "rcb.rds")

# rcc <- all_rcs[5001:6423,]
# saveRDS(object = rcc, file = "rcc.rds")

# remove(all_rcs, rca, rcb, rcc)

# rca <- readRDS("rca.rds")
# rcaa <- rca[500:2500,]
# saveRDS(object = rcaa, file = "rcaa.rds")


# rcb <- all_rcs[2501:5000,]
# saveRDS(object = rcb, file = "rcb.rds")
# rcc <- all_rcs[5001:6423,]
# saveRDS(object = rcc, file = "rcc.rds")
# remove(all_rcs, rca, rcb, rcc)
# rca <- readRDS("rca.rds")


# rc_final_results <- readRDS("rc_final_results.rds")

# # convert rciso to crs 4326
# #rciso <- st_transform(rciso, crs = st_crs(4326))
# # convert retail_c to crs 3857
# #rciso <- st_transform(rciso, crs = st_crs(3857))
# 
# 
# # Change the name of the centre column to make it identifiable
# # rca_results <- rca_results  |>  rename_at('center', ~'rcisocenter')
# 
# # remove the temporary dataframes
# remove(i)
# # save the rc_results and the rc_(x) files as RDS files
# saveRDS(obj = rc_a, file = "rc_a.rds")
# saveRDS(obj = rca_results, file = "rca_results.rds")
# remove(i)
# ###################################################################################
# # PROCESS THE RC_B FILE
# ###################################################################################
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_b)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_b[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_b, file = "rc_b.rds")
# saveRDS(obj = rcb_results, file = "rcb_results.rds")
# remove(i)
# 
# ###################################################################################
# ###################################################################################
# # PROCESS THE RC_C FILE
# ###################################################################################
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_c)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_c[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_c, file = "rc_c.rds")
# saveRDS(obj = rcc_results, file = "rcc_results.rds")
# remove(i)
# ###################################################################################
# ###################################################################################
# ###################################################################################
# # Convert all the geometries to work properly
# # load rca_results
# rca_results <- readRDS("rca_results.rds")
# a = as.data.frame(rca_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # Save a to rc_final_results
# rc_final_results <- a
# 
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcb_results <- readRDS("rcb_results.rds")
# a = as.data.frame(rcb_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[2,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # add the data to the final dataframe
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcc_results <- readRDS("rcc_results.rds")
# a = as.data.frame(rcc_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,21)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,26)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# 
# 
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'fid.1', 'RC_ID.1', 'RC_Name.1', 'Classifica.1', 'Country.1', 'Region_NM.1', 'H3_count.1', 'Retail_N.1', 'Area_km2.1', 'value', 'isodf.RC_ID'))
# # make sure the columns in a are in the same order as rc_final_results
# a <- a |> relocate(group_index, .before = rcgeometry)
# a <- st_as_sf(a)
# ###################################################################################
# # Fix the CRS of a
# # Try to fix zws_joined_lsoa_scr.rds geometries
# b = a[,c(1,10)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ###################################################################################
# # remove(rc_final_results)
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# b = rc_final_results[,c(13)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# rc_final_results$rcwalktime = b$rcwalktime
# 
# b = rc_final_results[,c(12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rccentroidgeom = b$rccentroidgeom
# 
# b = rc_final_results[,c(11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rcgeometry = b$rcgeometry
# 
# 
# ##################################################################################
# # TEST PLOT rc_final_results
# # ggplot(rc_final_results[2,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "blue")
# # THIS WORKED
# saveRDS(obj = rc_final_results, file = "rc_final_results.rds")
# ###################################################################################
# ###################################################################################
# # Remove unwanted dataframes and sf files
# remove(a, b, c, rc_a, rc_b, rc_c, rc_results, rca_results, rcb_results, rcc_results)
# ################################################################################
```

```{r rc_iso_calc}
# rc_final_results <- readRDS("rc_final_results.rds")
###################################################################################
# # RC ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# #### Process rc_a
# rca_results <- data.frame(matrix(ncol = 18, nrow = 0))
# 
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_a)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_a[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rca_results <- rbind(rca_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# # convert rciso to crs 4326
# #rciso <- st_transform(rciso, crs = st_crs(4326))
# # convert retail_c to crs 3857
# #rciso <- st_transform(rciso, crs = st_crs(3857))
# 
# 
# # Change the name of the centre column to make it identifiable
# # rca_results <- rca_results  |>  rename_at('center', ~'rcisocenter')
# 
# # remove the temporary dataframes
# remove(i)
# # save the rc_results and the rc_(x) files as RDS files
# saveRDS(obj = rc_a, file = "rc_a.rds")
# saveRDS(obj = rca_results, file = "rca_results.rds")
# remove(i)
# ###################################################################################
# # PROCESS THE RC_B FILE
# ###################################################################################
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_b)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_b[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_b, file = "rc_b.rds")
# saveRDS(obj = rcb_results, file = "rcb_results.rds")
# remove(i)
# 
# ###################################################################################
# ###################################################################################
# # PROCESS THE RC_C FILE
# ###################################################################################
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# #############################################################################
# i = 0
# i = i + 1
# #############################################################################
# for(i in 1:nrow(rc_c)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rc_c[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$rccentroidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
#   
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat 
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
#   
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200, 
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
#   
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
#   
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')  
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
#   # ggplot(rcwalktime20) +
#   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
#   
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
#   
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a)
#   remove(isodf)
#   remove(rciso)
#   remove(coordinates)
#   remove(ranges)
#   remove(values)
#   remove(rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# 
# saveRDS(obj = rc_c, file = "rc_c.rds")
# saveRDS(obj = rcc_results, file = "rcc_results.rds")
# remove(i)
# ###################################################################################
# ###################################################################################
# ###################################################################################
# # Convert all the geometries to work properly
# # load rca_results
# rca_results <- readRDS("rca_results.rds")
# a = as.data.frame(rca_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # Save a to rc_final_results
# rc_final_results <- a
# 
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcb_results <- readRDS("rcb_results.rds")
# a = as.data.frame(rcb_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# 
# b = a[,c(1,13)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,14)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$walktimegeometry = b$walktimegeometry
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[2,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'rcisocenter', 'isodf.RC_ID', 'value', 'walktimegeometry'))
# ###################################################################################
# # add the data to the final dataframe
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# # Convert all the geometries to work properly
# # load rcb_results
# rcc_results <- readRDS("rcc_results.rds")
# a = as.data.frame(rcc_results)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,21)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,26)]
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# 
# 
# ##################################################################################
# # TEST PLOT a
# # ggplot(a[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = a[1,]$rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = a[1,]$rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = a[1,]$rccentroidgeom), colour = "blue")
# # THIS WORKED
# ###################################################################################
# # Remove the unrequired columns from a
# a = a |> select(-one_of('index', 'fid', 'fid.1', 'RC_ID.1', 'RC_Name.1', 'Classifica.1', 'Country.1', 'Region_NM.1', 'H3_count.1', 'Retail_N.1', 'Area_km2.1', 'value', 'isodf.RC_ID'))
# # make sure the columns in a are in the same order as rc_final_results
# a <- a |> relocate(group_index, .before = rcgeometry)
# a <- st_as_sf(a)
# ###################################################################################
# # Fix the CRS of a
# # Try to fix zws_joined_lsoa_scr.rds geometries
# b = a[,c(1,10)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcgeometry = b$rcgeometry
# 
# b = a[,c(1,11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# a$rccentroidgeom = b$rccentroidgeom
# 
# b = a[,c(1,12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# a$rcwalktime = b$rcwalktime
# a = st_as_sf(a)
# ###################################################################################
# # remove(rc_final_results)
# rc_final_results <- rbind(rc_final_results, a)
# ###################################################################################
# b = rc_final_results[,c(13)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# rc_final_results$rcwalktime = b$rcwalktime
# 
# b = rc_final_results[,c(12)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rccentroidgeom = b$rccentroidgeom
# 
# b = rc_final_results[,c(11)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# b
# rc_final_results$rcgeometry = b$rcgeometry
# 
# 
# ##################################################################################
# # TEST PLOT rc_final_results
# # ggplot(rc_final_results[2,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "black", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "blue")
# # THIS WORKED
# saveRDS(obj = rc_final_results, file = "rc_final_results.rds")
# ###################################################################################
# ###################################################################################
# # Remove unwanted dataframes and sf files
# remove(a, b, c, rc_a, rc_b, rc_c, rc_results, rca_results, rcb_results, rcc_results)
# ###################################################################################
```

```{r rca_isocalc, echo = FALSE}
###################################################################################
# # RCAA ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# # RC ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# remove(i)
# 
# rca_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rca)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rca[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rca_results <- rbind(rca_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = 1:499 inclusive (499)
# saveRDS(object = rca_results, file = "rca_results.rds")
# rca_results = 500:2500 inclusive (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")
```

```{r rcaa_isocalc, echo=FALSE}
###################################################################################
# # RCAA ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rca_results)
# remove(i)
# 
# rcaa <- readRDS("rcaa.rds")
# # #### Process rcaa
# rcaa_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcaa)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcaa[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcaa_results <- rbind(rcaa_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = 1:499 inclusive (499)
# saveRDS(object = rca_results, file = "rca_results.rds")
# rca_results = 500:2500 inclusive (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")
```

```{r rcbb_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcbb <- readRDS("rcbb.rds")
# # #### Process rcaa
# rcbb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcbb)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcbb[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcbb_results <- rbind(rcbb_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# rca_results = (499)
# saveRDS(object = rca_results, file = "rca_results.rds")

# rca_results = (2001)
# saveRDS(object = rcaa_results, file = "rcaa_results.rds")

# rcbb_results = (498)
# saveRDS(object = rcbb_results, file = "rcbb_results.rds")

# rcb_results = (2002)
# saveRDS(object = rcb_results, file = "rcb_results.rds")
```

```{r rcb_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)
# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcb <- readRDS("rcb.rds")
# # remove(rcb)
# # #### Process rcaa
# rcb_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcb)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcb[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert  to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcb_results <- rbind(rcb_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rca_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcb_results = (2002)
# saveRDS(object = rcb_results, file = "rcb_results.rds")
# remove(rcb)
# rcc_results = (1423)
# saveRDS(object = rcc_results, file = "rcc_results.rds")
```

```{r rcc_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")
# rcb <- rbind(rcb, rcc)
# rcc <- rcb[2501:2925,]
# # # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcc$RC_ID,]
# saveRDS(object = rcc, file = "rcc.rds")
# saveRDS(object = rcb, file = "rcb.rds")
###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# rcc <- readRDS("rcc.rds")
# # #### Process rcaa
# rcc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rcc)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rcc[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rcc_results <- rbind(rcc_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rcaa_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcb_results = (2500)
# # saveRDS(object = rcb_results, file = "rcb_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcc_results = (425)
# saveRDS(object = rcc_results, file = "rcc_results.rds")
# remove(rcc)
# rccc_results = (500)
# saveRDS(object = rccc_results, file = "rccc_results.rds")
```

```{r rccc_isocalc, echo=FALSE}
# 
# # Load the rcb dataframe
# rcb <- readRDS("rcb.rds")
# # copy 1:499 rows from rcb to rcbb 
# rcbb <- rcb[1:498,]
# # Save rcbb
# saveRDS(object = rcbb, file = "rcbb.rds")
# # Remove the rows found in rcb from and rcbb from rcb
# rcb <- rcb[!rcb$RC_ID %in% rcbb$RC_ID,]
# # save both rcb and rcbb
# saveRDS(object = rcb, file = "rcb.rds")
# saveRDS(object = rcbb, file = "rcbb.rds")
# rccc <- rcc[924:1423,]
# # Remove the rows from rcc found in rccc
# rcc <- rcc[!rcc$RC_ID %in% rccc$RC_ID,]
# saveRDS(object = rccc, file = "rccc")

###################################################################################
# # RCBB ISOCHRONE CALCULATION
# # create a loop to find the isochrones for all retail centre centroids (20 minute walk time again)
# remove(i, isodf, rca_results, rciso, coordinates)

# remove(a)
# remove(isodf)
# remove(rciso)
# remove(coordinates)
# remove(ranges)
# remove(values)
# remove(rcwalktime20)
# remove(rcbb)
# 
# # rcc <- readRDS("rcc.rds")
# # #### Process rcaa
# rccc_results <- data.frame(matrix(ncol = 18, nrow = 0))
# # 
# # #############################################################################
# i = 0
# i = i + 1
# # #############################################################################
# for(i in 1:nrow(rccc)) {
#   # create a dataframe to hold the retail centres isochrone data for retail centres
#   rciso <- data.frame(matrix(ncol = 4, nrow = 0))
#   # create a df variable to hold the individual retail center row values from i
#   isodf = rccc[i,]
#   # embed data in the output file rather than html streaming option
#   mapviewOptions(fgb = FALSE)
#   #############################################################################
#   # Get the coordinates of the store in the (df)
#   coordinates <- data.frame(isodf$centoidgeom)
#   #coordinates <- data.frame(lon = isodf$Lon, lat = isodf$Lat)
#   # convert coordinates in to an sf file
#   coordinates = st_as_sf(coordinates)
#   # convert retail centres sf file to CRS 4326
#   coordinates <- st_transform(coordinates, crs = st_crs(4326))
# 
#   # split the geometry in coordinates to x and y
#   # Convert coordinates back to a dataframe
#   coordinates <- as.data.frame(st_coordinates(coordinates))
#   # rename x and y to Lon and Lat
#   coordinates <- coordinates  |>  rename_at('X', ~'Lon')
#   coordinates <- coordinates  |>  rename_at('Y', ~'Lat')
# 
#   #coordinates <- st_transform(coordinates, crs = st_crs(3857))
#   # Calculate a 20 minute walking time isochrone around the store
#   rcwalktime20 <- ors_isochrones(coordinates, range = 1200, interval = 1200,
#                                  output = "sf", profile = ors_profile("walking"))
#   values <- levels(factor(rcwalktime20$value))
#   ranges <- split(rcwalktime20, values)
#   ranges <- ranges[rev(values)]
#   names(ranges) <- sprintf("%s min", as.numeric(names(ranges))/60)
# 
#   # # Convert the walktime20 isochrone to the correct CRS
#   # # USE THIS AS THE ISOCHRONE
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(4326))
# 
#   # rename the walktime20 geometry column
#   rcwalktime20 <- rcwalktime20  |>  rename_at('geometry', ~'rcwalktime')
# 
# ###################################################################################
# # TEST PLOT RCWALKTIME
# # ggplot(rcwalktime20) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1)
# # This worked
# ###################################################################################
# 
#   # Join the calculated rcwalktime20 data to the rciso data
#   #jointoretail_c <- cbind(retail_c, rcwalktime20)
#   # rcwalktime20 <- st_transform(rcwalktime20, crs = st_crs(3857))
#   rcwalktime20 <- cbind(isodf$RC_ID, rcwalktime20)
#   rciso = rciso <- rbind(rciso,  rcwalktime20)
# 
#   # Combine the iso results to the row that was used to make the calculation from the rc_a file
#   a <- cbind(isodf, rciso)
#   rccc_results <- rbind(rccc_results, a)
#   # remove temp dataframes etc
#   remove(a, isodf, rciso, coordinates, ranges, values, rcwalktime20)
#   # Print (i) as a counter
#   cat(i, "completed\r")
#   Sys.sleep(3)
# }
# remove(i)
# # rca_results = (499)
# # saveRDS(object = rca_results, file = "rca_results.rds")
# 
# # rca_results = (2001)
# # saveRDS(object = rcaa_results, file = "rcaa_results.rds")
# 
# # rcbb_results = (498)
# # saveRDS(object = rcbb_results, file = "rcbb_results.rds")
# 
# # rcb_results = (2002)
# # saveRDS(object = rcb_results, file = "rcb_results.rds")
# 
# # rcc_results = (1423)
# saveRDS(object = rccc_results, file = "rccc_results.rds")
# # remove(rccc)
```

The population weighted centroids were then identified so that the LSOAs could be identified from them. Scorecards were then able to be calculated for each retail centre. Once the retail centre data was processed they were narrowed down to identify those that would be the best potential location for new zero waste stores. This was done by narrowing down the retail centre options through the production and analysis of the distributed scores based on various metrics.

1.  Those retail centres that scored a total that was the same as the mean of the stores total were located, and histograms of each variable and total score were created.
2.  Using those RCs that scored a total that fell within the minimum and maximum store total score range the distributions were visualised and investigated again through the use of a summary table distribution histograms.
3.  Retail centres were narrowed down to include only those that had a total score that was within the interquartile range of the stores total scores.
4.  Further filtering of the RCs was then done through identifying only those that scored a total that was the same as the mean for the stores total mean score (24).
5.  Finally, the final set of potential RCs were identified using the 5 variables and the total score of the stores data. Those RC variables that scored an average within +-1 of the same variable in the stores data were identified and only those that scored the same as the store mean score (24) for the total score were identified.

```{r rc_with_zws_prep}
# # Load the data required
# 
#  # Load Retail Centres data
 # rc_results <- readRDS("rc_results.rds")
#  # create a dataframe to hold the RCID and geometry for the isochrone
#  rc = select(rc_results, 2, 10)
#  # remove rc_results
#  # remove(rc_results)
#  # Convert rc to a sf format
#  rc = st_as_sf(rc)
# 
# # Load Lsoa data
# lsoas <- readRDS("lsoas.rds")
# lsoas = st_as_sf(lsoas)
# 
# # Load Population Weighted Centroid data and zws results
# lsoa_pwc <- readRDS("lsoa_pwc.rds")
# lsoa_pwc
# 
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# 
# # Find the retail centres that do not contain a store already
# # RCs WITH zws
# rc_with_zws = rc[zws_joined_lsoa_scr$zwsgeometry,]
# 
# # RCs WITHOUT zws##################################################################
# rc_no_zws = rc[!(rc$RC_ID  %in% rc_with_zws$RC_ID),]
# saveRDS(obj = rc_no_zws, file = "rc_no_zws.rds")
```

```{r rc_no_zws}
# ################# Prepare the retail centres data without a zws in them
# # PREPARE THE RETAIL CENTRE DATA
# # Get all the data for the retail centres
# rc_no_zws = rc_no_zws |> select(-3)
# rc_results = as.data.frame(rc_results)
# rc_no_zws = as.data.frame(rc_no_zws)
# rc_no_zws = inner_join(rc_no_zws, rc_results, by="RC_ID")
# 
# ## Remove retail centres from retail_c that are not required
# ### Remove retail centres that are not in England and Wales from retail_c
# rc_no_zws <- rc_no_zws[grep(c("Wales|England"), rc_no_zws$Country),]
# 
# # Clean the columns up
# rc_no_zws = rc_no_zws |> select(-one_of('rcgeometry.x'))
# rc_no_zws <- rc_no_zws  |>  rename_at('rcgeometry.y', ~'rcgeometry')
# 
# # Remove retail centres that are too large
# # Those zwstores that are located within a retail centre are mainly in :-
# # Town Centre
# # Small Local Centre
# # Local Centre
# # Market Town
# rc_no_zws <- rc_no_zws[grep(c("Town Centre|Small Local Centre|Local Centre|Market Town"), rc_no_zws$Classifica),]
# 
# 
# # Split he retail_c file in to chunks so that they can be processed and then re-combined
# 
# # Create the 2 temporary dataframes
# rc_1 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_2 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_3 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_4 <- data.frame(matrix(ncol = 20, nrow = 0))
# rc_5 <- data.frame(matrix(ncol = 20, nrow = 0))
# 
# # Move the relevant rows to the 5 new dataframes
# rc_1 <- rc_no_zws[rc_no_zws$Classifica == "Local Centre",]
# rc_2 <- rc_no_zws[rc_no_zws$Classifica == "Major Town Centre",]
# rc_3 <- rc_no_zws[rc_no_zws$Classifica == "Market Town",]
# rc_4 <- rc_no_zws[rc_no_zws$Classifica == "Small Local Centre",]
# rc_5 <- rc_no_zws[rc_no_zws$Classifica == "Town Centre",]
# 
# rc_a <- rbind(rc_1, rc_3)
# rc_b <- rbind(rc_2, rc_4, rc_5)
# 
# # remove the 5 temporary variables
# remove(rc_1, rc_2, rc_3, rc_4, rc_5)
# #remove(rc_a, rc_b)
# 
# # Split the rc_b file in to 2 leaving rc_b and rc_c
# rc_c <- tail(rc_b, -2500)
# rc_b = rc_b[!(rc_b$RC_ID %in% rc_c$RC_ID),]
# 
# ###################################################################################
# # with prep done, remove unrequired dataframes etc
# remove(rc, rc_with_zws)
```

```{r rc_scores}
# # # remove(joined_rc_results, rc_joined_lsoa_scr, rcs)
# # joined_rc_results <- readRDS("joined_rc_results.rds")
# # joined_rc_results <- joined_rc_results |> rename_at('geometry', ~'rcgeometry')
# # 
# # ##################################################################################
# # #                                                                                #
# # #          Calclate the isochrones around the retail centres without zws         #
# # #                                                                                #
# # ##################################################################################
# # # remove(i, rc_joined_lsoa_scr)
# # # # Load the data required
# # lsoa_pwc <- readRDS("lsoa_pwc.rds")
# # lsoas <- readRDS("lsoas.rds")
# # # # convert to sf
# # lsoa_pwc = st_as_sf(lsoa_pwc)
# # lsoas = st_as_sf(lsoas)
# # # 
# # # # # Find all the PWCs that appear in any of the rc_isochrones
# # st_geometry(joined_rc_results) <- "rcwalktime"
# # joined_rc_results$rcwalktime = st_transform(joined_rc_results$rcwalktime, crs = st_crs(3857))
# # joined_rc_results = st_as_sf(joined_rc_results)
# # pwc_in_rciso = lsoa_pwc[joined_rc_results$rcwalktime,]
# # # #
# # # ## # find all the pwc_in_rciso related LSOAs
# # lsoa_in_rciso = lsoas[(lsoas$LSOA21CD  %in% pwc_in_rciso$LSOA21CD),]
# # # 
# # # # Create a dataframe to hold all the joined results
# # rc_joined_lsoa_scr <- data.frame(matrix(ncol = 19, nrow = 0))
# # # 
# # # #initialise i
# # i = 0
# # i = i + 1
# # for (i in 1:nrow(joined_rc_results)) {
# # # 
# #   a = joined_rc_results[i,]
# # #   # Select the pwcs that appear in the isochrone for that (i) record in zwsiso
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(a) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = a$rcgeometry), alpha = 0.1, colour = "blue") +
# # # #   geom_sf(aes(geometry = a$rcwalktime), alpha = 0.1, colour = "red")
# # # #THIS WORKED
# # # ###################################################################################
# # # 
# # # # get all the pwcs that appear in the iso for that store
# # # a <- a  |>  rename_at('isogeometry', ~'geometry')
# # # a = st_transform(a$geometry, crs = st_crs(3857))
# # # 
# # # st_geometry(b) <- "geometry"
# # b = lsoa_pwc[a$rcwalktime,]
# # #   
# # #   # Check if (a) has 0 rows. If so, sack it off and move to the next record
# #  if(nrow(b) == 0) {
# #    cat(i, "..errored\r")
# #    next
# #  }
# # #   
# # #   # Convert a to a dataframe to manipulate it
# #   b = as.data.frame(b)
# # #   
# # #   # Get all the lsoas that relate to the pwcs just found
# #   c = lsoas[(lsoas$LSOA21CD %in% b$LSOA21CD),]
# # #   
# # #   #convert b to a dataframe
# #   c = as.data.frame(c)
# # #   
# # # ##### create a row in the b dataframe for the total for all lsoas in the area and the total mean of those totals
# #   c <- c |>
# #    bind_rows(summarise(c[9:14], across(where(is.numeric), mean),
# #                        across(where(is.character), ~'Total')))
# # #   
# # #   # Join the lsoas to a single shape so that a single line for this shape with the averages score can be used.
# # # 
# # #   # convert c to sf format
# #   c = st_as_sf(c)
# # #   
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(c) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = c$lsoageometry), alpha = 0.1)
# # # #THIS WORKED
# # # ################################################################################### 
# # #   # Join the lsoas together
# #   joined_lsoas <- st_union(c$lsoageometry)
# # #   
# # # ###################################################################################
# # # # TEST PLOT
# # #  # ggplot(joined_lsoas) +
# # #  #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # #  #   geom_sf(aes(geometry = joined_lsoas), alpha = 0.1, colour = "black")
# # # #THIS WORKED
# # # ###################################################################################
# # #   # Convert joined_lsoas to sf
# #   joined_lsoas = st_as_sf(joined_lsoas)
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(joined_lsoas) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = joined_lsoas$x), alpha = 0.1, colour = "blue")
# # # #THIS WORKED
# # # ###################################################################################
# # #   
# #   # combine the joined lsoa data and the score data
# #   joined_lsoas_c = cbind(joined_lsoas, c[nrow(c),9:14])
# #   #remove the empty multipolyon column
# #   joined_lsoas_c = as.data.frame(joined_lsoas_c)
# #   joined_lsoas_c = joined_lsoas_c |> dplyr::select(-one_of('lsoageometry'))
# #   # rename the x column to "joinedlsoageom"
# #   joined_lsoas_c <- joined_lsoas_c  |>  rename_at('x', ~'joinedlsoageom')
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # #   # ggplot(joined_lsoas_c) +
# # #   #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # #   #   geom_sf(aes(geometry = joined_lsoas_c$joinedlsoageom), alpha = 0.1, colou = "red")
# # # #THIS WORKED
# # # ###################################################################################
# # # 
# #   # retrieve the retail center ID from rc_final_results
# #   d = joined_rc_results[i,]
# # 
# #   # Join the retail center data, the scores, the joined LSOA geometry and the walktime geometry
# #   e = cbind(d, joined_lsoas_c)
# # # ###################################################################################
# # # # TEST PLOT
# # # # ggplot(e) +
# # # #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# # # #   geom_sf(aes(geometry = rcgeometry), colour = "green") +
# # # #   geom_sf(aes(geometry = rccentroidgeom), alpha = 0.1, colour = "black") +
# # # #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "red") +
# # # #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1, colour = "blue")
# # # # THIS WORKED
# # # ###################################################################################  
# #   # add this to a row in a new dataframe
# #   rc_joined_lsoa_scr <- rbind(rc_joined_lsoa_scr, e)
# # 
# #   # remove the temporary dataframes sf files etc
# #   remove(a, b, c, d, e, joined_lsoas, joined_lsoas_c)
# # 
# #   # Print (i) as a counter
# #   cat(i, "completed\r")
# # }
# # saveRDS(object = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
# 
# # # clean the rc_joined_lsoa_scr names and columns
# # # Round the scores to the nearest whole number
# # rc_joined_lsoa_scr = as.data.frame(rc_joined_lsoa_scr)
# # rc_joined_lsoa_scr = st_as_sf(rc_joined_lsoa_scr)
# # rc_joined_lsoa_scr <- rc_joined_lsoa_scr |>  mutate(across(c('lsoatotscr', 'carrank', 'dedrank', 'tenrank', 'occrank', 'pplrank'), round, 0))
# # # # 
# # # # # reindex the data
# # rownames(rc_joined_lsoa_scr) <- 1:nrow(rc_joined_lsoa_scr)
# # # Delete the irrelevant columns
# # rc_joined_lsoa_scr = rc_joined_lsoa_scr |> dplyr::select(-one_of('fid', "center", "value", 'group_index'))
# # # rename the columns that require renaming
# # rc_joined_lsoa_scr <- rc_joined_lsoa_scr  |>  rename_at('centoidgeom', ~'rccentroidgeom')
# # saveRDS(object = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # 
# # ###################################################################################
# # # # Convert all the geometries
# b = rc_joined_lsoa_scr[,c(1,19)]
# # b = as.data.frame(b)
# # b = b |> dplyr::select(-one_of('rcgeometry'))
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# 
# rc_joined_lsoa_scr$joinedlsoageom = b$joinedlsoageom
# 
# # # ###################################################################################
# # # # TEST PLOT
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # # # THIS WORKED
# # # ###################################################################################
# # # 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,18)]
# # remove rcgeometry
# # b = as.data.frame(b)
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rcwalktime = b$rcwalktime
# 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,17)]
# # remove rcgeometry
# # b = as.data.frame(b)
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rccentroidgeom = b$rccentroidgeom
# 
# remove(b)
# b = rc_joined_lsoa_scr[,c(1,16)]
# # remove rcgeometry
# # b = as.data.frame(b)
# # b = b |> select(-one_of('rcgeometry'))
# b = st_as_sf(b)
# b = st_transform(b, crs = st_crs(3857))
# rc_joined_lsoa_scr$rcgeometry = b$rcgeometry
# # # 
# # # ###################################################################################
# # # # TEST PLOT
# # # rc_joined_lsoa_scr <- st_as_sf(rc_joined_lsoa_scr)
# ggplot(rc_joined_lsoa_scr[67,]) +
#   annotation_map_tile(zoomin = 0, type = "osm") +
#   geom_sf(aes(geometry = joinedlsoageom, alpha = round(lsoatotscr, digits = 0)), colour = "blue") +
#   guides(alpha = guide_legend(title = "LSOAs total score")) +
#   geom_sf(aes(geometry = rcgeometry, colour = ""), colour = "black", alpha = 0.1) +
#   geom_sf(aes(geometry = rcwalktime, fill = ""), colour = "purple",alpha = 0.1) +
#   guides(fill = guide_legend(title = "Retail centre isochrone")) +
#   geom_sf(aes(geometry = rccentroidgeom), colour = "red")
# # # THIS WORKED
# # #################################################################################
# 
# # saveRDS(obj = rc_joined_lsoa_scr, file = "rc_joined_lsoa_scr.rds")
```

\FloatBarrier

```{r rc_minmax_hists, fig.height=4, fig.width=5, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that falls within the minimum and maximum score range for the zero waste stores."}
my_theme = readRDS("my_theme.rds")
rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# ###################################################################################
# # Using the range min-max
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (min(zws_joined_lsoa_scr$lsoatotscr)) & rc_joined_lsoa_scr$lsoatotscr <= (max(zws_joined_lsoa_scr$lsoatotscr))
# # 
# rc_in_zws_mm <- subset(rc_joined_lsoa_scr, identify_rows)
# remove(identify_rows)
# # 
# rcm1 <- ggplot(rc_in_zws_mm, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm2 <- ggplot(rc_in_zws_mm, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm3 <- ggplot(rc_in_zws_mm, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm4 <- ggplot(rc_in_zws_mm, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm5 <- ggplot(rc_in_zws_mm, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcm6 <- ggplot(rc_in_zws_mm, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # 
# plot_list_minmax <- list(rcm1, rcm2, rcm3, rcm4, rcm5, rcm6)
# saveRDS(object = plot_list_minmax, file = "plot_list_minmax.rds")
# remove(rcm1, rcm2, rcm3, rcm4, rcm5, rcm6)
plot_list_minmax <- readRDS("plot_list_minmax.rds")
do.call("grid.arrange", c(plot_list_minmax, ncol = 3))
remove(plot_list_minmax, rc_joined_lsoa_scr, zws_joined_lsoa_scr, my_theme)
```

\FloatBarrier

\newpage

# Results

```{r theme_setup}
# my_theme = theme(axis.text = element_text(size = 6), axis.title = element_text(size = 8))
# saveRDS(object = my_theme, file = "my_theme.rds")
```

\FloatBarrier

This section will analyse the results of the initial scorecard calculations for the locations containing zero waste stores. It will discuss the demographic composition of the 20 minute walking time catchment areas around the stores, and how the resulting scores may help to understand what makes these locations most suitable for this sector of retail.

### Zero waste stores scorecard

```{r}
# Remove the COGS store
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
zws_joined_lsoa_scr <- zws_joined_lsoa_scr[-c(128), ]
```

Once the scorecards for the 129 stores had been calculated, summary tables were produced. All scores were calculated as means, based on the number of LSOA that appeared within the isochrone catchment area for each location and rounded to the nearest integer. For example, the first record of the examples in table \ref{tab:allzwsscrtable} shows that the mean for each variable (*carrank*, *dedrank*, *occrank*, *pplrank*, and *tenrank*) were 6, 3, 4, 5 and 7 respectively, while the total mean score (*lsoatotscr*) was 26.

\FloatBarrier

```{r all_zws_scr_table}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
my_theme = readRDS("my_theme.rds")
a = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[1:5, c(2, 12:17)]))
kable(a, caption = "\\label{tab:allzwsscrtable}Scorecard table for first 5 zero waste stores")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |>
  column_spec(1,width = "0.5in") |>
  column_spec(2,width = "0.5in") |>
  column_spec(3,width = "0.5in") |>
  column_spec(4,width = "0.5in") |>
  column_spec(5,width = "0.5in") |>
  column_spec(6,width = "0.5in") |>
  column_spec(7,width = "0.5in")

remove(a, zws_joined_lsoa_scr, my_theme)
```

\FloatBarrier

Table \ref{tab:zws_scrsummary} shows the summary values for each variable. Across all 129 stores, the total scores out of a possible maximum of 50 (*lsoatotscr*) ranged from 15 through to 32, a mean of 24 and an interquartile range of between 22 to 27 was observed. The variables were scored out of a possible 10, and the greatest range of scores was seen in the *tenrank* variable which ranged from 1 to 9. The interquartile range of this variable was between 5 and 7 with a mean of 6. The smallest range was seen in the *carrank* variable which was between 3 and 7, and had an interquartile range of 0 (25th % and 75% were both 6) and a mean of 6.

\FloatBarrier

```{r zws_scrsums_tab}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
scrs_summary <- readRDS("scrs_summary.rds")
scrs_summary <- scrs_summary[-c(1:nrow(scrs_summary)), ]
my_theme = readRDS("my_theme.rds")
# carrank summary
c  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$carrank)))
c = as.data.frame(c)
c = rbind(nrow(zws_joined_lsoa_scr), c)
c <- c  |>  rename_at('c', ~'carrank total score summary value')
c = as.data.frame(t(c))
c <- c  |>  rename_at('1', ~'Total no. stores')
c = as.data.frame(t(c))
scrs_summary = as.data.frame(t(scrs_summary))
c = as.data.frame(t(c))
scrs_summary = as.data.frame(t(scrs_summary))
scrs_summary = rbind(scrs_summary, c)

# dedrank summary
d  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$dedrank)))
d = as.data.frame(d)
d = rbind(nrow(zws_joined_lsoa_scr), d)
d <- d  |>  rename_at('d', ~'dedrank total score summary value')
d = as.data.frame(t(d))
d <- d  |>  rename_at('1', ~'Total no. stores')
d = as.data.frame(t(d))
scrs_summary = as.data.frame(t(scrs_summary))
d = as.data.frame(t(d))
scrs_summary = as.data.frame(t(scrs_summary))
scrs_summary = rbind(scrs_summary, d)

# occrank summary
o  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$occrank)))
o = as.data.frame(o)
o = rbind(nrow(zws_joined_lsoa_scr), o)
o <- o  |>  rename_at('o', ~'occrank total score summary value')
o = as.data.frame(t(o))
o <- o  |>  rename_at('1', ~'Total no. stores')
o = as.data.frame(t(o))
scrs_summary = as.data.frame(t(scrs_summary))
o = as.data.frame(t(o))
scrs_summary = as.data.frame(t(scrs_summary))
scrs_summary = rbind(scrs_summary, o)

# pplrank summary
p  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$pplrank)))
p = as.data.frame(p)
p = rbind(nrow(zws_joined_lsoa_scr), p)
p <- p  |>  rename_at('p', ~'pplrank total score summary value')
p = as.data.frame(t(p))
p <- p  |>  rename_at('1', ~'Total no. stores')
p = as.data.frame(t(p))
scrs_summary = as.data.frame(t(scrs_summary))
p = as.data.frame(t(p))
scrs_summary = as.data.frame(t(scrs_summary))
scrs_summary = rbind(scrs_summary, p)

# tenrank summary
t  <- as.vector.data.frame(round(summary(zws_joined_lsoa_scr$tenrank)))
t = as.data.frame(t)
t = rbind(nrow(zws_joined_lsoa_scr), t)
t <- t  |>  rename_at('t', ~'tenrank total score summary value')
t = as.data.frame(t(t))
t <- t  |>  rename_at('1', ~'Total no. stores')
t = as.data.frame(t(t))
scrs_summary = as.data.frame(t(scrs_summary))
t = as.data.frame(t(t))
scrs_summary = as.data.frame(t(scrs_summary))
scrs_summary = rbind(scrs_summary, t)
saveRDS(object = scrs_summary, file = "scrs_summary.rds")

remove(a, c, d, o, p, t)

kable(scrs_summary, caption = "\\label{tab:zws_scrsummary}Scorecard summary table for all zero waste stores.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(zws_joined_lsoa_scr, a, c, d, o, p, t, scrs_summary, my_theme)
```

\FloatBarrier

To visualise this distribution of each the 129 stores, total and variable scores together, histogram plots were produced, and can be seen in figure \ref{fig:zw_scrs_hists}. The *lsoatotscr* (total scores) were distributed normally between 15 and 32. The *tenrank* variable was distributed widely with a negative skew. The variable for the households comprised two people without children (*pplrank*) was distributed fairly narrowly with a slight positive skew. The *occrank* and *dedrank* variables were more widely distributed and with a slight positive skew. The carrank variable was by contrast very narrowly distributed and showed a negative skew.

\FloatBarrier

```{r zw_scrs_hists, fig.cap="Histograms showing individual variable mean scores for all zero waste stores.", fig.width = 5, fig.height = 4}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
my_theme = readRDS("my_theme.rds")
# nrow(zws_joined_lsoa_scr)

zwh1 <- ggplot(zws_joined_lsoa_scr, aes(x=lsoatotscr)) +
  geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme

zwh2 <- ggplot(zws_joined_lsoa_scr, aes(x=tenrank)) +
  geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme

zwh3 <- ggplot(zws_joined_lsoa_scr, aes(x=pplrank)) +
  geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme

zwh4 <- ggplot(zws_joined_lsoa_scr, aes(x=occrank)) +
  geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme

zwh5 <- ggplot(zws_joined_lsoa_scr, aes(x=dedrank)) +
  geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme

zwh6 <- ggplot(zws_joined_lsoa_scr, aes(x=carrank)) +
  geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme

# Add the histograpms to a plot list
zwh_plot_list <- list(zwh1, zwh2, zwh3, zwh4, zwh5, zwh6)
saveRDS(object = zwh_plot_list, file = "zwh_plot_list.rds")
remove(zwh1, zwh2, zwh3, zwh4, zwh5, zwh6)
# Plot them together in a grid
zwh_plot_list <- readRDS("zwh_plot_list.rds")
do.call("grid.arrange", c(zwh_plot_list, ncol = 3))
remove(zwh_plot_list, zws_joined_lsoa_scr, my_theme)
```

\FloatBarrier

Figure \ref{fig:corr_plot} shows the correlation between the individual variables and the total scores. This visualises the varying strength of the relationships between the variables and between the total score (*lsoatotscr*). For example, the degree educated (*dedrank*), occupation (*occrank*) and home-ownership (*occrank*) variables all have a more positive linear relationship with the total score, than the vehicle access (*carrank*) and household composition (pplrank) variables. As expected, there is a strong positive correlation between the *dedrank* and *occrank* scores. Those variables that seemed to display a more negative relationship were between the *pplrank* and *dedrank*.

Less linear correlations can be seen in the relationship between the *tenrank* and, *dedrank* and *occrank* variables for example. As *tenrank* increases both *dedrank* and *occrank* decrease up to a certain point. After this point, they both increase at roughly the same rate.

\FloatBarrier

```{r corr_plot, fig.height=4, fig.width=5, fig.cap="Plot showing correlations between total scores and the 5 variables for the stores data."}
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
a_cor = as.data.frame(st_drop_geometry(zws_joined_lsoa_scr[,c(17,12:16)]))
cor_plot <- plot(a_cor, cex = 0.3,
     col = grey(0.145,alpha=0.5), upper.panel=panel.smooth)
remove(a_cor, zws_joined_lsoa_scr, cor_plot)
```

\FloatBarrier

So that a comparison could be made between the store(s) with the lowest and the store(s) with the highest score as seen in table \ref{tab:minmaxstore_tab} distribution histograms were produced side by side for comparison (see \ref{fig:minmaxcomp_plot}.

\FloatBarrier

```{r min_max_store_tab}
# Load the data to be used
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# minmaxstr <- readRDS("minmaxstr.rds")
# my_theme = readRDS("my_theme.rds")
# Get the store(s) with the lowest score
minstore = zws_joined_lsoa_scr[which.min(zws_joined_lsoa_scr$lsoatotscr), ]
# Save this for future reference
saveRDS(object = minstore, file = "minstore.rds")

# prepare it for the table
minstore =  as.data.frame(minstore[,c(2,3,12:17)])
minstore = st_as_sf(minstore)
minstore = st_drop_geometry(minstore)

# Get the store(s) with the highest score
maxstore = zws_joined_lsoa_scr[which.max(zws_joined_lsoa_scr$lsoatotscr), ]
# Save this for future reference
saveRDS(object = maxstore, file = "maxstore.rds")

# Prepare it for the table
maxstore =  as.data.frame(maxstore[,c(2,3,12:17)])
maxstore = st_as_sf(maxstore)
maxstore = st_drop_geometry(maxstore)

# Combine them ready for kable table
minmaxstr <- rbind(maxstore, minstore)

# Save this for future reference
saveRDS(object = minmaxstr, file = "minmaxstr.rds")

# Show the table for the 2 stores
kable(minmaxstr, row.names = F, caption = "\\label{tab:minmaxstore_tab}Summary table for zero waste store(s) with highest and lowest scores.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) |> 
  column_spec(1,width = "0.8in") |>
  column_spec(2,width = "0.8in") |>
  column_spec(3,width = "0.8in") |>
  column_spec(4,width = "0.8in") |>
  column_spec(5,width = "0.8in") |>
  column_spec(6,width = "0.8in")

# clean the dataframes from the environment
remove(zws_joined_lsoa_scr, minstore, maxstore, minmaxstr, my_theme)
```

The smallest difference between the individual scores in the these two stores was seen in the household composition (*pplrank*) variable with the lowest and highest scoring stores scored 2 and 4 respectively. The vehicle access variable (*carrank*) was also fairly low with the lowest to the highest scoring store being 5 and 8 respectively. All other variables were considerably higher for the store with the highest score, and the totals for each being 15 for the low scoring store and 32 for the highest store.

```{r minmaxcomp_plot, fig.cap="Histograms showing compairson between highest and lowest scoring stores variables and total scores"}
minstore <- readRDS("minstore.rds")
maxstore <- readRDS("maxstore.rds")
# create the dataframe for the plottble scores
minstr <- as.data.frame(minstore[,c(2,12:17)])
# change the data from wide to long
plotminstr <- gather(minstr, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)

# create the dataframe for the plottble scores
maxstr <- as.data.frame(maxstore[,c(2,12:17)])
# change the data from wide to long
plotmaxstr <- gather(maxstr, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)

# bind them together
plotcompare <- rbind(plotminstr, plotmaxstr)
# rename the columns
plotcompare <- plotcompare  |> dplyr::rename_at('st_nam', ~'Store_Name')

saveRDS(object = plotcompare, file = "plotcompare.rds")

# Load the data
plotcompare <- readRDS("plotcompare.rds")

# Plot it as a comparison
ggplot(plotcompare, aes(x = Store_Name, y= score, fill = variable)) +
  geom_histogram(stat="identity", width=0.9, position = "dodge") +
  scale_fill_brewer(palette="Dark2", name = "Variables (0-10)\n& total (0-50)") +
  xlab("Store Name") +
  scale_y_continuous(name="Score", breaks = seq(0, 50, by = 5), limits = c(0,50)) +
  geom_text(
    aes(label = score),
    position = position_dodge(0.9),
    vjust = -0.2)

remove(maxstore, maxstr, minstore, minstr, plotmaxstr, plotminstr, plotcompare)
remove(b, i, joined_rc_results, lsoa_in_rciso, lsoa_pwc, lsoas, pwc_in_rciso, rc_joined_lsoa_scr)
```

\FloatBarrier

These were then individually mapped so that a picture of the physical locations could be visualised and compared. Both stores appear to be located in urban areas of cities.

The highest scoring store as seen in \ref{fig:maxstr_map} is located within Teddington which is an area of South-West London in the borough of Richmond upon Thames. This is a relatively small residential area, with a small local retail centre in the middle (on which the store was found), and is surrounded by large areas of greenspace.

\FloatBarrier

```{r}
# Get the retail centres for the min and max stores
# Load the retail centres data
rcs <- readRDS("joined_rc_results.rds")
# Load the maxstore data
maxstore <- readRDS("maxstore.rds")

# Look to see if the store sits within a retail centre
rcmaxstr = rcs[maxstore$zwsgeometry,]
# Save the max store retail centre
saveRDS(object = rcmaxstr, file = "rcmaxstr.rds")
```

```{r maxstr_map, fig.height=4, fig.width=5, warning=FALSE, fig.cap="Map showing the store with the highest value scorecard and the variable averages for the location."}
maxstore <- readRDS("maxstore.rds")
rcmaxstr <- readRDS("rcmaxstr.rds")
maxstoremap <- 
  ggplot(maxstore) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
    geom_sf(data = rcmaxstr, aes(geometry = geometry, shape = rcmaxstr$Classifica), alpha = 0.1, colour = "blue") +
  guides(shape = guide_legend(title = "RC Classification", reverse = TRUE)) +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "red") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = maxstore$geometry, fill = maxstore$lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = st_nam)) +
  guides(colour = guide_legend(title = str_wrap("Store name", width = 15), reverse = TRUE)) +
  #   # North arrow and scale bar
  # annotation_scale(location = "br") +
  # annotation_north_arrow(location = "tr", 
  #                        which_north = "true", 
  #                        pad_x = unit(0.1, "in"), 
  #                        pad_y = unit(0.1, "in"),
  #                        style = north_arrow_minimal) +
  theme_void(base_size = 10 )

maxvarhead <- 
  ggplot(maxstore) + 
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

maxcarscr <-
  ggplot(maxstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

maxdedscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

maxoccscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxpplscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) + 
        theme_void()

maxtenscr <- 
  ggplot(maxstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void(margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"))

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = maxstoremap,
           B = maxvarhead,
           C = maxcarscr,
           D = maxdedscr,
           E = maxoccscr,
           F = maxpplscr,
           G = maxtenscr,
           design = layout)
remove(rcmaxstr,maxstore, maxstoremap, maxvarhead, maxcarscr, maxdedscr, maxoccscr, maxpplscr, maxtenscr, layout)
```

\FloatBarrier

The lowest scoring store as seen in \ref{fig:minstr_map} is located within the City of Leicester area which is in the Midlands of England. The store was found not to be located in a retail centre, but is situated on the campus of Leicester University. The isochrone however covers a large area of the city.

```{r}
# Get the retail centres for the min stores
# Load the retail centres data
# rcs <- readRDS("retail_c.rds")
# Load the minstore data
minstore <- readRDS("minstore.rds")

# Look to see if the store siits within a retail centre
rcminstr = rcs[minstore$zwsgeometry,]
# Save the min store retail centre
saveRDS(object = rcminstr, file = "rcminstr.rds")
```

```{r minstr_map, fig.height=4, fig.width=5, warning=FALSE, fig.cap="Map showing the store with the lowest value scorecard, and the variable averages for the location."}
rcminstr <- readRDS("rcminstr.rds")
minstore <- readRDS("minstore.rds")
minstoremap <- ggplot(minstore) +
  annotation_map_tile(zoomin = -1, type = "hotstyle") +
  geom_sf(aes(geometry = isogeometry, alpha = ""), colour = "red") +
  guides(alpha = guide_legend(title = "Catchment Area",reverse = TRUE)) +
  geom_sf(aes(geometry = minstore$geometry, fill = lsoatotscr), alpha = 0.2) +
  guides(fill = guide_legend(title = "LSOA Score", reverse = TRUE)) +
  geom_sf(aes(geometry = zwsgeometry, colour = st_nam)) +
  guides(colour = guide_legend(title = str_wrap("Store name", width = 15), reverse = TRUE)) +
    geom_sf(data = rcminstr, aes(geometry = geometry, shape = rcminstr$Classifica), alpha = 0.1, colour = "blue") +
  guides(shape = guide_legend(title = "RC Classification", reverse = TRUE)) +
  theme_void()

minvarhead <-
  ggplot(minstore) +
  geom_text(aes(label = paste("Variable Averages"),
                x = 1,
                y = 1)) +
      theme_void()

mincarscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("carrank \n", round(carrank, 2)),
                x = 1,
                y = 1)) +
        theme_void(margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"))

mindedscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("dedrank \n", round(dedrank, 2)),
                x = 1,
                y = 1)) +
      theme_void()

minoccscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("occrank \n", round(occrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

minpplscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("pplrank \n", round(pplrank, 2)),
                x = 1,
                y = 1)) +
        theme_void()

mintenscr <-
  ggplot(minstore) +
  geom_text(aes(label = paste("tenrank \n", round(tenrank, 2)),
                x = 1,
                y = 1)) +
    theme_void(base_size = 8)

layout <- '
AAAAA####
AAAAABBBB
AAAAACCCC
AAAAADDEE
AAAAAFFGG
AAAAA####
'

wrap_plots(A = minstoremap,
           B = minvarhead,
           C = mincarscr,
           D = mindedscr,
           E = minoccscr,
           F = minpplscr,
           G = mintenscr,
           design = layout)
remove(rcminstr, minstore, minstoremap, minvarhead, mincarscr, mindedscr, minoccscr, minpplscr, mintenscr, layout)
```

\FloatBarrier

```{r}
############### Try to fix zws_joined_lsoa_scr.rds geometries #####################
###################################################################################
# # Load zwsiso
# zwsdata <- readRDS("zws_joined_lsoa_scr.rds")
# a = as.data.frame(zwsdata)
# 
# # Try to fix zws_joined_lsoa_scr.rds geometries
# a$index <- 1:nrow(a)
# a = a |> select(index, everything())
# 
# b = a[,c(1,20)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$joinedlsoageom <- b$joinedlsoageom
# 
# b = a[,c(1,19)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$isogeometry <- b$isogeometry
# 
# b = a[,c(1,18)]
# b = st_as_sf(b)
# b
# b = st_transform(b, crs = st_crs(3857))
# 
# a$zwsgeometry <- b$zwsgeometry
# 
# ###################################################################################
# # # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1) +
# #   geom_sf(aes(geometry = zwsgeometry))
# # 
# ###################################################################################
# # # FINAL TEST
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# # #################################################################################
# zwsdata = a
# zwsdata = st_as_sf(zwsdata)
# 
# ###################################################################################
# # TEST PLOT
# # ggplot(a[92,]) +
# #   annotation_map_tile(zoomin = 0, type = "hotstyle") +
# #   geom_sf(aes(geometry = zwsgeometry)) +
# #   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
# #   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr = zwsdata
# zws_joined_lsoa_scr$zwsgeometry
# zws_joined_lsoa_scr$isogeometry
# zws_joined_lsoa_scr$joinedlsoageom
# 
# ###################################################################################
# # TEST PLOT
# ggplot(zws_joined_lsoa_scr[93,]) +
#   annotation_map_tile(zoomin = 0, type = "hotstyle") +
#   geom_sf(aes(geometry = zwsgeometry)) +
#   geom_sf(aes(geometry = isogeometry), alpha = 0.1) +
#   geom_sf(aes(geometry = joinedlsoageom), alpha = 0.1)
# ###################################################################################
# 
# saveRDS(obj = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")
```

```{r}
# # reindex the rc_joined_lsoa_scr data
# rownames(rc_joined_lsoa_scr) <- 1:nrow(rc_joined_lsoa_scr)
# ###################################################################################
# # TEST PLOT
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# # i = 0
# # i = i + 1
# # a = rc_joined_lsoa_scr[i,]
# # a
# # st_geometry(a) <- "rcwalktime"
# # a
# # st_geometry(a) <- "joinedlsoageom"
# # a
# # ggplot(rc_joined_lsoa_scr[1,]) +
# #   annotation_map_tile(zoomin = -1, type = "hotstyle") +
# #   geom_sf(aes(geometry = rccentroidgeom), colour = "black") +
# #   geom_sf(aes(geometry = rcgeometry), colour = "brown", alpha = 0.1) +
# #   geom_sf(aes(geometry = rcwalktime), alpha = 0.1, colour = "blue") +
# #   geom_sf(aes(geometry = joinedlsoageom, fill = lsoatotscr), alpha = 0.1, colour = "red")
# # THIS WORKED
# #################################################################################
```

\newpage

### Retail centres results

```{r join_rc_results, echo=FALSE}
# joined_rc_results <- rbind(rca_results, rcaa_results, rcb_results, rcbb_results, rcc_results, rccc_results)
# saveRDS(object = joined_rc_results, file = "joined_rc_results.rds")
# remove(rca_results, rcaa_results, rcb_results, rcbb_results, rcc_results, rccc_results)
```

A summary of the retail centre scores can be seen in table \ref{tab:rc_scrs_summary} below. A total of 5139 retail centres were processed. The total scores out of a possible 50, ranged from between 12 and 36. The mean was calculated to 23 with a median value of 22 and an interquartile range of between 20 and 25.

Again, each variable was scored out of 10, showing a very wide range of scores across all 5 individual variables, with *carrank* being the most narrow (between 2 and 8) and *tenrank* being the widest (between 1 and 10).

```{r rc_scrsums_tab}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
rc_scrs_summary <- readRDS("rc_scrs_summary.rds")
# totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_joined_lsoa_scr), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total score summary value')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_scrs_summary <- data.frame(matrix(ncol = 7, nrow = 0))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# l = as.data.frame(t(l))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_joined_lsoa_scr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# c = as.data.frame(t(c))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_joined_lsoa_scr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# d = as.data.frame(t(d))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_joined_lsoa_scr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# o = as.data.frame(t(o))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_joined_lsoa_scr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# p = as.data.frame(t(p))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_joined_lsoa_scr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_joined_lsoa_scr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# t = as.data.frame(t(t))
# rc_scrs_summary = as.data.frame(t(rc_scrs_summary))
# rc_scrs_summary = rbind(rc_scrs_summary, t)
# saveRDS(object = rc_scrs_summary, file = "rc_scrs_summary.rds")

kable(rc_scrs_summary, caption = "\\label{tab:rc_scrs_summary}Scorecard summary table for all retail centres.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary)
```

```{r}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# rc_scrs_summary <- readRDS("rc_scrs_summary.rds")
# 
# # Get the retail centre(s) with the lowest score
# rcmin = rc_joined_lsoa_scr[which.min(rc_joined_lsoa_scr$lsoatotscr), ]
# # Get the retail centre(s) with the highest score
# rcmax = rc_joined_lsoa_scr[which.max(rc_joined_lsoa_scr$lsoatotscr), ]
# 
# # create the dataframe for the plottble scores
# rcmin <- as.data.frame(rcmin[,c(2,3,10:15)])
# # change the data from wide to long
# plotminrc <- gather(rcmin, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)
# 
# # create the dataframe for the plottble scores
# rcmax <- as.data.frame(rcmax[,c(2,3,10:15)])
# # change the data from wide to long
# plotmaxrc <- gather(rcmax, variable, score, carrank, dedrank, occrank, pplrank, tenrank, lsoatotscr, factor_key=TRUE)
# 
# # bind them together
# rcplotcompare <- rbind(plotminrc, plotmaxrc)
# # rename the columns
# rcplotcompare <- rcplotcompare  |> dplyr::rename_at('RC_Name', ~'Retail_Centre_Name')
# saveRDS(object = rcplotcompare, file = "rcplotcompare.rds")
rcplotcompare <- readRDS("rcplotcompare.rds")

ggplot(rcplotcompare, aes(x = Retail_Centre_Name, y= score, fill = variable)) +
  geom_histogram(stat="identity", width=0.9, position = "dodge") +
  scale_fill_brewer(palette="Dark2", name = "Variables (0-10)\n& total (0-50)") +
  xlab("Retail Centre Name") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 40)) +
  scale_y_continuous(name="Score", breaks = seq(0, 50, by = 5), limits = c(0,50)) +
  geom_text(
    aes(label = score),
    position = position_dodge(0.9),
    vjust = -0.2)

remove(plotmaxrc, plotminrc, rc_joined_lsoa_scr, rc_scrs_summary, rcmax, rcmin, rcplotcompare)
```

\FloatBarrier

Distributions of all scores for all retail centres were produced. Figure \ref{fig:all_rc_hists} shows that all retail centres were distributed normally. The *tenrank* and *carrank* variables were negatively skewed with the *tenrank* widely distributed and *carrank* more narrowly distributed. The widely distributed *pplrank* and *occrank,* and narrowly distributed *dedrank* variables were all positively skewed.

```{r all_rc_hists, fig.cap="Histograms showing distributions for individual variable scores for all retail centres.", fig.width = 5, fig.height = 4}
# ###################################################################################
# All rc_total scores
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# rc_hist1 <- ggplot(rc_joined_lsoa_scr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rc_hist2 <- ggplot(rc_joined_lsoa_scr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist3 <- ggplot(rc_joined_lsoa_scr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist4 <- ggplot(rc_joined_lsoa_scr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist5 <- ggplot(rc_joined_lsoa_scr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# rc_hist6 <- ggplot(rc_joined_lsoa_scr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey")+ my_theme
# 
# plot_list_rchist <- list(rc_hist1, rc_hist2, rc_hist3, rc_hist4, rc_hist5, rc_hist6)
# saveRDS(object = plot_list_rchist, file = "plot_list_rchist.rds")
# remove(rc_hist1, rc_hist2, rc_hist3, rc_hist4, rc_hist5, rc_hist6)
plot_list_rchist <- readRDS("plot_list_rchist.rds")
do.call("grid.arrange", c(plot_list_rchist, ncol = 3))
remove(plot_list_rchist, rc_joined_lsoa_scr)
```

\FloatBarrier

Those retail centres that scored a total that fell within the interquartile range (22 to 27) of the stores scores were identified, and the summary results can be seen in table \ref{tab:rc_zwsiqr_scrs_summary} below.

The results here show that there were 2089 of these retail centres The lowest scoring variable was the *dedrank* variable which ranged from 0 to 7.

```{r rc_zwiqrsummary_tab}
# Load the data
# rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
# rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
# rc_in_zws_iqr <- readRDS("rc_in_zws_iqr.rds")
rc_zwsiqr_scrs_summary <- readRDS("rc_zwsiqr_scrs_summary.rds")
# # totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_in_zws_iqr), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nsit within the ZWS interquartile range.')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_zwsiqr_scrs_summary <- data.frame(matrix(ncol = 6, nrow = 0))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# l = as.data.frame(t(l))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_in_zws_iqr), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# c = as.data.frame(t(c))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_in_zws_iqr), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# d = as.data.frame(t(d))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_in_zws_iqr), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# o = as.data.frame(t(o))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_in_zws_iqr), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# p = as.data.frame(t(p))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_in_zws_iqr$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_in_zws_iqr), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# t = as.data.frame(t(t))
# rc_zwsiqr_scrs_summary = as.data.frame(t(rc_zwsiqr_scrs_summary))
# rc_zwsiqr_scrs_summary = rbind(rc_zwsiqr_scrs_summary, t)
# saveRDS(object = rc_zwsiqr_scrs_summary, file = "rc_zwsiqr_scrs_summary.rds")
# 
kable(rc_zwsiqr_scrs_summary, caption = "\\label{tab:rc_zwsiqr_scrs_summary}Scorecard summary table for all retail centres whos total scores sit within the ZWS stores interquartile range.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, rc_zwsiqr_scrs_summary, rc_in_zws_iqr)
```

\FloatBarrier

The distribution histograms as seen in \ref{fig:rc_iqr_hists} show that the widely distributed *tenrank* and narrowly distributed *carrank* variables were negatively skewed. The occrank and dedrank variables were more widely distributed than the pplrank variable and all were positively skewed to varying degrees.

```{r rc_iqr_hists, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that falls within the interquartile range of the zero waste stores total scores.", fig.width = 5, fig.height = 4}
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
# zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

# # ###################################################################################
# # # Using the interquartile range
# # # Find the 1st and 3rd Quartiles of the zws results
# a <- data.frame(unclass(summary(zws_joined_lsoa_scr$lsoatotscr)), check.names = F)
# # # rotate the dataframe
# a = a |> rotate_df()
# # 
# identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (a$`1st Qu.`) & rc_joined_lsoa_scr$lsoatotscr <= (a$`3rd Qu.`)
# # 
# rc_in_zws_iqr <- subset(rc_joined_lsoa_scr, identify_rows)
# # 
# rcq1 <- ggplot(rc_in_zws_iqr, aes(x=lsoatotscr)) +
#   geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq2 <- ggplot(rc_in_zws_iqr, aes(x=tenrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq3 <- ggplot(rc_in_zws_iqr, aes(x=pplrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq4 <- ggplot(rc_in_zws_iqr, aes(x=occrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq5 <- ggplot(rc_in_zws_iqr, aes(x=dedrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
# rcq6 <- ggplot(rc_in_zws_iqr, aes(x=carrank)) +
#   geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # 
# plot_list_iqr <- list(rcq1, rcq2, rcq3, rcq4, rcq5, rcq6)
# saveRDS(object = plot_list_iqr, file = "plot_list_iqr.rds")
# remove(rcq1, rcq2, rcq3, rcq4, rcq5, rcq6)
plot_list_iqr <- readRDS("plot_list_iqr.rds")
do.call("grid.arrange", c(plot_list_iqr, ncol = 3))
remove(plot_list_iqr, rc_joined_lsoa_scr, rc_in_zws_iqr, zws_joined_lsoa_scr, identify_rows, a)
```

\FloatBarrier

Due to the rounding of score values, the average total store score was calculated to 24. This was used to locate all the retail centres that also scored 24. There were 69 of these retail centres in total, and the summaries for the total and variables can be seen in table \ref{tab:rc_eqzws_scrs_summary} below.

```{r rc_eq_zw_ave_tab}
# Load the data
# rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
# rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
# 
# # totalscore summary
# l  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$lsoatotscr)))
# l = as.data.frame(l)
# l = rbind(nrow(rc_eq_zws_ave), l)
# l <- l  |>  rename_at('l', ~'Retail Centres total scores that\nmatch the ZWS average score')
# l = as.data.frame(t(l))
# l <- l  |>  rename_at('1', ~'Total no. retail centres')
# l = as.data.frame(t(l))
# rc_eqzws_scrs_summary <- data.frame(matrix(ncol = 6, nrow = 0))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# l = as.data.frame(t(l))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, l)
# 
# # carrank summary
# c  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$carrank)))
# c = as.data.frame(c)
# c = rbind(nrow(rc_eq_zws_ave), c)
# c <- c  |>  rename_at('c', ~'carrank total score summary value')
# c = as.data.frame(t(c))
# c <- c  |>  rename_at('1', ~'Total no. retail centres')
# c = as.data.frame(t(c))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# c = as.data.frame(t(c))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, c)
# 
# # dedrank summary
# d  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$dedrank)))
# d = as.data.frame(d)
# d = rbind(nrow(rc_eq_zws_ave), d)
# d <- d  |>  rename_at('d', ~'dedrank total score summary value')
# d = as.data.frame(t(d))
# d <- d  |>  rename_at('1', ~'Total no. retail centres')
# d = as.data.frame(t(d))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# d = as.data.frame(t(d))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, d)
# 
# # occrank summary
# o  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$occrank)))
# o = as.data.frame(o)
# o = rbind(nrow(rc_eq_zws_ave), o)
# o <- o  |>  rename_at('o', ~'occrank total score summary value')
# o = as.data.frame(t(o))
# o <- o  |>  rename_at('1', ~'Total no. retail centres')
# o = as.data.frame(t(o))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# o = as.data.frame(t(o))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, o)
# 
# # pplrank summary
# p  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$pplrank)))
# p = as.data.frame(p)
# p = rbind(nrow(rc_eq_zws_ave), p)
# p <- p  |>  rename_at('p', ~'pplrank total score summary value')
# p = as.data.frame(t(p))
# p <- p  |>  rename_at('1', ~'Total no. retail centres')
# p = as.data.frame(t(p))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# p = as.data.frame(t(p))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, p)
# 
# # tenrank summary
# t  <- as.vector.data.frame(round(summary(rc_eq_zws_ave$tenrank)))
# t = as.data.frame(t)
# t = rbind(nrow(rc_eq_zws_ave), t)
# t <- t  |>  rename_at('t', ~'tenrank total score summary value')
# t = as.data.frame(t(t))
# t <- t  |>  rename_at('1', ~'Total no. retail centres')
# t = as.data.frame(t(t))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# t = as.data.frame(t(t))
# rc_eqzws_scrs_summary = as.data.frame(t(rc_eqzws_scrs_summary))
# rc_eqzws_scrs_summary = rbind(rc_eqzws_scrs_summary, t)
# saveRDS(object = rc_eqzws_scrs_summary, file = "rc_eqzws_scrs_summary.rds")

rc_eqzws_scrs_summary <- readRDS("rc_eqzws_scrs_summary.rds")
kable(rc_eqzws_scrs_summary, caption = "\\label{tab:rc_eqzws_scrs_summary}Scorecard summary table for all retail centres that total the same as the ZWS average.")|>
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8)

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave)
```

\FloatBarrier

The distribution histograms seen in figure \ref{fig:zwmeanrc_hists} below show the single average total score (24) for the retail centres. The variables were fairly narrowly distributed with *tenrank*, *pplrank* and *carrank* all negatively skewed, and *occrank* and *dedrank* positively skewed. the *tenrank* and *carrank* variables seemed to be particularly high scoring among these retail centres, while the *dedrank* variable seems particularly low on average.

```{r rc_zws_mean_hists, fig.height=4, fig.width=5, fig.cap="Histograms showing individual variable scores for the retail centres that score a total that equals the mean score for the zero waste stores."}
# Find the mean total score for the zero waste stores
# Load the data required
 # zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")
 # rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")
 my_theme <- readRDS("my_theme.rds")
 plot_list_ave <- readRDS("plot_list_ave.rds")
# # # Find and round the average zws score to the nearest while number
#  zws_ave = round(mean(zws_joined_lsoa_scr$lsoatotscr))
# #
# # # Identify the rows in the retail centre total score data that match the average total score for the stores data
#  identify_rows <- rc_joined_lsoa_scr$lsoatotscr >= (zws_ave) & rc_joined_lsoa_scr$lsoatotscr <= (zws_ave)
# #
# # # Get the rows identified as matching the zws mean score
#  rc_eq_zws_ave <- subset(rc_joined_lsoa_scr, identify_rows)
# #
# rcnum = as.data.frame(nrow(rc_eq_zws_ave))
# # # Plot these distributions
#  rca1 <- ggplot(rc_eq_zws_ave, aes(x=lsoatotscr)) +
#    geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + 
#      geom_text(stat="bin", label = rcnum, vjust = -0.2, size = 3) +
#    my_theme
# # #
#  rca2 <- ggplot(rc_eq_zws_ave, aes(x=tenrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca3 <- ggplot(rc_eq_zws_ave, aes(x=pplrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca4 <- ggplot(rc_eq_zws_ave, aes(x=occrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca5 <- ggplot(rc_eq_zws_ave, aes(x=dedrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # #
#  rca6 <- ggplot(rc_eq_zws_ave, aes(x=carrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# # # #
#  plot_list_ave <- list(rca1, rca2, rca3, rca4, rca5, rca6)
#  saveRDS(object = plot_list_ave, file = "plot_list_ave.rds")
#  plot_list_ave <- readRDS("plot_list_ave.rds")
 do.call("grid.arrange", c(plot_list_ave, ncol = 3))
 remove(rca1, rca2, rca3, rca4, rca5, rca6, plotmaxrc, plotminrc, rc_eq_zws_ave, rc_joined_lsoa_scr, rc_scrs_summary, rcmax, rcmin, rcplotcompare, zws_ave, zws_joined_lsoa_scr, my_theme, plot_list_ave, identify_rows, rcnum)
```

```{r zwmeanrc_hists, fig.cap="Histograms showing total and individual variable scores for the retail centres that score a total which matches the mean store total score.", fig.width = 5, fig.height = 4}
# zws_ave <- readRDS("zws_ave.rds")
# rc_joined_lsoa_scr <- readRDS("rc_joined_lsoa_scr.rds")

# # # Find the retail centres where the totalscore is equal to the zws average total score
# rc_eq_zws_ave = rc_joined_lsoa_scr[rc_joined_lsoa_scr$lsoatotscr == zws_ave, ]
# 
# saveRDS(obj = rc_eq_zws_ave, file = "rc_eq_zws_ave.rds")
# rc_eq_zws_ave <- readRDS("rc_eq_zws_ave.rds")
# nrow(rc_eq_zws_ave)
# individual variable scores for the retail centres that score a total that matches the mean store total score
#  zrc1 <- ggplot(rc_eq_zws_ave, aes(x=lsoatotscr)) +
#    geom_histogram(breaks = seq(0, 50, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
#  zrc2 <- ggplot(rc_eq_zws_ave, aes(x=tenrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
#  zrc3 <- ggplot(rc_eq_zws_ave, aes(x=pplrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
#  zrc4 <- ggplot(rc_eq_zws_ave, aes(x=occrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
#  zrc5 <- ggplot(rc_eq_zws_ave, aes(x=dedrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# 
#  zrc6 <- ggplot(rc_eq_zws_ave, aes(x=carrank)) +
#    geom_histogram(breaks = seq(0, 10, by = 1), colour = "orange", fill = "darkgrey") + my_theme
# #  
# #  # Add the histograms to a plot list
#  zrc_plot_list <- list(zrc1, zrc2, zrc3, zrc4, zrc5, zrc6)
#  # saveRDS(object = zrc_plot_list, file = "zrc_plot_list.rds")
#  remove(zrc1, zrc2, zrc3, zrc4, zrc5, zrc6)
#  # Plot them together in a grid
my_theme = readRDS("my_theme.rds")
zrc_plot_list <- readRDS("zrc_plot_list.rds")
do.call("grid.arrange", c(zrc_plot_list, ncol = 3))
remove(zrc_plot_list, rc_eq_zws_ave, rc_joined_lsoa_scr, my_theme, zws_ave)
```

\FloatBarrier

Finally, the final set of potential retail centres that scored an average within +-1 of the same variable in the stores data, including the exact mean score (24) for the total score were identified.

```{r rc_eq_zws_ave_tab}
# Load the data
# zws_joined_lsoa_scr <- as.data.frame(readRDS("zws_joined_lsoa_scr.rds"))
# rc_joined_lsoa_scr <- as.data.frame(readRDS("rc_joined_lsoa_scr.rds"))
zwsmeans <- as.data.frame(readRDS("zwsmeans.rds"))
allmatches <- as.data.frame(readRDS("allmatches.rds"))
# # Get the column names for the scores
# zwcolnames <- as.data.frame(t(colnames(st_drop_geometry(zws_joined_lsoa_scr[,12:17]))))
# # Create a dataframe to hold the mean scores
# zwsmeans <- data.frame(matrix(ncol = 6, nrow = 1))
# # Change the column names
# colnames(zwsmeans) <- zwcolnames
# 
# # Add the mean scores for each of the variables to the mean dataframe
# zwsmeans$carrank = round(mean(zws_joined_lsoa_scr$carrank), digits = 0)
# zwsmeans$dedrank = round(mean(zws_joined_lsoa_scr$dedrank), digits = 0)
# zwsmeans$occrank = round(mean(zws_joined_lsoa_scr$occrank), digits = 0)
# zwsmeans$pplrank = round(mean(zws_joined_lsoa_scr$pplrank), digits = 0)
# zwsmeans$tenrank = round(mean(zws_joined_lsoa_scr$tenrank), digits = 0)
# zwsmeans$lsoatotscr = round(mean(zws_joined_lsoa_scr$lsoatotscr), digits = 0)
# remove(zwcolnames, zws_joined_lsoa_scr)
# 
# # Use this mean dataframe to find the retail centres that have scores that match this data.
# 
# allmatches <- subset(rc_joined_lsoa_scr, lsoatotscr == zwsmeans$lsoatotscr)
# 
# allmatches <- subset(allmatches, (carrank > zwsmeans$carrank-1) & (carrank < zwsmeans$carrank+1))
# 
# allmatches <- subset(allmatches, (dedrank > zwsmeans$dedrank-1) & (dedrank < zwsmeans$dedrank+1))
# 
# allmatches <- subset(allmatches, (occrank > zwsmeans$occrank-1) & (occrank < zwsmeans$occrank+1))
# 
# allmatches <- subset(allmatches, (pplrank > zwsmeans$pplrank-1) & (pplrank < zwsmeans$pplrank+1))
# 
# allmatches <- subset(allmatches, (tenrank > zwsmeans$tenrank-1) & (tenrank < zwsmeans$tenrank+1))
# 
# allmatches[, 11:16] <- round(allmatches[, 11:16])
# 
# #   row_spec(0,bold = T, font_size = 8)
# 
# row.names(allmatches) <- NULL

kable(allmatches[,c(2:3, 11:16)], caption = "\\label{tab:allmatches}Scorecard summary table for all retail centres that contain all variable scores that sit within +-1 of mean zero wastte store variable scores, and match the mean total store score.") |> 
  kable_styling(full_width = FALSE,latex_options = c("HOLD_position"), font_size = 8)|>
  row_spec(0,bold = T, font_size = 8) 
  # column_spec(1,width = "0.5in") |> 
  # column_spec(2,width = "0.1in") |>
  # column_spec(3,width = "0.1in") |>
  # column_spec(4,width = "0.1in") |>
  # column_spec(5,width = "0.1in") |>
  # column_spec(6,width = "0.1in") |>
  # column_spec(7,width = "0.1in") |>
  # column_spec(8,width = "0.1in") |>
  # column_spec(9,width = "0.1in")

#saveRDS(object = zwsmeans, file = "zwsmeans.rds")
#saveRDS(object = allmatches, file = "allmatches.rds")

remove(rc_joined_lsoa_scr, a, c, d, o, p, t, l, rc_scrs_summary, rc_eqzws_scrs_summary, rc_eq_zws_ave, allmatches, zwsmeans)
```

```{r zws_rc_join}
remove(a, i, z, rc_with_zws, retail_c, b, zws_joined_lsoa_scr, all_rcs)
rc_with_zws <- readRDS("rc_with_zws.rds")
# retail_c <- readRDS("retail_c.rds")
zws_joined_lsoa_scr <- readRDS("zws_joined_lsoa_scr.rds")

###############################################################################
# ALL RETAIL CENTRES SETUP
all_rcs <- read_sf('all_retailcentres.shp')
saveRDS(object = all_rcs, file = "all_rcs.rds")

all_rcs <- readRDS('all_rcs.rds')
all_rcs = st_transform(all_rcs, crs = st_crs(3857))
##############################################################################

# delete the RC geometry column
zws_joined_lsoa_scr = as.data.frame(zws_joined_lsoa_scr)
zws_joined_lsoa_scr = zws_joined_lsoa_scr |> dplyr::select(-one_of('V21'))
zws_joined_lsoa_scr = st_as_sf(zws_joined_lsoa_scr)

# Create a blank dataframe to hold the new data ready to copy to the zws data
b <- data.frame(matrix(ncol = 22, nrow = 0))

# set up the counter
i = 0
i = i + 1
missingrcs = 0
# Start the loop
for(i in 1:nrow(zws_joined_lsoa_scr)) {
  # take the i row of zws_joined_lsoa_scr
 z = zws_joined_lsoa_scr[i,]
 # # Set the active geometry column
  # st_geometry(z) <- "rcgeometry"
 # get the retail centre that i sits in
 a = all_rcs[z,]

 # check to see of the store is contaned within a retail centre
   if(nrow(a) == 0) {
     cat(i, "No Coordinates\r")
# Add the row from z to the b dataframe 
    z = cbind(z, a[i,c(4,10)])
  b = rbind(b, z)
  missingrcs = missingrcs + 1
   next
 }
dammt = cbind(z, a[,c(4,10)])
# Add the row from z to the b dataframe 
  b = rbind(b, dammt)

# remove a and z
  remove(a, z, dammt)

##   # print i as a count of rows that have completed
 cat(i, ".....completed\r")
  # Sys.sleep(1)

}
# Make the zwsjoined dataframe the same as the b dataframe
zws_joined_lsoa_scr[,c(21:22)] = b[,c(18,22)]
saveRDS(object = zws_joined_lsoa_scr, file = "zws_joined_lsoa_scr.rds")

remove(a, i, z, rc_with_zws, retail_c, b, all_rcs)
```

\newpage

# Discussion

WRITE THE DISCUSSION HERE

do some writing

In **Coventry**, **15.4%** of the population was income-deprived in 2019. Of the 316 local authorities in England (excluding the Isles of Scilly), Coventry is ranked **68th most income-deprived** [@officefornationalstatistics2021]

In **Richmond upon Thames**, **6.4%** of the population was income-deprived in 2019. Of the 316 local authorities in England (excluding the Isles of Scilly), Richmond upon Thames is ranked \*\*282nd most income-deprived [\*\* @officefornationalstatistics2021].

which may suggest variation in the demographic composition of the areas in which these stores were found.

=AVERAGE - maybe because all retail centres (69) are in locations with a high proportion of homeowners

would have thought pplscr would have been more important due to shared incomes and no children, but this did not seem to be very correlated to increase in total scores

\newpage

# Limitations

OA scale data would have been better

House prices would be a good measure of wealth perhaps (See Teddington vs Coventry stores)

\newpage

# Conclusions

WRITE THE CONCLUSIONS HERE

\newpage

# Bibliography

::: {#refs}
\noindent \vspace{-2em} \setlength{\parindent}{-0.5in} \setlength{\leftskip}{0.5in} \setlength{\parskip}{15pt}
:::
